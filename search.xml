<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java程序员Chrome浏览器必装插件</title>
    <url>/archives/b0de6b16.html</url>
    <content><![CDATA[<p>整理了一下自己一直在用的Chrome浏览器插件,之后有觉得好用的也会更新进来</p><h2 id="SQLDelimiter"><a href="#SQLDelimiter" class="headerlink" title="SQLDelimiter"></a><a href="https://chrome.google.com/webstore/detail/sqldelimiter/ngobnmgdnggmcafeblbealjjnpakoghd" target="_blank" rel="noopener">SQLDelimiter</a></h2><p>参数拆分插件,从Excel直接复制或者MySQL查询结果复制,直接转化成带逗号分隔<br><img src="/images/loading.png" data-original="/images/pasted-3.png" alt="upload successful"></p><h2 id="JSON-handle"><a href="#JSON-handle" class="headerlink" title="JSON-handle"></a><a href="https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj" target="_blank" rel="noopener">JSON-handle</a></h2><a id="more"></a>

<p>Json格式化或者转成更好看的形式,方便检查数据<br><img src="/images/loading.png" data-original="/images/pasted-4.png" alt="upload successful"></p>
<h2 id="JSON-Formatter"><a href="#JSON-Formatter" class="headerlink" title="JSON Formatter"></a><a href="https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa" target="_blank" rel="noopener">JSON Formatter</a></h2><p>直接格式化http请求返回的json内容</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>插件</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员必须知道的linux命令</title>
    <url>/archives/b77c3e4.html</url>
    <content><![CDATA[<h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find / -name filename.txt 根据名称查找/目录下的filename.txt文件。</span><br><span class="line">find . -name &quot;*.xml&quot; 递归查找所有的xml文件</span><br><span class="line">find .  -name &quot;*.xml&quot; |xargs grep  &quot;hello world&quot; 递归查找所有文件内容中包含hello world的xml文件</span><br><span class="line">grep -H  &apos;spring&apos; *.xml 查找所以有的包含spring的xml文件</span><br><span class="line">find ./ -size 0 | xargs rm -f &amp; 删除文件大小为零的文件</span><br><span class="line">ls -l | grep &apos;jar&apos; 查找当前目录中的所有jar文件</span><br><span class="line">grep &apos;test&apos; d* 显示所有以d开头的文件中包含test的行。</span><br><span class="line">grep &apos;test&apos; aa bb cc 显示在aa，bb，cc文件中匹配test的行。</span><br><span class="line">grep &apos;[a-z]\&#123;5\&#125;&apos; aa 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</span><br></pre></td></tr></table></figure><a id="more"></a>
<h3 id="查看一个程序是否运行"><a href="#查看一个程序是否运行" class="headerlink" title="查看一个程序是否运行"></a>查看一个程序是否运行</h3><p><code>ps –ef|grep tomcat 查看所有有关tomcat的进程</code></p>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p><code>kill -9 19979 终止线程号位19979的线程</code></p>
<h3 id="查看文件，包含隐藏文件"><a href="#查看文件，包含隐藏文件" class="headerlink" title="查看文件，包含隐藏文件"></a>查看文件，包含隐藏文件</h3><p><code>ls -al</code></p>
<h3 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h3><p><code>pwd</code></p>
<h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp  source dest 复制文件</span><br><span class="line">cp -r  sourceFolder targetFolder 递归复制整个文件夹</span><br><span class="line">scp sourecFile romoteUserName@remoteIp:remoteAddr 远程拷贝</span><br></pre></td></tr></table></figure>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p><code>mkdir newfolder</code></p>
<h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><p><code>rmdir deleteEmptyFolder 删除空目录 rm -rf deleteFile 递归删除目录中所有内容</code></p>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p><code>mv /temp/movefile /targetFolder</code></p>
<h3 id="重命令"><a href="#重命令" class="headerlink" title="重命令"></a>重命令</h3><p><code>mv oldNameFile newNameFile</code></p>
<h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p><code>su -username</code></p>
<h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p><code>chmod 777 file.java //file.java的权限-rwxrwxrwx，r表示读、w表示写、x表示可执行</code></p>
<h3 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h3><p><code>tar -czf test.tar.gz /test1 /test2</code></p>
<h3 id="列出压缩文件列表"><a href="#列出压缩文件列表" class="headerlink" title="列出压缩文件列表"></a>列出压缩文件列表</h3><p><code>tar -tzf test.tar.gz</code></p>
<h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><p><code>tar -xvzf test.tar.gz</code></p>
<h3 id="查看文件头10行"><a href="#查看文件头10行" class="headerlink" title="查看文件头10行"></a>查看文件头10行</h3><p><code>head -n 10 example.txt</code></p>
<h3 id="查看文件尾10行"><a href="#查看文件尾10行" class="headerlink" title="查看文件尾10行"></a>查看文件尾10行</h3><p><code>tail -n 10 example.txt</code></p>
<h3 id="查看日志类型文件"><a href="#查看日志类型文件" class="headerlink" title="查看日志类型文件"></a>查看日志类型文件</h3><p><code>tail -f exmaple.log //这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。</code></p>
<h3 id="使用超级管理员身份执行命令"><a href="#使用超级管理员身份执行命令" class="headerlink" title="使用超级管理员身份执行命令"></a>使用超级管理员身份执行命令</h3><p><code>sudo rm a.txt 使用管理员身份删除文件</code></p>
<h3 id="查看端口占用情况"><a href="#查看端口占用情况" class="headerlink" title="查看端口占用情况"></a>查看端口占用情况</h3><p><code>netstat -tln | grep 8080 查看端口8080的使用情况</code></p>
<h3 id="查看端口属于哪个程序"><a href="#查看端口属于哪个程序" class="headerlink" title="查看端口属于哪个程序"></a>查看端口属于哪个程序</h3><p><code>lsof -i :8080</code></p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps aux|grep java 查看java进程</span><br><span class="line">ps aux 查看所有进程</span><br></pre></td></tr></table></figure>
<h3 id="以树状图列出目录的内容"><a href="#以树状图列出目录的内容" class="headerlink" title="以树状图列出目录的内容"></a>以树状图列出目录的内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tree a</span><br><span class="line">ps:Mac下使用tree命令</span><br></pre></td></tr></table></figure>
<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://file.tgz mac下安装wget命令</span><br><span class="line">curl http://file.tgz</span><br></pre></td></tr></table></figure>
<h3 id="网络检测"><a href="#网络检测" class="headerlink" title="网络检测"></a>网络检测</h3><p><code>ping www.taobao.com</code></p>
<h3 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h3><p><code>ssh userName@ip</code></p>
<h3 id="打印信息"><a href="#打印信息" class="headerlink" title="打印信息"></a>打印信息</h3><p>echo $JAVA_HOME 打印java home环境变量的值</p>
<h3 id="java-常用命令"><a href="#java-常用命令" class="headerlink" title="java 常用命令"></a>java 常用命令</h3><p><code>java javac jps ,jstat ,jmap, jstack</code></p>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p><code>svn git maven</code></p>
<h3 id="linux命令学习网站"><a href="#linux命令学习网站" class="headerlink" title="linux命令学习网站:"></a>linux命令学习网站:</h3><p><a href="http://explainshell.com/" target="_blank" rel="noopener">http://explainshell.com/</a></p>
<h3 id="修改机器名"><a href="#修改机器名" class="headerlink" title="修改机器名"></a>修改机器名</h3><pre><code>更改/etc/sysconfig下的network文件，在提示符下输入vi /etc/sysconfig/network，然后将HOSTNAME后面的值改为想要设置的主机名，在提示符下输入reboot命令，重新启动服务器。</code></pre><h3 id="解压nginx日志"><a href="#解压nginx日志" class="headerlink" title="解压nginx日志"></a>解压nginx日志</h3><pre><code>现在nginx日志用gzip压缩，文件以gz结尾。

解压命令： gzip -d  压缩文件名 
不解压，直接查看压缩文件内容，命令： gunzip -c  压缩文件名</code></pre><h3 id="测试磁盘的读写"><a href="#测试磁盘的读写" class="headerlink" title="测试磁盘的读写"></a>测试磁盘的读写</h3><pre><code> time有计时作用，dd用于复制，从if读出，写到of。if=/dev/zero不产生IO，因此可以用来测试纯写速度。同理of=/dev/null不产生IO，可以用来测试纯读速度。bs是每次读或写的大小，即一个块的大小，count是读写块的数量。

纯写速度： time dd if=/dev/zero of=/var/test bs=8k count=10000

 纯读速度：time dd if=/var/test of=/dev/null bs=8k</code></pre><h3 id="linux端口连接范围-gt-gt-gt-gt-gt-用于向外连接的端口范围"><a href="#linux端口连接范围-gt-gt-gt-gt-gt-用于向外连接的端口范围" class="headerlink" title="linux端口连接范围&gt;&gt;&gt;&gt;&gt;用于向外连接的端口范围"></a>linux端口连接范围&gt;&gt;&gt;&gt;&gt;用于向外连接的端口范围</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/ip_local_port_range</span><br><span class="line">net.ipv4.ip_local_port_range=1024 65000</span><br></pre></td></tr></table></figure>
<h3 id="修改打开文件最大数，vi-etc-security-limits-conf-加入以下两行"><a href="#修改打开文件最大数，vi-etc-security-limits-conf-加入以下两行" class="headerlink" title="修改打开文件最大数，vi /etc/security/limits.conf,加入以下两行"></a>修改打开文件最大数，vi /etc/security/limits.conf,加入以下两行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* soft nofile 402400</span><br><span class="line">* hard nofile 480000</span><br></pre></td></tr></table></figure>
<p>然后重新登录即可使用命令ulimit -a 查看到修改。在这之前启动的进程仍旧使用以前的配置，之后启动的进程使用最新配置<br>用ulimit -n 2048 修改只对当前的shell有效，退出后失效</p>
<h3 id="tcp连接复用和快速回收"><a href="#tcp连接复用和快速回收" class="headerlink" title="tcp连接复用和快速回收"></a>tcp连接复用和快速回收</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br></pre></td></tr></table></figure>
<p><code>net.ipv4.tcp_keepalive_time = 1200</code>表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</p>
<p><code>net.ipv4.ip_local_port_range = 1024</code> 65535表示用于向外连接的端口范围。缺省情况下过窄：32768到61000，改为1024到65535。</p>
<p><code>net.ipv4.tcp_max_syn_backlog = 16384</code><br>表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。 </p>
<p><code>net.ipv4.tcp_max_tw_buckets = 180000</code> </p>
<p>表示系统同时保持TIME_WAIT套接字的最大数 量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000,可适当增大该值，但不建议减小。对于Apache、 Nginx等服务器，以上几行参数的设置可以很好地减少TIME_WAIT套接字数量，但是对于Squid，效果却不大。此项参数可以控制 TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time = 180</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 15</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 2</span><br><span class="line">net.ipv4.tcp_fin_timeout = 5</span><br><span class="line"></span><br><span class="line">nf_conntrack: table full, dropping packet.</span><br></pre></td></tr></table></figure>


<h3 id="查看NS提供商"><a href="#查看NS提供商" class="headerlink" title="查看NS提供商"></a>查看NS提供商</h3><p><code>dig baidu.com NS trace @8.8.8.8</code></p>
<h3 id="指定NS解析域名"><a href="#指定NS解析域名" class="headerlink" title="指定NS解析域名"></a>指定NS解析域名</h3><p> <code>nslookup www.baidu.com</code></p>
<h3 id="sz-rz安装"><a href="#sz-rz安装" class="headerlink" title="sz/rz安装"></a>sz/rz安装</h3><p>（1）编译安装</p>
<p>root 账号登陆后，依次执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line"></span><br><span class="line">wget http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxvf lrzsz-0.12.20.tar.gz &amp;&amp; cd lrzsz-0.12.20</span><br><span class="line"></span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>上面安装过程默认把lsz和lrz安装到了/usr/local/bin/目录下，现在我们并不能直接使用，下面创建软链接，并命名为rz/sz：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/bin</span><br><span class="line">ln -s /usr/local/bin/lrz rz</span><br><span class="line">ln -s /usr/local/bin/lsz sz</span><br></pre></td></tr></table></figure>


<p>（2）yum安装</p>
<p>root 账号登陆后执行以下命令：</p>
<p><code>yum install -y lrzsz</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Meno</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql数据库配置优化</title>
    <url>/archives/692ce8b8.html</url>
    <content><![CDATA[<h1 id="tmp-table-size-临时表-用于排序"><a href="#tmp-table-size-临时表-用于排序" class="headerlink" title="tmp_table_size 临时表 (用于排序)"></a>tmp_table_size 临时表 (用于排序)</h1><p>show global status like ‘created_tmp%’; </p><p>| Variable_name | Value | </p><p>| Created_tmp_disk_tables | 21197 | #在磁盘上创建临时表的次数 </p><a id="more"></a>


<p>| Created_tmp_files | 58 | #在磁盘上创建临时文件的次数</p>
<p>| Created_tmp_tables | 1771587 | #使用临时表的总次数</p>
<p>TmpTable的状况主要是用于监控MySQL使用临时表的量是否过多，</p>
<p>是否有临时表过大而不得不从内存中换出到磁盘文件上。 </p>
<p>a.如果：</p>
<p>Created_tmp_disk_tables/Created_tmp_tables&gt;10%，则需调大tmp_table_size</p>
<p>比较理想的配置是：</p>
<p>Created_tmp_disk_tables/Created_tmp_tables&lt;=25%</p>
<p>b.如果：</p>
<p>Created_tmp_tables非常大 ，则可能是系统中排序操作过多，或者是表连接方式不是很优化。</p>
<p>相关参数：</p>
<p>tmp_table_size 内存中，临时表区域总大小</p>
<p>max_heap_table_size 内存中，单个临时表的最大值，超过的部分会放到硬盘上。</p>
<h1 id="连接数"><a href="#连接数" class="headerlink" title="连接数:"></a>连接数:</h1><p>max_connections MySQL最大连接数</p>
<p>back_log 当连接数满了后，设置一个值，允许多少个连接进入等待堆栈</p>
<p>max_connect_errors 账号连接到服务器允许的错误次数</p>
<p>connect_timeout 一个连接报文的最大时间(单位：s)</p>
<p>skip-name-resolve 加入my.cnf即可，MySQL在收到连接请求的时候，会根据请求包 </p>
<p>中获得的ip来反向追查请求者的主机名。然后再根据返回</p>
<p>的主机名又一次去获取ip。如果两次获得的ip相同，那么连接就成功建立了。</p>
<p>加了次参数，即可省去这个步骤</p>
<p>NOTES:</p>
<p>查询当前连接数:show global status like ‘connections’;</p>
<h1 id="table-cache相关优化-："><a href="#table-cache相关优化-：" class="headerlink" title="table cache相关优化 ："></a>table cache相关优化 ：</h1><p>参数table_open_cache，将表的文件描述符打开，cache在内存中</p>
<p>global status：</p>
<p>open_tables 当前系统中打开的文件描述符的数量</p>
<p>opened_tables 系统打开过的文件描述符的数量</p>
<h1 id="慢查询日志："><a href="#慢查询日志：" class="headerlink" title="慢查询日志："></a>慢查询日志：</h1><p>slow_launch_time=2 查询大于某个时间的值(单位：s)</p>
<p>slow_query_log=on/off 开启关闭慢查询日志</p>
<p>slow_query_log_file=/opt/data/xxx.log 慢查询日志位置</p>
<h1 id="查询缓存-Query-Cache"><a href="#查询缓存-Query-Cache" class="headerlink" title="查询缓存(Query Cache)"></a>查询缓存(Query Cache)</h1><p>将客户端的SQL语句(仅限select语句)通过hash计算，放在hash链表中，同时将该SQL的结果集</p>
<p>放在内存中cache。该hash链表中，存放了结果集的内存地址以及所涉及到的所有Table等信息。</p>
<p>如果与该结果集相关的任何一个表的相关信息发生变化后(包扩：数据、索引、表结构等)，</p>
<p>就会导致结果集失效，释放与该结果集相关的所有资源，以便后面其他SQL能够使用。</p>
<p>当客户端有select SQL进入，先计算hash值，如果有相同的，就会直接将结果集返回。</p>
<p>Query Cache的负面影响：</p>
<p>a.使用了Query Cache后，每条select SQL都要进行hash计算，然后查找结果集。对于大量SQL</p>
<p>访问，会消耗过多额外的CPU。</p>
<p>b.如果表变更比较频繁，则会造成结果集失效率非常高。</p>
<p>c.结果集中保存的是整个结果，可能存在一条记录被多次cache的情况，这样会造成内存资源的</p>
<p>过度消耗。</p>
<p>Query Cache的正确使用：</p>
<p>a.根据表的变更情况来选择是否使用Query Cache，可使用SQL Hint：SQL_NO_CACHE和SQL_CACHE</p>
<p>b.对于 变更比较少 或 数据基本处于静态 的表，使用SQL_CACHE</p>
<p>c.对于结果集比较大的，使用Query Cache可能造成内存不足，或挤占内存。</p>
<p>可使用1.SQL_NO_CACHE 2.query_cache_limit控制Query Cache的最大结果集(系统默认1M)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;%query_cache%&apos;;</span><br><span class="line"></span><br><span class="line">+------------------------------+---------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+------------------------------+---------+</span><br><span class="line"></span><br><span class="line">| have_query_cache | YES | #是否支持Query Cache</span><br><span class="line"></span><br><span class="line">| query_cache_limit | 1048576 | #单个结果集的最大值，默认1M</span><br><span class="line"></span><br><span class="line">| query_cache_min_res_unit | 4096 | #每个结果集存放的最小内存，默认4K</span><br><span class="line"></span><br><span class="line">| query_cache_size | 0 | #Query Cache总内存大小，必须是1024的整数倍</span><br><span class="line"></span><br><span class="line">| query_cache_type | ON | #ON,OFF,DEMAND(包含SQL_CACHE的查询中才开启)</span><br><span class="line"></span><br><span class="line">| query_cache_wlock_invalidate | OFF | </span><br><span class="line"></span><br><span class="line">+------------------------------+---------+</span><br><span class="line"></span><br><span class="line">#query_cache_wlock_invalidate：</span><br></pre></td></tr></table></figure>

<p>针对于MyISAM存储引擎，设置当有WRITELOCK在某个Table上面的时候，</p>
<p>读请求是要等待WRITE LOCK释放资源之后再查询还是允许直接从QueryCache中读取结果，</p>
<p>默认为FALSE（可以直接从QueryCache中取得结果）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &apos;qcache%&apos;;</span><br><span class="line"></span><br><span class="line">+-------------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-------------------------+-------+</span><br><span class="line"></span><br><span class="line">| Qcache_free_blocks | 0 | </span><br><span class="line"></span><br><span class="line">| Qcache_free_memory | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_hits | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_inserts | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_lowmem_prunes | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_not_cached | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_queries_in_cache | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_total_blocks | 0 |</span><br><span class="line"></span><br><span class="line">+-------------------------+-------+</span><br><span class="line"></span><br><span class="line"># Qcache_free_blocks</span><br></pre></td></tr></table></figure>

<p>QueryCache中目前还有多少剩余的blocks</p>
<p>a.如果Qcache_free_blocks值较大，说明Query Cache中内存碎片比较多</p>
<p>b.如果Qcache_free_blocks约等于Qcache_total_blocks/2，说明内存碎片非常严重</p>
<p>移除碎片：</p>
<p>flush query cache;</p>
<p>这个命令会把所有的存储块向上移动，并把自由块移到底部。</p>
<p>查询缓存碎片率：</p>
<p>查询缓存碎片率 = Qcache_free_blocks / Qcache_total_blocks * 100%</p>
<p>c.如果：</p>
<p>查询缓存碎片率超过20%， 可以用flush query cache整理碎片，或者减小</p>
<p>query_cache_min_res_unit(如果该系统的查询都是小数据量的话)</p>
<h2 id="Qcache-free-memory"><a href="#Qcache-free-memory" class="headerlink" title="Qcache_free_memory"></a>Qcache_free_memory</h2><p>QueryCache中目前剩余的内存大小</p>
<p>查询缓存利用率：</p>
<p>查询缓存利用率 = (query_cache_size – Qcache_free_memory) / query_cache_size * 100%</p>
<p>a.如果：</p>
<p>查询缓存利用率在25%以下，说明query_cache_size设置过大，可适当减小。</p>
<p>b.如果：</p>
<p>查询缓存利用率&gt;80%，且Qcache_lowmem_prunes&gt;50，说明query_cache_size可能有点小，或者</p>
<p>有太多的碎片</p>
<h2 id="Qcache-hits"><a href="#Qcache-hits" class="headerlink" title="Qcache_hits"></a>Qcache_hits</h2><p>Query Cache的命中次数，可以看到QueryCache的基本效果；</p>
<h2 id="Qcache-inserts"><a href="#Qcache-inserts" class="headerlink" title="Qcache_inserts"></a>Qcache_inserts</h2><p>Query Cache未命中然后插入的次数</p>
<p>Query Cache的命中率：</p>
<p>=Qcache_hits/(Qcache_hits+Qcache_inserts)</p>
<h2 id="Qcache-lowmem-prunes"><a href="#Qcache-lowmem-prunes" class="headerlink" title="Qcache_lowmem_prunes"></a>Qcache_lowmem_prunes</h2><p>因为内存不足而被清除出Query Cache的SQL数量。</p>
<p>如果：</p>
<p>Qcache_lowmem_prunes的值正在增加，并且有大量的Qcache_free_blocks，</p>
<p>这意味着碎片导致查询正在被从缓存中永久删除。</p>
<h2 id="Qcache-not-cached"><a href="#Qcache-not-cached" class="headerlink" title="Qcache_not_cached"></a>Qcache_not_cached</h2><p>因为query_cache_type的设置或者不能被cache的select SQL数量</p>
<h2 id="Qcache-queries-in-cache"><a href="#Qcache-queries-in-cache" class="headerlink" title="Qcache_queries_in_cache"></a>Qcache_queries_in_cache</h2><p>Query Cache中cache的select SQL数量</p>
<h2 id="Qcache-total-blocks"><a href="#Qcache-total-blocks" class="headerlink" title="Qcache_total_blocks"></a>Qcache_total_blocks</h2><p>当前Query Cache中block的总数量</p>
<p>Query Cache限制：</p>
<p>a) 5.1.17之前的版本不能Cache帮定变量的Query，但是从5.1.17版本开始，QueryCache已经开</p>
<p>始支持帮定变量的Query了； </p>
<p>b) 所有子查询中的外部查询SQL不能被Cache； </p>
<p>c) 在Procedure，Function以及Trigger中的Query不能被Cache； </p>
<p>d) 包含其他很多每次执行可能得到不一样结果的函数的Query不能被Cache。</p>
<h1 id="进程的使用情况"><a href="#进程的使用情况" class="headerlink" title="进程的使用情况"></a>进程的使用情况</h1><p>在MySQL中，为了尽可能提高客户端请求创建连接这个过程的性能，实现了一个ThreadCache池，</p>
<p>将空闲的连接线程存放在其中，而不是完成请求后就销毁。这样，当有新的连接请求的时候，</p>
<p>MySQL首先会检查ThreadCache池中是否存在空闲连接线程，如果存在则取出来直接使用，</p>
<p>如果没有空闲连接线程，才创建新的连接线程。</p>
<p>参数：thread_cache_size</p>
<p>thread cache 池中存放的最大连接数</p>
<p>调整参考：</p>
<p>在短连接的数据库应用中，数据库连接的创建和销毁是非常频繁的，</p>
<p>如果每次都需要让MySQL新建和销毁相应的连接线程，那么这个资源消耗实际上是非常大的，因此</p>
<p>thread_cache_size的值应该设置的相对大一些，不应该小于应用系统对数据库的实际并发请求数。</p>
<p>参数：thread_stack - 每个连接线程被创建的时候，MySQL给他分配的内存大小，</p>
<p>类似PGA中存放数据的内存部分(不包括排序的空间)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &apos;connections&apos;;</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Connections | 80 | #接受到的来自客户端的总连接数，包括以前和现在的连接。</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">show status like &apos;thread%&apos;;</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br><span class="line"></span><br><span class="line">| Threads_cached | 0 | #当前系统中，缓存的连接数</span><br><span class="line"></span><br><span class="line">| Threads_connected | 1 | #当前系统中正连接的线程数</span><br><span class="line"></span><br><span class="line">| Threads_created | 77 | #创建过的总线程数</span><br><span class="line"></span><br><span class="line">| Threads_running | 1 | </span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br></pre></td></tr></table></figure>
<p>a.如果：</p>
<p>Threads_created 值过大，说明MySQL一直在创建线程，这是比较消耗资源的，应该适当增大</p>
<p>thread_cache_size的值</p>
<p>b.如果：</p>
<p>Threads_cached的值比参数thread_cache_size小太多，则可以适当减小thread_cache_size的值</p>
<p>ThreadCache命中率：</p>
<p>Threads_Cache_Hit=(Connections-Threads_created)/Connections*100%</p>
<p>一般来说，当系统稳定运行一段时间之后，我们的ThreadCache命中率应该保持在90%</p>
<p>左右甚至更高的比率才算正常。</p>
<h1 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h1><p>索引缓存大小，是对MyISAM表性能影响最大的一个参数</p>
<p>32bit平台上，此值不要超过2GB，64bit平台不用做此限制，但也不要超过4GB</p>
<p>根据3点计算：</p>
<p>a.系统索引总大小 </p>
<p>b.系统物理内存 </p>
<p>c.系统当前keycache命中率</p>
<p>粗略计算公式：</p>
<p>Key_Size =key_number*(key_length+4)/0.67 </p>
<p>Max_key_buffer_size&lt;Max_RAM-QCache_Usage-Threads_Usage-System_Usage </p>
<p>Threads_Usage = max_connections * (sort_buffer_size + join_buffer_size + </p>
<p>read_buffer_size+read_rnd_buffer_size+thread_stack)</p>
<p>key_cache_block_size ，是key_buffer缓存块的单位长度，以字节为单位，默认值为1024。</p>
<p>key_cache_division_limit 控制着缓存块重用算法。默认值为100，此值为key_buffer_size中暖链所占的大小百分比(其中有暖链和热链)，100意味着全是暖链。(类似于Oracle Data Buffer Cache中的default、keep、recycle)</p>
<p>key_cache_age_threshold 如果key_buffer里的热链里的某个缓存块在这个变量所设定的时间里没有被访问过，MySQL服务器就会把它调整到暖链里去。这个参数值越大，缓存块在热链里停留的时间就越长。</p>
<p>这个参数默认值为 300，最小值为100。</p>
<p>Myisam索引默认是缓存在原始key_buffer中的，我们可以手动创建新的key_buffer，如在my.cnf中加入参数new_cache.key_buffer_size=20M。指定将table1和table2的索引缓存到new_cache的key_buffer中：</p>
<p>cache index table1,table2 in new_cache;</p>
<p>(之前默认的key_buffer为default，现在手动创建的为new_cache)</p>
<p>手动将table1和table2的索引载入到key_buffer中：</p>
<p>load index into cache table1,table2;</p>
<p>系统中记录的与Key Cache相关的性能状态参数变量： global status </p>
<p>l Key_blocks_not_flushed，已经更改但还未刷新到磁盘的DirtyCacheBlock； </p>
<p>l Key_blocks_unused，目前未被使用的CacheBlock数目； </p>
<p>l Key_blocks_used，已经使用了的CacheBlock数目； </p>
<p>l Key_read_requests，CacheBlock被请求读取的总次数； </p>
<p>l Key_reads，在CacheBlock中找不到需要读取的Key信息后到“.MYI”文件中(磁盘)读取的次数； </p>
<p>l Key_write_requests，CacheBlock被请求修改的总次数； </p>
<p>l Key_writes，在CacheBlock中找不到需要修改的Key信息后到“.MYI”文件中读入再修改的次数；</p>
<p>索引命中缓存率：</p>
<p>key_buffer_read_hits=(1-Key_reads/Key_read_requests)*100% </p>
<p>key_buffer_write_hits=(1-Key_writes/Key_write_requests)*100%</p>
<p>该命中率就代表了MyISAM类型表的索引的cache</p>
<h1 id="排序使用情况："><a href="#排序使用情况：" class="headerlink" title="排序使用情况："></a>排序使用情况：</h1><p>参数 ：sort_buffer_size - 单个thread能用来排序的内存空间大小，系统默认2M</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;sort%&apos;;</span><br><span class="line"></span><br><span class="line">+------------------+---------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+------------------+---------+</span><br><span class="line"></span><br><span class="line">| sort_buffer_size | 2097144 |</span><br><span class="line"></span><br><span class="line">+------------------+---------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show global status like &apos;sort%&apos;;</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br><span class="line"></span><br><span class="line">| Sort_merge_passes | 0 |#在内存中无法完成排序，而在磁盘上创建临时文件的次数(两倍)</span><br><span class="line"></span><br><span class="line">| Sort_range | 0 |#在范围内执行的排序的数量</span><br><span class="line"></span><br><span class="line">| Sort_rows | 0 |#已经排序的行数</span><br><span class="line"></span><br><span class="line">| Sort_scan | 0 |#通过扫描表完成的排序的数量</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br></pre></td></tr></table></figure>


<h1 id="表锁情况"><a href="#表锁情况" class="headerlink" title="表锁情况"></a>表锁情况</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;table%&apos;;</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">| Table_locks_immediate | 96 | # 表示立即释放的表锁数</span><br><span class="line"></span><br><span class="line">| Table_locks_waited | 0 | # 表示需要等待的表锁数</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br></pre></td></tr></table></figure>
<p>如果 Table_locks_immediate / Table_locks_waited &gt; 5000，最好采用InnoDB引擎。</p>
<p>因为InnoDB是行锁而MyISAM是表锁，对于高并发写入的应用InnoDB效果会好些。</p>
<h1 id="表扫描情况"><a href="#表扫描情况" class="headerlink" title="表扫描情况"></a>表扫描情况</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;handler_read%&apos;;</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">| Handler_read_first | 60 |</span><br><span class="line"></span><br><span class="line">| Handler_read_key | 2442 |</span><br><span class="line"></span><br><span class="line">| Handler_read_next | 286 |</span><br><span class="line"></span><br><span class="line">| Handler_read_prev | 0 |</span><br><span class="line"></span><br><span class="line">| Handler_read_rnd | 28 |</span><br><span class="line"></span><br><span class="line">| Handler_read_rnd_next | 3191 |</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show global status like &apos;com_select&apos;;</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Com_select | 23 |</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>
<p>计算表扫描率： </p>
<p>表扫描率 = Handler_read_rnd_next / Com_select </p>
<p>如果：</p>
<p>表扫描率超过4000，说明进行了太多表扫描，很有可能索引没有建好，</p>
<p>增加read_buffer_size值会有一些好处，但最好不要超过8MB。</p>
<h2 id="Handler-read-first"><a href="#Handler-read-first" class="headerlink" title="Handler_read_first"></a>Handler_read_first</h2><p>此选项表明SQL是在做一个全索引扫描(注意是全部，而不是部分)，所以说如果存在WHERE语句，</p>
<p>这个值是不会变的。如果这个值的数值很大，既是好事 也是坏事。</p>
<p>说它好是因为毕竟查询是在索引里完成的，而不是数据文件里，说它坏是因为大数据量时，</p>
<p>即便是索引文件，做一次完整的扫描也是很费时的。</p>
<h2 id="Handler-read-key"><a href="#Handler-read-key" class="headerlink" title="Handler_read_key"></a>Handler_read_key</h2><p>此选项数值如果很高，说明系统高效的使用了索引，一切运转良好</p>
<h1 id="Handler-read-next"><a href="#Handler-read-next" class="headerlink" title="Handler_read_next"></a>Handler_read_next</h1><p>此选项表明在进行索引扫描时，按照索引从数据文件里取数据的次数</p>
<h2 id="Handler-read-prev"><a href="#Handler-read-prev" class="headerlink" title="Handler_read_prev"></a>Handler_read_prev</h2><p>此选项表明在进行索引扫描时，按照索引倒序从数据文件里取数据的次数，</p>
<p>一般就是ORDER BY … DESC。</p>
<h2 id="Handler-read-rnd"><a href="#Handler-read-rnd" class="headerlink" title="Handler_read_rnd"></a>Handler_read_rnd</h2><p>简单的说，就是查询直接操作了数据文件，很多时候表现为没有使用索引或者文件排序</p>
<p>可能是有大量的全表扫描或连接时没恰当使用keys。</p>
<p>The number of requests to read a row based on a fixed position. This value is </p>
<p>high if you are doing a lot of queries that require sorting of the result. You </p>
<p>probably have a lot of queries that require MySQL to scan entire tables or you </p>
<p>have joins that do not use keys properly.</p>
<h2 id="Handler-read-rnd-next"><a href="#Handler-read-rnd-next" class="headerlink" title="Handler_read_rnd_next"></a>Handler_read_rnd_next</h2><p>此选项表明在进行数据文件扫描时，从数据文件里取数据的次数。(物理IO次数)</p>
<h1 id="MySQL内存分配"><a href="#MySQL内存分配" class="headerlink" title="MySQL内存分配"></a>MySQL内存分配</h1><p>mysql服务器为每个连接上的客户端线程，分配的内存空间：</p>
<p>read_buffer_size + read_rnd_buffer_size + sort_buffer_size + </p>
<p>thread_stack + join_buffer_size</p>
<p>从内存的使用方式MySQL 数据库的内存使用主要分为以下两类</p>
<p>· 线程独享内存</p>
<p>· 全局共享内存</p>
<p>先分析 MySQL 中主要的 “线程独享内存” 的。</p>
<p>在 MySQL 中，线程独享内存主要用于各客户端连接线程存储各种操作的独享数据，如线程栈信息，分组排序操作，数据读写缓冲，结果集暂存等等，而且大多数可以通过相关参数来控制内存的使用量。</p>
<p>线程栈信息使用内存(thread_stack)：</p>
<p>主要用来存放每一个线程自身的标识信息，如线程id，线程运行时基本信息等等，我们可以通过 thread_stack 参数来设置为每一个线程栈分配多大的内存。</p>
<p>排序使用内存(sort_buffer_size)：</p>
<p>MySQL 用此内存区域进行排序操作（filesort），完成客户端的排序请求。当我们设置的排序区缓存大小无法满足排序实际所需内存的时候，MySQL 会将数据写入磁盘文件来完成排序。由于磁盘和内存的读写性能完全不在一个数量级，所以sort_buffer_size参数对排序操作的性能影响绝对不可小视。排序操作的实现原理请参考：MySQL Order By 的实现分析(<a href="http://www.kuqin.com/database/20081206/29716.html)。" target="_blank" rel="noopener">http://www.kuqin.com/database/20081206/29716.html)。</a></p>
<p>Join操作使用内存(join_buffer_size)：</p>
<p>应用程序经常会出现一些两表（或多表）Join的操作需求，MySQL在完成某些 Join 需求的时候（all/index join），为了减少参与Join的“被驱动表”的读取次数以提高性能，需要使用到 Join Buffer 来协助完成 Join操作（具体 Join 实现算法请参考：</p>
<p>MySQL 中的 Join 基本实现原理(<a href="http://www.kuqin.com/database/20081206/29717.html)）。当" target="_blank" rel="noopener">http://www.kuqin.com/database/20081206/29717.html)）。当</a> Join Buffer 太小，MySQL 不会将该 Buffer 存入磁盘文件，而是先将Join Buffer中的结果集与需要 Join 的表进行 Join 操作，然后清空 Join Buffer 中的数据，继续将剩余的结果集写入此 Buffer 中，如此往复。这势必会造成被驱动表需要被多次读取，成倍增加 IO 访问，降低效率。</p>
<p>顺序读取数据缓冲区使用内存(read_buffer_size)：</p>
<p>这部分内存主要用于当需要顺序读取数据的时候，如无法使用索引的情况下的全表扫描，全索引扫描等。在这种时候，MySQL 按照数据的存储顺序依次读取数据块，每次读取的数据快首先会暂存在read_buffer_size中，当 buffer 空间被写满或者全部数据读取结束后，再将buffer中的数据返回给上层调用者，以提高效率。</p>
<p>随机读取数据缓冲区使用内存(read_rnd_buffer_size)：</p>
<p>和顺序读取相对应，当 MySQL 进行非顺序读取（随机读取）数据块的时候，会利用这个缓冲区暂存读取的数据。如根据索引信息读取表数据，根据排序后的结果集与表进行Join等等。总的来说，就是当数据块的读取需要满足一定的顺序的情况下，MySQL 就需要产生随机读取，进而使用到 read_rnd_buffer_size 参数所设置的内存缓冲区。</p>
<p>连接信息及返回客户端前结果集暂存使用内存(net_buffer_size)：</p>
<p>这部分用来存放客户端连接线程的连接信息和返回客户端的结果集。当 MySQL 开始产生可以返回的结果集，会在通过网络返回给客户端请求线程之前，会先暂存在通过 net_buffer_size 所设置的缓冲区中，等满足一定大小的时候才开始向客户端发送，以提高网络传输效率。不过，net_buffer_size 参数所设置的仅仅只是该缓存区的初始化大小，MySQL 会根据实际需要自行申请更多的内存以满足需求，但最大不会超过 max_allowed_packet 参数大小。</p>
<p>批量插入暂存使用内存(bulk_insert_buffer_size)：</p>
<p>当我们使用如 insert … values(…),(…),(…)… 的方式进行批量插入的时候，MySQL 会先将提交的数据放如一个缓存空间中，当该缓存空间被写满或者提交完所有数据之后，MySQL 才会一次性将该缓存空间中的数据写入数据库并清空缓存。此外，当我们进行 LOAD DATA INFILE 操作来将文本文件中的数据 Load 进数据库的时候，同样会使用到此缓冲区。</p>
<p>MySQL对硬件的”收益递减点“为256G内存，32CPU。</p>
<h1 id="dalayed-queue-size"><a href="#dalayed-queue-size" class="headerlink" title="dalayed_queue_size"></a>dalayed_queue_size</h1><p>在被插入到实际的数据表里之前，来自insert delayed语句的数据航将在每个队列里等待</p>
<p>MySQL来处理他们。delayed_queue_size就是这个队列所能容纳的数据航的最大个数。当</p>
<p>这个队列满是，后续的insert delayed语句将被阻塞，直到这个队列里有容纳他们的空间</p>
<p>为止。</p>
<p>如果有很多客户在发出insert delayed语句以避免受阻塞，但你发现这些语句有阻塞的迹象，</p>
<p>加大这个变量的值将使更多的insert delayed语句更快地得到处理。</p>
<h1 id="文件打开数-open-files-limit"><a href="#文件打开数-open-files-limit" class="headerlink" title="文件打开数 open_files_limit"></a>文件打开数 open_files_limit</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;open%&apos;;</span><br><span class="line"></span><br><span class="line">+------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+------------------+-------+</span><br><span class="line"></span><br><span class="line">| open_files_limit | 1024 | #mysql总共能够打开的文件的数量</span><br><span class="line"></span><br><span class="line">+------------------+-------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show global status like &apos;open%file%&apos;;</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Open_files | 79 | # 系统当前打开的文件数</span><br><span class="line"></span><br><span class="line">| Opened_files | 278 | # 系统打开过的文件总数</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>
<p>比较合适的设置：Open_files / open_files_limit * 100% &lt;= 75%</p>
]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>为何选择logback+slf4j</title>
    <url>/archives/e2c1fb46.html</url>
    <content><![CDATA[<p>无论从设计上还是实现上，Logback相对log4j而言有了相对多的改进。不过尽管难以一一细数，这里还是列举部分理由为什么选择logback而不是log4j。牢记logback与log4j在概念上面是很相似的，它们都是有同一群开发者建立。所以如果你已经对log4j很熟悉，你也可以很快上手logback。如果你喜欢使用log4j,你也许会迷上使用logback。</p><a id="more"></a>
<ol>
<li>更快的执行速度</li>
</ol>
<p>基于我们先前在log4j上的工作，logback 重写了内部的实现，在某些特定的场景上面，甚至可以比之前的速度快上10倍。在保证logback的组件更加快速的同时，同时所需的内存更加少。</p>
<p>2.更充足的测试</p>
<p>Logback 历经了几年，数不清小时数的测试。尽管log4j也是测试过的，但是Logback的测试更加充分，跟log4j不在同一个级别。我们认为，这正是人们选择Logback而不是log4j的最重要的原因。人们都希望即使在恶劣的条件下，你的日记框架依然稳定而可靠。</p>
<ol start="3">
<li>logback-classic 非常自然的实现了SLF4J</li>
</ol>
<p>logback-classic中的登陆类自然的实现了SLF4J。当你使用 logback-classic作为底层实现时，涉及到LF4J日记系统的问题你完全不需要考虑。更进一步来说，由于 logback-classic强烈建议使用SLF4J作为客户端日记系统实现，如果需要切换到log4j或者其他，你只需要替换一个jar包即可，不需要去改变那些通过SLF4J API 实现的代码。这可以大大减少更换日记系统的工作量。</p>
<ol start="4">
<li>扩展文档</li>
</ol>
<p>Logback附带详细的和不断更新的文档。</p>
<p>5.使用XML配置文件或者Groovy</p>
<p>配置logback的传统方法是通过XML文件。在文档中，大部分例子都是是用XML语法。但是，对于logback版本0.9.22，通过Groovy编写的配置文件也得到支持。相比于XML，Groovy风格的配置文件更加直观，连贯和简短的语法。<br>现在， 已经有一个工具自动把logback.xml文件迁移至logback.groovy。</p>
<p>6.自动重新载入配置文件</p>
<p>Logback-classic可以在配置文件被修改后，自动重新载入。这个扫描过程很快，无资源争用，并且可以动态扩展支持在上百个线程之间每秒上百万个调用。它和应用服务器结合良好，并且在JEE环境通用，因为它不会调用创建一个单独的线程来做扫描。</p>
<p>7.优雅地从I/O错误中恢复</p>
<p>FileAppender和它的子类，包括RollingFileAppender，可以优雅的从I/O错误中恢复。所以，如果一个文件服务器临时宕机，你再也不需要重启你的应用，而日志功能就能正常工作。当文件服务器恢复工作，logback相关的appender就会透明地和快速的从上一个错误中恢复。</p>
<p>8.自动清除旧的日志归档文件</p>
<p>通过设置TimeBasedRollingPolicy 或者 SizeAndTimeBasedFNATP的 maxHistory 属性，你就可以控制日志归档文件的最大数量。如果你的回滚策略是每月回滚的，并且你希望保存一年的日志，那么只需简单的设置maxHistory属性为12。对于12个月之前的归档日志文件将被自动清除。</p>
<ol start="9">
<li>自动压缩归档日志文件</li>
</ol>
<p>RollingFileAppender可以在回滚操作中，自动压缩归档日志文件。压缩通常是异步执行的，所以即使是很大的日志文件，你的应用都不会因此而被阻塞。</p>
<ol start="10">
<li>谨慎模式</li>
</ol>
<p>在谨慎模式中，在多个JVM中运行的多个FileAppender实例，可以安全的写入统一个日志文件。谨慎模式可以在一定的限制条件下应用于RollingFileAppender。</p>
<p>11.Lilith</p>
<p>Lilith是logback的一个记录和访问事件查看器。它相当于log4j的 chainsaw，但是Lilith设计的目的是处理大量的日志记录。</p>
<ol start="12">
<li>配置文件中的条件处理</li>
</ol>
<p>开发者通常需要在不同的目标环境中变换logback的配置文件，例如开发环境，测试环境和生产环境。这些配置文件大体是一样的，除了某部分会有不同。为了避免重复，logback支持配置文件中的条件处理，只需使用<if>,<then>和<else>，那么同一个配置文件就可以在不同的环境中使用了。</else></then></if></p>
<p>13.过滤</p>
<p>Logback拥有远比log4j更丰富的过滤能力。例如，让我们假设，有一个相当重要的商业应用部署在生产环境。考虑到大量的交易数据需要处理，记录级别被设置为WARN，那么只有警告和错误信息才会被记录。现在，想象一下，你在开发环境遇到了一个臭虫，但是在测试平台中却很难发现，因为一些环境之间(生产环境/测试环境)的未知差异。</p>
<p>使用log4j，你只能选择在生产系统中降低记录的级别到DEBUG，来尝试发现问题。但是很不幸，这会生成大量的日志记录，让分析变得困难。更重要的是，多余的日志记录会影响到生产环境的性能。<br>使用logback，你可以选择保留只所有用户的WARN级别的日志，而除了某个用户，例如Alice，而她就是问题的相关用户。当Alice登录系统，她就会以DEBUG级别被记录，而其他用户仍然是以WARN级别来记录日志。这个功能，可以通过在配置文件的XML中添加4行。请在相关章节中查找MDCFilter</p>
<ol start="14">
<li>SiftingAppender</li>
</ol>
<p>SiftingAppender是一个全能的追加器。它可以基于任何给定的实时属性分开（或者筛选）日志。例如，SiftingAppender可以基于用户会话分开日志事件，这样，可以为每一个用户建立一个独立的日志文件。</p>
<p>15.Logback-access模块，提供了通过HTTP访问日志的能力，是logback不可或缺的组成部分</p>
<p>最后但绝非最不重要的是，作为logback发布包的一部分，logback-access模块可与Jetty或者Tomcat进行集成，提供了非常丰富而强大的通过HTTP访问日志的功能。因为logback-access模块是logback初期设计方案中的一部分，因此，所有你所喜欢的logback-classic模块所提供的全部特性logback-access同样也具备。</p>
<p>以上网络整理的内容————————————————————–<br>下面是我编写的一个demo配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration scan=&quot;false&quot; debug=&quot;false&quot;&gt;  </span><br><span class="line">  	&lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;mm:ss&#125; %-5level %logger&#123;36&#125; &gt;&gt;&gt; %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;appender name=&quot;DEBUG_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    	&lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;  </span><br><span class="line">            &lt;level&gt;DEBUG&lt;/level&gt;</span><br><span class="line">            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;  </span><br><span class="line">    		&lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">        &lt;/filter&gt; </span><br><span class="line">	    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">	      &lt;!-- daily rollover --&gt;</span><br><span class="line">	      &lt;fileNamePattern&gt;logs/debug.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">	</span><br><span class="line">	      &lt;!-- keep 30 days&apos; worth of history capped at 3GB total size --&gt;</span><br><span class="line">	      &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">	      &lt;totalSizeCap&gt;3GB&lt;/totalSizeCap&gt;</span><br><span class="line">	    &lt;/rollingPolicy&gt;</span><br><span class="line">	    &lt;encoder&gt;</span><br><span class="line">	      &lt;pattern&gt;%d [%thread] [%-5level] %file,%line - %msg%n&lt;/pattern&gt;</span><br><span class="line">	    &lt;/encoder&gt; </span><br><span class="line">    &lt;/appender&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;appender name=&quot;WARN_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    	&lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;  </span><br><span class="line">            &lt;level&gt;WARN&lt;/level&gt;</span><br><span class="line">        &lt;/filter&gt; </span><br><span class="line">	    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">	      &lt;!-- daily rollover --&gt;</span><br><span class="line">	      &lt;fileNamePattern&gt;logs/warn.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">	</span><br><span class="line">	      &lt;!-- keep 30 days&apos; worth of history capped at 3GB total size --&gt;</span><br><span class="line">	      &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">	      &lt;totalSizeCap&gt;3GB&lt;/totalSizeCap&gt;</span><br><span class="line">	    &lt;/rollingPolicy&gt;</span><br><span class="line">	    &lt;encoder&gt;</span><br><span class="line">	      &lt;pattern&gt;%d [%thread] [%-5level] %file,%line - %msg%n&lt;/pattern&gt;</span><br><span class="line">	    &lt;/encoder&gt; </span><br><span class="line">    &lt;/appender&gt; </span><br><span class="line">  </span><br><span class="line">    &lt;root level=&quot;DEBUG&quot;&gt;  </span><br><span class="line">        &lt;appender-ref ref=&quot;DEBUG_FILE&quot; /&gt;  </span><br><span class="line">        &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt;  </span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">    &lt;/root&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestA &#123;</span><br><span class="line">	static Logger log = LoggerFactory.getLogger(TestB.class);</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		log.trace(&quot;======trace&quot;);  </span><br><span class="line">		log.debug(&quot;======debug&quot;);  </span><br><span class="line">		log.info(&quot;======info&quot;);  </span><br><span class="line">		log.warn(&quot;======warn&quot;);  </span><br><span class="line">		log.error(&quot;======error&quot;); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<p><img src="/images/loading.png" data-original="/images/pasted-1.png" alt="upload successful"></p>
<p>日志记录情况:</p>
<p><img src="/images/loading.png" data-original="/images/pasted-2.png" alt="upload successful"></p>
<p>demo每天一个新日志文件,历史数据保留最大30天.日志总占数据量大于3G自动异步删除旧日志</p>
<p>根节点<code>&lt;configuration&gt;</code>包含的属性：</p>
<p>scan:</p>
<p>当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</p>
<p>scanPeriod:</p>
<p>设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</p>
<p>debug:</p>
<p>当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</p>
<p><code>&lt;level&gt;</code>:设置过滤级别</p>
<p><code>&lt;onMatch&gt;</code>:用于配置符合过滤条件的操作</p>
<p><code>&lt;onMismatch&gt;</code>:用于配置不符合过滤条件的操作</p>
<p>Logback的过滤器基于三值逻辑（ternary logic），允许把它们组装或成链，从而组成任意的复合过滤策略。过滤器很大程度上受到Linux的iptables启发。这里的所谓三值逻辑是说，过滤器的返回值只能是ACCEPT、DENY和NEUTRAL的其中一个。</p>
<p>如果返回DENY，那么记录事件立即被抛弃，不再经过剩余过滤器；</p>
<p>如果返回NEUTRAL，那么有序列表里的下一个过滤器会接着处理记录事件；</p>
<p>如果返回ACCEPT，那么记录事件被立即处理，不再经过剩余过滤器。</p>
<p><code>&lt;maxHistory&gt;</code>:<br>可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每个月滚动，且<maxhistory>是6，则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除。</maxhistory></p>
<p>独立的日志标签</p>
<p><code>&lt;logger name=&quot;monitor&quot; additivity=&quot;false&quot; level=&quot;INFO&quot;&gt;</code></p>
<p>这里通过设置additivity=”false”禁止monitor里的内容向上传递，否则会同时显示在默认的日志中。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>slf4j</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>快速生成Maven archetype模板</title>
    <url>/archives/e0f55110.html</url>
    <content><![CDATA[<h2 id="快捷生成archetype方便修改"><a href="#快捷生成archetype方便修改" class="headerlink" title="快捷生成archetype方便修改"></a>快捷生成archetype方便修改</h2><p>mvn archetype:create-from-project -Darchetype.filteredExtensions=java -DpackageName=com.pearlgo -DartifactId=ec-template</p><a id="more"></a>
<h3 id="上传archetype到私服"><a href="#上传archetype到私服" class="headerlink" title="上传archetype到私服"></a>上传archetype到私服</h3><p>添加配置pom配置,是配置到archetype的pom</p>
<!-- 配置部署的远程仓库 -->
<p> <code>&lt;distributionManagement&gt;
  &lt;snapshotRepository&gt;
   &lt;id&gt;nexus-snapshots&lt;/id&gt;
   &lt;name&gt;nexus distribution snapshot repository&lt;/name&gt;
   &lt;url&gt;xxxx私服snapshots地址&lt;/url&gt;
  &lt;/snapshotRepository&gt;
  &lt;repository&gt;
   &lt;id&gt;nexus-releases&lt;/id&gt;
   &lt;name&gt;Nexus Release Repository&lt;/name&gt;
   &lt;url&gt;xxxx私服release地址&lt;/url&gt;
  &lt;/repository&gt;
 &lt;/distributionManagement&gt;</code></p>
<h2 id="执行上传-用IDEA可以直接用快捷方法无需用命令"><a href="#执行上传-用IDEA可以直接用快捷方法无需用命令" class="headerlink" title="执行上传,用IDEA可以直接用快捷方法无需用命令"></a>执行上传,用IDEA可以直接用快捷方法无需用命令</h2><p>mvn clean deploy</p>
]]></content>
      <categories>
        <category>archetype</category>
        <category>maven</category>
      </categories>
      <tags>
        <tag>archetype</tag>
        <tag>maven</tag>
        <tag>快捷</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作</title>
    <url>/archives/7a00f2af.html</url>
    <content><![CDATA[<h3 id="找到根目录下所有的以test开头的文件并把查找结果当做参数传给rm-rf命令进行删除："><a href="#找到根目录下所有的以test开头的文件并把查找结果当做参数传给rm-rf命令进行删除：" class="headerlink" title="找到根目录下所有的以test开头的文件并把查找结果当做参数传给rm -rf命令进行删除："></a>找到根目录下所有的以test开头的文件并把查找结果当做参数传给rm -rf命令进行删除：</h3><p>1、find / -name “test<em>” |xargs rm -rf<br>2、find / -name “test</em>” -exec rm -rf {} ;<br>3、rm -rf $(find / -name “test”)</p><a id="more"></a>
<h3 id="如果想指定递归深度，可以这样："><a href="#如果想指定递归深度，可以这样：" class="headerlink" title="如果想指定递归深度，可以这样："></a>如果想指定递归深度，可以这样：</h3><p>1、find / -maxdepth 3 -name “<em>.mp3” |xargs rm -rf<br>2、find / -maxdepth 3 -name “test</em>” -exec rm -rf {} ;<br>3、rm -rf $(find / -maxdepth 3 -name “test”)<br>这样只会查找三层目录中符合条件的文件并删除掉！ </p>
<h3 id="使用特定用户重启"><a href="#使用特定用户重启" class="headerlink" title="使用特定用户重启"></a>使用特定用户重启</h3><p>sudo -u apprunner bash ./start.sh restart</p>
<p>sudo -u apprunner /usr/local/java/jdk1.8.0_152/bin</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>ps aux –sort -rss|grep java</p>
<h4 id="线程数等数据"><a href="#线程数等数据" class="headerlink" title="线程数等数据"></a>线程数等数据</h4><p>cat /proc/PID/status</p>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>tar -czvf 文件名 要打包内容</p>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>tar -xzvf file.tar.gz</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>zcat vsftpd.tar.gz|grep –binary-files=text ‘footbar.js’或<br>zgrep –binary-files=text ‘footbar.js’ vsftpd.tar.gz</p>
<p>sudo rz -y 覆盖文件<br>sudo unzip -o<br>sudo cp -rf<br>chmod +x *.sh</p>
<p>df -lh 磁盘大小</p>
<p>du -h –max-depth=1 文件夹大小</p>
<p>sudo scp -P 58880  ./dwc-pj.tar.gz <a href="mailto:dwc-lyp@112.74.140.11" target="_blank" rel="noopener">dwc-lyp@112.74.140.11</a>:/data/project/dwc</p>
<p>jmap -histo:live 15441|less</p>
<p>netstat -nap|grep 120.24.166.239:6379</p>
<p>nohup java …. &gt; xx.txt &amp;</p>
<p>jps</p>
<p>功能</p>
<p>显示当前所有java进程pid的命令。</p>
<p>常用指令</p>
<p>jps：显示当前用户的所有java进程的PID<br>jps -v 3331：显示虚拟机参数<br>jps -m 3331：显示传递给main()函数的参数<br>jps -l 3331：显示主类的全路径<br>详细介绍</p>
<p>jinfo</p>
<p>功能</p>
<p>实时查看和调整虚拟机参数，可以显示未被显示指定的参数的默认值（jps -v 则不能）。</p>
<p>jdk8中已经不支持该命令。</p>
<p>常用指令</p>
<p>jinfo -flag CMSIniniatingOccupancyFration 1444：查询CMSIniniatingOccupancyFration参数值</p>
<p>详细介绍</p>
<p>jstat</p>
<p>功能</p>
<p>显示进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<p>常用指令</p>
<p>jstat -gc 3331 250 20 ：查询进程2764的垃圾收集情况，每250毫秒查询一次，一共查询20次。<br>jstat -gccause：额外输出上次GC原因<br>jstat -calss：件事类装载、类卸载、总空间以及所消耗的时间<br>详细介绍</p>
<p>jmap</p>
<p>功能</p>
<p>生成堆转储快照（heapdump）</p>
<p>常用指令</p>
<p>jmap -heap 3331：查看java 堆（heap）使用情况<br>jmap -histo 3331：查看堆内存(histogram)中的对象数量及大小<br>jmap -histo:live 3331：JVM会先触发gc，然后再统计信息<br>jmap -dump:format=b,file=heapDump 3331：将内存使用的详细情况输出到文件，之后一般使用其他工具进行分析。<br>详细介绍</p>
<p>jhat</p>
<p>功能</p>
<p>一般与jmap搭配使用，用来分析jmap生成的堆转储文件。</p>
<p>由于有很多可视化工具（Eclipse Memory Analyzer 、IBM HeapAnalyzer）可以替代，所以很少用。不过在没有可视化工具的机器上也是可用的。</p>
<p>常用指令</p>
<p>jmap -dump:format=b,file=heapDump 3331 + jhat heapDump：解析Java堆转储文件,并启动一个 web server</p>
<p>详细介绍</p>
<p>jstack</p>
<p>功能</p>
<p>生成当前时刻的线程快照。</p>
<p>常用指令</p>
<p>jstack 3331：查看线程情况<br>jstack -F 3331：正常输出不被响应时，使用该指令<br>jstack -l 3331：除堆栈外，显示关于锁的附件信息<br>详细介绍</p>
<p>常见问题定位过程</p>
<p>频繁GC问题或内存溢出问题</p>
<p>一、使用jps查看线程ID</p>
<p>二、使用jstat -gc 3331 250 20 查看gc情况，一般比较关注PERM区的情况，查看GC的增长情况。</p>
<p>三、使用jstat -gccause：额外输出上次GC原因</p>
<p>四、使用jmap -dump:format=b,file=heapDump 3331生成堆转储文件</p>
<p>五、使用jhat或者可视化工具（Eclipse Memory Analyzer 、IBM HeapAnalyzer）分析堆情况。</p>
<p>六、结合代码解决内存溢出或泄露问题。</p>
<p>死锁问题</p>
<p>一、使用jps查看线程ID</p>
<p>二、使用jstack 3331：查看线程情况</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA常用快捷键</title>
    <url>/archives/566321e7.html</url>
    <content><![CDATA[<h2 id="记录原因"><a href="#记录原因" class="headerlink" title="记录原因"></a>记录原因</h2><p>因为经常忘记快捷键,所以写一遍记录常用快捷键的博客,方便忘记的时候可以快速查找,不用到处翻。</p>
<a id="more"></a>
<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><p>Ctrl+Shift + Enter，语句完成<br>“！”，否定完成，输入表达式时按 “！”键<br>Ctrl+E，最近的文件<br>Ctrl+Shift+E，最近更改的文件<br>Shift+Click，可以关闭文件<br>Ctrl+[ OR ]，可以跑到大括号的开头与结尾<br>Ctrl+F12，可以显示当前文件的结构<br>Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择<br>Ctrl+N，可以快速打开类<br>Ctrl+Shift+N，可以快速打开文件<br>Alt+Q，可以看到当前方法的声明<br>Ctrl+P，可以显示参数信息<br>Ctrl+Shift+Insert，可以选择剪贴板内容并插入<br>Alt+Insert，可以生成构造器/Getter/Setter等<br>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义<br>Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch<br>Ctrl+Enter，导入包，自动修正<br>Ctrl+Alt+L，格式化代码<br>Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作<br>Ctrl+Alt+O，优化导入的类和包<br>Ctrl+R，替换文本<br>Ctrl+F，查找文本<br>Ctrl+Shift+Space，自动补全代码<br>Ctrl+空格，代码提示（与系统输入法快捷键冲突）<br>Ctrl+Shift+Alt+N，查找类中的方法或变量<br>Alt+Shift+C，最近的更改<br>Alt+Shift+Up/Down，上/下移一行<br>Shift+F6，重构 – 重命名<br>Ctrl+X，删除行<br>Ctrl+D，复制行<br>Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）<br>Ctrl+J，自动代码（例如：serr）<br>Ctrl+Alt+J，用动态模板环绕<br>Ctrl+H，显示类结构图（类的继承层次）<br>Ctrl+Q，显示注释文档<br>Alt+F1，查找代码所在位置<br>Alt+1，快速打开或隐藏工程面板<br>Ctrl+Alt+left/right，返回至上次浏览的位置<br>Alt+left/right，切换代码视图<br>Alt+Up/Down，在方法间快速移动定位<br>Ctrl+Shift+Up/Down，向上/下移动语句<br>F2 或 Shift+F2，高亮错误或警告快速定位<br>Tab，代码标签输入完成后，按 Tab，生成代码<br>Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失<br>Alt+F3，逐个往下查找相同文本，并高亮显示<br>Ctrl+Up/Down，光标中转到第一行或最后一行下<br>Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）<br>Ctrl+Alt+B，跳转到方法实现处<br>Ctrl+Shift+Backspace，跳转到上次编辑的地方<br>Ctrl+O，重写方法<br>Ctrl+Alt+Space，类名自动完成<br>Ctrl+Alt+Up/Down，快速跳转搜索结果<br>Ctrl+Shift+J，整合两行<br>Alt+F8，计算变量值<br>Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本<br>Ctrl+Alt+Shift+V，简单粘贴<br>Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口<br>F12，把焦点从编辑器移到最近使用的工具窗口<br>Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器<br>Ctrl+W，可以选择单词继而语句继而行继而函数<br>Ctrl+Shift+W，取消选择光标所在词<br>Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置<br>Ctrl+I，实现方法<br>Ctrl+Shift+U，大小写转化<br>Ctrl+Y，删除当前行<br>Shift+Enter，向下插入新行<br>psvm/sout，main/System.out.println(); Ctrl+J，查看更多<br>Ctrl+Shift+F，全局查找<br>Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找<br>Ctrl+Shift+S，高级搜索<br>Ctrl+U，转到父类<br>Ctrl+Alt+S，打开设置对话框<br>Alt+Shift+Inert，开启/关闭列选择模式<br>Ctrl+Alt+Shift+S，打开当前项目/模块属性<br>Ctrl+G，定位行<br>Alt+Home，跳转到导航栏<br>Ctrl+Enter，上插一行<br>Ctrl+Backspace，按单词删除<br>Ctrl+”+/-”，当前方法展开、折叠<br>Ctrl+Shift+”+/-”，全部展开、折叠</p>
<h2 id="【调试部分、编译】"><a href="#【调试部分、编译】" class="headerlink" title="【调试部分、编译】"></a>【调试部分、编译】</h2><p>Ctrl+F2，停止<br>Alt+Shift+F9，选择 Debug<br>Alt+Shift+F10，选择 Run<br>Ctrl+Shift+F9，编译<br>Ctrl+Shift+F10，运行<br>Ctrl+Shift+F8，查看断点<br>F8，步过<br>F7，步入<br>Shift+F7，智能步入<br>Shift+F8，步出<br>Alt+Shift+F8，强制步过<br>Alt+Shift+F7，强制步入<br>Alt+F9，运行至光标处<br>Ctrl+Alt+F9，强制运行至光标处<br>F9，恢复程序<br>Alt+F10，定位到断点<br>Ctrl+F8，切换行断点<br>Ctrl+F9，生成项目<br>Alt+1，项目<br>Alt+2，收藏<br>Alt+6，TODO<br>Alt+7，结构<br>Ctrl+Shift+C，复制路径<br>Ctrl+Alt+Shift+C，复制引用，必须选择类名<br>Ctrl+Alt+Y，同步<br>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）<br>Shift+F12，还原默认布局<br>Ctrl+Shift+F12，隐藏/恢复所有窗口<br>Ctrl+F4，关闭<br>Ctrl+Shift+F4，关闭活动选项卡<br>Ctrl+Tab，转到下一个拆分器<br>Ctrl+Shift+Tab，转到上一个拆分器</p>
<h2 id="【重构】"><a href="#【重构】" class="headerlink" title="【重构】"></a>【重构】</h2><p>Ctrl+Alt+Shift+T，弹出重构菜单<br>Shift+F6，重命名<br>F6，移动<br>F5，复制<br>Alt+Delete，安全删除<br>Ctrl+Alt+N，内联</p>
<h2 id="【查找】"><a href="#【查找】" class="headerlink" title="【查找】"></a>【查找】</h2><p>Ctrl+F，查找<br>Ctrl+R，替换<br>F3，查找下一个<br>Shift+F3，查找上一个<br>Ctrl+Shift+F，在路径中查找<br>Ctrl+Shift+R，在路径中替换<br>Ctrl+Shift+S，搜索结构<br>Ctrl+Shift+M，替换结构<br>Alt+F7，查找用法<br>Ctrl+Alt+F7，显示用法<br>Ctrl+F7，在文件中查找用法<br>Ctrl+Shift+F7，在文件中高亮显示用法</p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/archives/8979b4c0.html</url>
    <content><![CDATA[<h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p><p>示例：</p><p><code># 这是一级标题</code><br><br><code>## 这是二级标题</code><br><br><code>### 这是三级标题</code><br><br><code>#### 这是四级标题</code><br><br><code>##### 这是五级标题</code><br><br><code>###### 这是六级标题</code><br><br>效果如下：</p><a id="more"></a>



<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h2 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h2><p>加粗<br>要加粗的文字左右分别用两个*号包起来</p>
<p>斜体<br>要倾斜的文字左右分别用一个*号包起来</p>
<p>斜体加粗<br>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<p>删除线<br>要加删除线的文字左右分别用两个~~号包起来</p>
<p>示例：</p>
<p><code>**这是加粗的文字**</code><br><br><code>*这是倾斜的文字*``&lt;br&gt;</code><strong><em>这是斜体加粗的文字</em></strong><code>&lt;br&gt;</code><del>这是加删除线的文字</del>`<br><br>效果如下：</p>
<p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p>
<h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…<br>貌似可以一直加下去，但没神马卵用</p>
<p>示例：</p>
<p><code>&gt;这是引用的内容</code><br><br><code>&gt;&gt;这是引用的内容</code><br><br><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</code><br><br>效果如下：</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><p>三个或者三个以上的 - 或者 * 都可以。</p>
<p>示例：</p>
<p><code>---</code><br><br><code>----</code><br><br><code>***</code><br><br><code>*****</code><br><br>效果如下：<br>可以看到，显示效果是一样的。</p>
<hr>
<hr>
<hr>
<hr>
<h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><p>语法：</p>
<p><code>![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</code></p>
<p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加<br>示例：</p>
<p>![blockchain](<a href="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/" target="_blank" rel="noopener">https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</a><br>u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”)<br>效果如下：</p>
<p>blockchain<br>上传本地图片直接点击导航栏的图片标志，选择图片即可</p>
<h2 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h2><p>语法：</p>
<p><a href="超链接地址" title="超链接title">超链接名</a><br>title可加可不加<br>示例：</p>
<p><code>[简书](http://jianshu.com)</code><br><br><code>[百度](http://baidu.com)</code><br><br>效果如下：</p>
<p><a href="http://jianshu.com" target="_blank" rel="noopener">简书</a><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p>
<p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p>
<p><code>&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;</code></p>
<p>示例<br><a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank">简书</a></p>
<h2 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h2><p>无序列表</p>
<h4 id="语法：无序列表用-任何一种都可以"><a href="#语法：无序列表用-任何一种都可以" class="headerlink" title="语法：无序列表用 - + * 任何一种都可以"></a>语法：无序列表用 - + * 任何一种都可以</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br></pre></td></tr></table></figure>
<p>注意：- + * 跟内容之间都要有一个空格</p>
<p>效果如下：</p>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<p>语法：数字加点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br></pre></td></tr></table></figure>
<p>注意：序号跟内容之间要有空格<br>效果如下：</p>
<p>1.列表内容<br>2.列表内容<br>3.列表内容</p>
<p>列表嵌套<br>上一级和下一级之间敲三个空格即可</p>
<p>一级无序列表内容<br>   二级无序列表内容<br>   二级无序列表内容<br>   二级无序列表内容<br>一级无序列表内容<br>   二级有序列表内容<br>   二级有序列表内容<br>   二级有序列表内容<br>一级有序列表内容<br>   二级无序列表内容<br>   二级无序列表内容<br>   二级无序列表内容<br>一级有序列表内容<br>   二级有序列表内容<br>   二级有序列表内容<br>   二级有序列表内容</p>
<h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br></pre></td></tr></table></figure>
<p>第二行分割表头和内容。</p>
<ul>
<li>有一个就行，为了对齐，多加了几个<br>文字默认居左</li>
<li>两边加：表示文字居中</li>
<li>右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略<br>示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure>
效果如下：</li>
</ul>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
<tr>
<td>## 九、代码</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td>语法：</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td>单行代码：代码之间分别用一个反引号包起来</td>
<td align="center"></td>
<td align="right"></td>
</tr>
</tbody></table>
<pre><code>`代码内容`</code></pre><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(```)---去掉括号</span><br><span class="line"> 代码...</span><br><span class="line"> 代码...</span><br><span class="line"> 代码...</span><br><span class="line">(```)---去掉括号</span><br></pre></td></tr></table></figure>
<p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p>
<p>示例：</p>
<p>单行代码</p>
<p><code>create database hero;</code><br>代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">     echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p>单行代码</p>
<p><code>create database hero;</code></p>
<p>代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">  echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>
<h2 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
</search>
