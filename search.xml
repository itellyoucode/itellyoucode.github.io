<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面试经</title>
    <url>/archives/4048efa0.html</url>
    <content><![CDATA[<h2 id="java基础："><a href="#java基础：" class="headerlink" title="java基础："></a>java基础：</h2><h3 id="1-HashMap的数据结构是什么？"><a href="#1-HashMap的数据结构是什么？" class="headerlink" title="1.HashMap的数据结构是什么？"></a>1.HashMap的数据结构是什么？</h3><p>JDK版本 实现方式 节点数&gt;=8 节点数&lt;=6<br>1.8以前 数组+单向链表 数组+单向链表 数组+单向链表<br>1.8以后 数组+单向链表+红黑树 数组+红黑树 数组+单向链表<br>寻址算法优化<br>(n - 1) &amp; hash -&gt; 数组里的一个位置</p><a id="more"></a>
<h3 id="2、HashSet-是如何保证不重复的"><a href="#2、HashSet-是如何保证不重复的" class="headerlink" title="2、HashSet 是如何保证不重复的"></a>2、HashSet 是如何保证不重复的</h3><p>底层维护了一个HashMap</p>
<h3 id="3、HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）"><a href="#3、HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）" class="headerlink" title="3、HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?"></a>3、HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?</h3><p>线程不安全</p>
<h3 id="4、HashMap-的扩容过程"><a href="#4、HashMap-的扩容过程" class="headerlink" title="4、HashMap 的扩容过程"></a>4、HashMap 的扩容过程</h3><p>初始长度是16，并且每次扩展时候，长度必须是2的幂。因为2的幂-1对应的二进制末尾总是是1111，这样，和key.hash做“与”运算的时候，只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。</p>
<h3 id="5、HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？"><a href="#5、HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？" class="headerlink" title="5、HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？"></a>5、HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？</h3><p>JDK版本 实现方式 节点数&gt;=8 节点数&lt;=6<br>1.8以前 数组+单向链表 数组+单向链表 数组+单向链表<br>1.8以后 数组+单向链表+红黑树 数组+红黑树 数组+单向链表<br>寻址算法优化<br>(n - 1) &amp; hash -&gt; 数组里的一个位置</p>
<h3 id="6、final-finally-finalize"><a href="#6、final-finally-finalize" class="headerlink" title="6、final finally finalize"></a>6、final finally finalize</h3><p>final用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。<br>finally是异常处理语句结构的一部分，表示总是执行。<br>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。</p>
<h3 id="7、强引用-、软引用、-弱引用、虚引用"><a href="#7、强引用-、软引用、-弱引用、虚引用" class="headerlink" title="7、强引用 、软引用、 弱引用、虚引用"></a>7、强引用 、软引用、 弱引用、虚引用</h3><p>强引用（Strong Reference）：通常我们通过new来创建一个新对象时返回的引用就是一个强引用，若一个对象通过一系列强引用可到达，它就是强可达的(strongly reachable)，那么它就不被回收；<br>软引用（Soft Reference）：软引用和弱引用的区别在于，若一个对象是弱引用可达，无论当前内存是否充足它都会被回收，而软引用可达的对象在内存不充足时才会被回收，因此软引用要比弱引用“强”一些；<br>弱引用（Weak Reference）：弱引用简单来说就是将对象留在内存的能力不是那么强的引用。使用Weak Reference，垃圾回收器会帮你来决定引用的对象何时回收并且将对象从内存移除。ThreadLocal的key使用了弱引用。<br>虚引用（Phantom Reference）：虚引用是Java中最弱的引用，那么它弱到什么程度呢？它是如此脆弱以至于我们通过虚引用甚至无法获取到被引用的对象，虚引用存在的唯一作用就是当它指向的对象被回收后，虚引用本身会被加入到引用队列中，用作记录它指向的对象已被回收。</p>
<h3 id="8、Java反射的实现原理"><a href="#8、Java反射的实现原理" class="headerlink" title="8、Java反射的实现原理"></a>8、Java反射的实现原理</h3><p>反射:(reflection):在运行时期,动态地去获取类中的信息(类的信息,方法信息,构造器信息,字段等信息进行操作);<br>一个类中包含的信息有： 构造器，字段，方法<br>如何使用反射描述这些相关的信息<br>Class ： 描述类<br>Method ： 描述方法<br>Constructor ：描述构造器<br>Field ：描述字段</p>
<h3 id="9、Arrays-sort-实现原理和-Collections-实现原理"><a href="#9、Arrays-sort-实现原理和-Collections-实现原理" class="headerlink" title="9、Arrays.sort 实现原理和 Collections 实现原理"></a>9、Arrays.sort 实现原理和 Collections 实现原理</h3><p>事实上Collections.sort方法底层就是调用的array.sort方法，而且不论是Collections.sort或者是Arrays.sort方法，<br>不论是Collections.sort方法或者是Arrays.sort方法，底层实现都是TimSort实现的，这是jdk1.7新增的，以前是归并排序。TimSort算法就是找到已经排好序数据的子序列，然后对剩余部分排序，然后合并起来</p>
<h3 id="10、LinkedHashMap的应用"><a href="#10、LinkedHashMap的应用" class="headerlink" title="10、LinkedHashMap的应用"></a>10、LinkedHashMap的应用</h3><p>LinkedHashMap是HashMap的子类，但是内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于双向链表中。LinkedHashMap支持两种顺序插入顺序 、 访问顺序</p>
<p>插入顺序：先添加的在前面，后添加的在后面。修改操作不影响顺序<br>访问顺序：所谓访问指的是get/put操作，对一个键执行get/put操作后，其对应的键值对会移动到链表末尾，所以最末尾的是最近访问的，最开始的是最久没有被访问的，这就是访问顺序。</p>
<p>可以设置访问顺序用做JVM LRU缓存</p>
<h3 id="11、cloneable接口实现原理"><a href="#11、cloneable接口实现原理" class="headerlink" title="11、cloneable接口实现原理"></a>11、cloneable接口实现原理</h3><p>Cloneable是一个标记接口，里面没有任何的方法。<br>java的一个类，如果要使用Cloneable实现拷贝功能，需要先实现这个接口，然后重写Object的clone方法。对于类中的引用类型的属性，需要在clone方法中实现深拷贝，否则就是浅拷贝。</p>
<h3 id="12、异常分类以及处理机制"><a href="#12、异常分类以及处理机制" class="headerlink" title="12、异常分类以及处理机制"></a>12、异常分类以及处理机制</h3><p>异常的分类：<br>　Throwable是根接口。<br>　Error和Exception继承这个接口 。<br>　　Error是无法处理的异常，比如OutOfMemoryError，一般发生这种异常，JVM会选择终止程序。因此我们编写程序时不需要关心这类异常。<br>　　Exception，也就是我们经常见到的一些异常情况，这些异常是我们可以处理的异常，是所有异常类的父类。<br>　　RuntimeException和checked exception(受査异常也称非运行时异常)继承Exception<br>　　 unchecked Exception(非受査异常)，包括Error和RuntimeException，比如常见的NullPointerException、IndexOutOfBoundsException。对于RuntimeException，java编译器不要求必须进行异常捕获处理或者抛出 声明，由程序员自行决定。<br>　　checked exception（受查异常），也称非运行时异常（运行时异常以外的异常就是非运行时异常），由代 码能力之外的因素导致的运行时错误。java编译器强制程序员必须进行捕获处理，比如常见的有IOExeption 和SQLException。如果不进行捕获或者抛出声明处理，编译都不会通过。<br>处理机制:<br>捕获机制：try-catch-finally<br>try-监控区域，执行可能产生异常的代码<br>catch-捕获，处理异常<br>finally-善后处理，无论是否发生异常，代码总能执行<br>抛出异常：throw 手动抛出异常<br>声明异常：throws 声明方法可能要抛出的异常<br>throw：手动抛出异常，一般由程序员在方法内抛出Exception的子类异常。<br>throws：声明在方法名之后，告诉调用者，该方法可能会抛出异常，也就是说异常发生后会抛给调用者，由 调用者处理异常。</p>
<p>请写出5种常见到的runtime exception<br>常见的几种如下：<br>NullPointerException - 空指针引用异常<br>ClassCastException - 类型强制转换异常。<br>IllegalArgumentException - 传递非法参数异常。<br>ArithmeticException - 算术运算异常<br>ArrayStoreException - 向数组中存放与声明类型不兼容对象异常<br>IndexOutOfBoundsException - 下标越界异常<br>NegativeArraySizeException - 创建一个大小为负数的数组错误异常<br>NumberFormatException - 数字格式异常<br>SecurityException - 安全异常<br>UnsupportedOperationException - 不支持的操作异常</p>
<h3 id="13、数组在内存中如何分配"><a href="#13、数组在内存中如何分配" class="headerlink" title="13、数组在内存中如何分配"></a>13、数组在内存中如何分配</h3><h3 id="14-io的模型和nio-selectionkey是什么"><a href="#14-io的模型和nio-selectionkey是什么" class="headerlink" title="14.io的模型和nio selectionkey是什么"></a>14.io的模型和nio selectionkey是什么</h3><h2 id="多线程："><a href="#多线程：" class="headerlink" title="多线程："></a>多线程：</h2><h3 id="1-什么是多线程，多线程的目的是什么？"><a href="#1-什么是多线程，多线程的目的是什么？" class="headerlink" title="1.什么是多线程，多线程的目的是什么？"></a>1.什么是多线程，多线程的目的是什么？</h3><p>1、避免阻塞（异步调用）<br>2、避免CPU空转<br>3、提升性能</p>
<h3 id="2-什么是线程安全，非线程安全？"><a href="#2-什么是线程安全，非线程安全？" class="headerlink" title="2.什么是线程安全，非线程安全？"></a>2.什么是线程安全，非线程安全？</h3><p>在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p>
<h3 id="3-线程的有那几个状态以及相互间的转换"><a href="#3-线程的有那几个状态以及相互间的转换" class="headerlink" title="3.线程的有那几个状态以及相互间的转换"></a>3.线程的有那几个状态以及相互间的转换</h3><p>创建<br>一般就是创建一个方法继承thread或实现runable方法的类，通过new来创建了。<br>就绪<br>当一个线程调用了start方法后，还没有获取到cpu线程。<br>运行<br>当就绪状态的线程获取到cpu后，便开始运行。<br>阻塞<br>当运行时的线程调用wait、sleep、join等方法后便进入阻塞状态，当线程重新被唤醒时，就会进入就绪或运行。<br>死亡<br>当线程的run方法执行完成后，或调用stop方法后就会死亡。</p>
<h3 id="4-wait-notify为什么必须存在于synchronized块中？"><a href="#4-wait-notify为什么必须存在于synchronized块中？" class="headerlink" title="4.wait/notify为什么必须存在于synchronized块中？"></a>4.wait/notify为什么必须存在于synchronized块中？</h3><p>也就是说wait/notify是线程之间的通信，他们存在竞态，我们必须保证在满足条件的情况下才进行wait。换句话说，如果不加锁的话，那么wait被调用的时候可能wait的条件已经不满足了(如上述)。由于错误的条件下进行了wait，那么就有可能永远不会被notify到，所以我们需要强制wait/notify在synchronized中</p>
<h3 id="5-多线程volatile关键字的作用？"><a href="#5-多线程volatile关键字的作用？" class="headerlink" title="5.多线程volatile关键字的作用？"></a>5.多线程volatile关键字的作用？</h3><p>volatile——Java虚拟机提供的最轻量级的同步机制。这个关键字的作用就是告诉编译器，只要是被此关键字修饰的变量都是易变的、不稳定的。<br>        volatile特性之一：<br>  保证变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。<br>        volatile特性之二：<br>  阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。</p>
<h3 id="6-Runnable，Thread，Callable三者的区别？"><a href="#6-Runnable，Thread，Callable三者的区别？" class="headerlink" title="6.Runnable，Thread，Callable三者的区别？"></a>6.Runnable，Thread，Callable三者的区别？</h3><p>Java中实现多线程有3种方法：<br>继承Thread类<br>实现Runnable接口<br>实现Callable接口(参考&lt;Java编程思想(第4版)&gt;  21.2.4章节，原来一直以为是2种，后来发现是3种)</p>
<p>Thread是继承重写run方法,可以直接执行start方法启动线程<br>Runnable是实现接口,本身不带线程启动方法,需要丢到Thread或者线程池里执行<br>Runnable是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成的能返回一个值，那么可以实现Callable接口而不是Runnable接口。在Java SE5中引入的Callable是一种具有类型参数的泛型，它的参数类型表示的是从方法call()(不是run())中返回的值。<br>总结<br>实现Runnable接口相比继承Thread类有如下优势：</p>
<p>可以避免由于Java的单继承特性而带来的局限；<br>增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；<br>适合多个相同程序代码的线程区处理同一资源的情况。</p>
<p>实现Runnable接口和实现Callable接口的区别:<br>Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的<br>Callable规定的方法是call(),Runnable规定的方法是run()<br>Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)<br>call方法可以抛出异常，run方法不可以<br>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。<br>加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。</p>
<h3 id="7-ThreadLocal-的作用，怎么使用它？"><a href="#7-ThreadLocal-的作用，怎么使用它？" class="headerlink" title="7.ThreadLocal 的作用，怎么使用它？"></a>7.ThreadLocal 的作用，怎么使用它？</h3><p>在每个线程中存储一个变量的副本，这样在每个线程对该变量进行使用的使用，使用的即是该线程的局部变量，从而保证了线程的安全性以及高效性。</p>
<p>ThreadLocal的使用场景：<br>在并发编程中时常有这样一种需求：每条线程都需要存取一个同名变量，但每条线程中该变量的值均不相同。比如后台系统登录账号信息</p>
<h3 id="8-Lock与synchronized的区别？"><a href="#8-Lock与synchronized的区别？" class="headerlink" title="8.Lock与synchronized的区别？"></a>8.Lock与synchronized的区别？</h3><p>1.　　Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定。<br>　　   但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将 unLock()放到finally{} 中；<br>2.　　synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；<br>　　　而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；<br>3.　　Lock可以让等待锁的线程响应中断，线程可以中断去干别的事务，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断<br>4.　　通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。<br>5.　　Lock可以提高多个线程进行读操作的效率。</p>
<h3 id="9-请对比hashTable-concurrentHashMap-HashMap的区别？"><a href="#9-请对比hashTable-concurrentHashMap-HashMap的区别？" class="headerlink" title="9.请对比hashTable , concurrentHashMap, HashMap的区别？"></a>9.请对比hashTable , concurrentHashMap, HashMap的区别？</h3><p>HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。<br>HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。<br>HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。<br>Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。<br>最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。</p>
<h3 id="10-什么是线程死锁？产生的原因？如何避免死锁？"><a href="#10-什么是线程死锁？产生的原因？如何避免死锁？" class="headerlink" title="10.什么是线程死锁？产生的原因？如何避免死锁？"></a>10.什么是线程死锁？产生的原因？如何避免死锁？</h3><h3 id="11-什么是Executors框架？"><a href="#11-什么是Executors框架？" class="headerlink" title="11.什么是Executors框架？"></a>11.什么是Executors框架？</h3><h3 id="12-什么是Callable和Future"><a href="#12-什么是Callable和Future" class="headerlink" title="12.什么是Callable和Future?"></a>12.什么是Callable和Future?</h3><h3 id="13-在静态方法上使用同步时会发生什么事？"><a href="#13-在静态方法上使用同步时会发生什么事？" class="headerlink" title="13.在静态方法上使用同步时会发生什么事？"></a>13.在静态方法上使用同步时会发生什么事？</h3><p>同步静态方法时会获取该类的“Class”对象，所以当一个线程进入同步的静态方法中时，线程监视器获取类本身的对象锁，其它线程不能进入这个类的任何静态同步方法。它不像实例方法，因为多个线程可以同时访问不同实例同步实例方法。</p>
<h3 id="14-什么是线程饿死，什么是活锁？"><a href="#14-什么是线程饿死，什么是活锁？" class="headerlink" title="14.什么是线程饿死，什么是活锁？"></a>14.什么是线程饿死，什么是活锁？</h3><h2 id="线程池："><a href="#线程池：" class="headerlink" title="线程池："></a>线程池：</h2><h3 id="1-解释线程池的作用？"><a href="#1-解释线程池的作用？" class="headerlink" title="1.解释线程池的作用？"></a>1.解释线程池的作用？</h3><p>1）降低资源消耗；2）提高响应速度；3）提高线程的可管理性。<br>线程的创建和销毁的开销是巨大的，而通过线程池的重用大大减少了这些不必要的开销，当然既然少了这么多消费内存的开销，其线程执行速度也是突飞猛进的提升。</p>
<p>并发：在某个时间段内，多个程序都处在执行和执行完毕之间；但在一个时间点上只有一个程序在运行。头脑风暴：老鹰妈妈喂小雏鹰食物，小雏鹰很多，而老鹰只有一张嘴，她需要一个个喂过去，到最后每个小雏鹰都可以吃到，但是在一个时间点里只能有一个小雏鹰可以吃到美味的食物。</p>
<p>并行：在某个时间段里，每个程序按照自己独立异步的速度执行，程序之间互不干扰。头脑风暴：这就好似老鹰妈妈决定这样喂食太费劲于是为每个小雏鹰请了个保姆，这样子在一个时间点里，每个小雏鹰都可以同时吃到食物，而且互相不干扰。</p>
<h3 id="2-线程池的处理流程？"><a href="#2-线程池的处理流程？" class="headerlink" title="2.线程池的处理流程？"></a>2.线程池的处理流程？</h3><p><img src="/images/loading.png" data-original="/images/pasted-11.png" alt="upload successful"><br>线程池优先要创建出基本线程池大小（corePoolSize）的线程数量，没有达到这个数量时，每次提交新任务都会直接创建一个新线程，当达到了基本线程数量后，又有新任务到达，优先放入等待队列，如果队列满了，才去创建新的线程（不能超过线程池的最大数maxmumPoolSize）</p>
<h3 id="3-jdk提供的线程池工具类有哪些，区别是什么？"><a href="#3-jdk提供的线程池工具类有哪些，区别是什么？" class="headerlink" title="3.jdk提供的线程池工具类有哪些，区别是什么？"></a>3.jdk提供的线程池工具类有哪些，区别是什么？</h3><p>newFixedThreadPool<br>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</p>
<p>newCachedThreadPool<br>创建一个可缓存的线程池。这种类型的线程池特点是：<br>1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。<br>2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p>
<p>newSingleThreadExecutor<br>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。</p>
<p>newScheduleThreadPool<br>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。(这种线程池原理暂还没完全了解透彻)</p>
<h3 id="4-关闭线程池的方法有哪些？区别是什么？"><a href="#4-关闭线程池的方法有哪些？区别是什么？" class="headerlink" title="4.关闭线程池的方法有哪些？区别是什么？"></a>4.关闭线程池的方法有哪些？区别是什么？</h3><p>一种是调用其shutdown()方法，另一种是调用shutdownNow()方法<br>shutdown:<br>1、调用之后不允许继续往线程池内继续添加线程;<br>2、线程池的状态变为SHUTDOWN状态;<br>3、所有在调用shutdown()方法之前提交到ExecutorSrvice的任务都会执行;<br>4、一旦所有线程结束执行当前任务，ExecutorService才会真正关闭。</p>
<p>shutdownNow():<br>1、该方法返回尚未执行的 task 的 List;<br>2、线程池的状态变为STOP状态;<br>3、阻止所有正在等待启动的任务, 并且停止当前正在执行的任务。</p>
<p>简单点来说，就是:<br>shutdown()调用后，不可以再 submit 新的 task，已经 submit 的将继续执行<br>shutdownNow()调用后，试图停止当前正在执行的 task，并返回尚未执行的 task 的 list</p>
<h2 id="MySqL："><a href="#MySqL：" class="headerlink" title="MySqL："></a>MySqL：</h2><h3 id="1-sql优化方法？"><a href="#1-sql优化方法？" class="headerlink" title="1.sql优化方法？"></a>1.sql优化方法？</h3><h3 id="2-建索引有哪些策略和原则？"><a href="#2-建索引有哪些策略和原则？" class="headerlink" title="2.建索引有哪些策略和原则？"></a>2.建索引有哪些策略和原则？</h3><h3 id="3-索引存储原理？"><a href="#3-索引存储原理？" class="headerlink" title="3.索引存储原理？"></a>3.索引存储原理？</h3><h3 id="4-mysql数据库锁有哪几种？"><a href="#4-mysql数据库锁有哪几种？" class="headerlink" title="4.mysql数据库锁有哪几种？"></a>4.mysql数据库锁有哪几种？</h3><h3 id="5-写一个数据库死锁的sql？"><a href="#5-写一个数据库死锁的sql？" class="headerlink" title="5.写一个数据库死锁的sql？"></a>5.写一个数据库死锁的sql？</h3><h3 id="6-如何做数据库分库分表？（mycat）"><a href="#6-如何做数据库分库分表？（mycat）" class="headerlink" title="6.如何做数据库分库分表？（mycat）"></a>6.如何做数据库分库分表？（mycat）</h3><h2 id="消息队列："><a href="#消息队列：" class="headerlink" title="消息队列："></a>消息队列：</h2><h3 id="1-RabbitMQ的exchange有哪几种？"><a href="#1-RabbitMQ的exchange有哪几种？" class="headerlink" title="1.RabbitMQ的exchange有哪几种？"></a>1.RabbitMQ的exchange有哪几种？</h3><h3 id="2-mq的使用场景有哪些？"><a href="#2-mq的使用场景有哪些？" class="headerlink" title="2.mq的使用场景有哪些？"></a>2.mq的使用场景有哪些？</h3><h3 id="3-RabbitMQ的系统架构？"><a href="#3-RabbitMQ的系统架构？" class="headerlink" title="3.RabbitMQ的系统架构？"></a>3.RabbitMQ的系统架构？</h3><h3 id="4-RabbitMQ的任务分发机制有哪些？"><a href="#4-RabbitMQ的任务分发机制有哪些？" class="headerlink" title="4.RabbitMQ的任务分发机制有哪些？"></a>4.RabbitMQ的任务分发机制有哪些？</h3><h2 id="Redis："><a href="#Redis：" class="headerlink" title="Redis："></a>Redis：</h2><h3 id="1-使用redis有哪些好处"><a href="#1-使用redis有哪些好处" class="headerlink" title="1.使用redis有哪些好处?"></a>1.使用redis有哪些好处?</h3><h3 id="2-redis相比memcached有哪些优势？"><a href="#2-redis相比memcached有哪些优势？" class="headerlink" title="2.redis相比memcached有哪些优势？"></a>2.redis相比memcached有哪些优势？</h3><h3 id="3-redis常见性能问题和解决方案"><a href="#3-redis常见性能问题和解决方案" class="headerlink" title="3.redis常见性能问题和解决方案?"></a>3.redis常见性能问题和解决方案?</h3><h3 id="4-redis集群有哪些模式？"><a href="#4-redis集群有哪些模式？" class="headerlink" title="4.redis集群有哪些模式？"></a>4.redis集群有哪些模式？</h3><h3 id="5-redis中穿透，击穿与雪崩的预防及解决？"><a href="#5-redis中穿透，击穿与雪崩的预防及解决？" class="headerlink" title="5.redis中穿透，击穿与雪崩的预防及解决？"></a>5.redis中穿透，击穿与雪崩的预防及解决？</h3><h3 id="6-redis哨兵模式集群的原理？"><a href="#6-redis哨兵模式集群的原理？" class="headerlink" title="6.redis哨兵模式集群的原理？"></a>6.redis哨兵模式集群的原理？</h3><h2 id="Spring："><a href="#Spring：" class="headerlink" title="Spring："></a>Spring：</h2><h3 id="1-IOC和AOP的实现原理？"><a href="#1-IOC和AOP的实现原理？" class="headerlink" title="1.IOC和AOP的实现原理？"></a>1.IOC和AOP的实现原理？</h3><h3 id="2-AOP的应用场景有哪些？以及动态代理原理是什么？"><a href="#2-AOP的应用场景有哪些？以及动态代理原理是什么？" class="headerlink" title="2.AOP的应用场景有哪些？以及动态代理原理是什么？"></a>2.AOP的应用场景有哪些？以及动态代理原理是什么？</h3><h3 id="3-事务的传播属性有哪几种？"><a href="#3-事务的传播属性有哪几种？" class="headerlink" title="3.事务的传播属性有哪几种？"></a>3.事务的传播属性有哪几种？</h3><h3 id="4-bean的生命周期？"><a href="#4-bean的生命周期？" class="headerlink" title="4.bean的生命周期？"></a>4.bean的生命周期？</h3><h3 id="5-Spring有哪些模块，分别有哪些作用和功能？"><a href="#5-Spring有哪些模块，分别有哪些作用和功能？" class="headerlink" title="5.Spring有哪些模块，分别有哪些作用和功能？"></a>5.Spring有哪些模块，分别有哪些作用和功能？</h3><h2 id="SpringMVC："><a href="#SpringMVC：" class="headerlink" title="SpringMVC："></a>SpringMVC：</h2><h3 id="1-SpringMVC的工作原理，举例说明流程？"><a href="#1-SpringMVC的工作原理，举例说明流程？" class="headerlink" title="1.SpringMVC的工作原理，举例说明流程？"></a>1.SpringMVC的工作原理，举例说明流程？</h3><h2 id="MyBatis："><a href="#MyBatis：" class="headerlink" title="MyBatis："></a>MyBatis：</h2><h3 id="1-Mybatis的二级缓存？"><a href="#1-Mybatis的二级缓存？" class="headerlink" title="1.Mybatis的二级缓存？"></a>1.Mybatis的二级缓存？</h3><h2 id="Zookeeper："><a href="#Zookeeper：" class="headerlink" title="Zookeeper："></a>Zookeeper：</h2><h3 id="1-zk的作用和原理？"><a href="#1-zk的作用和原理？" class="headerlink" title="1.zk的作用和原理？"></a>1.zk的作用和原理？</h3><h3 id="2-zk设计要满足哪些特性？分别解释一下？"><a href="#2-zk设计要满足哪些特性？分别解释一下？" class="headerlink" title="2.zk设计要满足哪些特性？分别解释一下？"></a>2.zk设计要满足哪些特性？分别解释一下？</h3><h3 id="3-zk的选举机制是什么？是否有了解Paxos算法？"><a href="#3-zk的选举机制是什么？是否有了解Paxos算法？" class="headerlink" title="3.zk的选举机制是什么？是否有了解Paxos算法？"></a>3.zk的选举机制是什么？是否有了解Paxos算法？</h3><h2 id="Nginx："><a href="#Nginx：" class="headerlink" title="Nginx："></a>Nginx：</h2><h3 id="1-什么是Nginx？Nginx的作用是什么？"><a href="#1-什么是Nginx？Nginx的作用是什么？" class="headerlink" title="1.什么是Nginx？Nginx的作用是什么？"></a>1.什么是Nginx？Nginx的作用是什么？</h3><h3 id="2-Nginx-有哪些特点？"><a href="#2-Nginx-有哪些特点？" class="headerlink" title="2.Nginx 有哪些特点？"></a>2.Nginx 有哪些特点？</h3><h2 id="分布式："><a href="#分布式：" class="headerlink" title="分布式："></a>分布式：</h2><h3 id="1-什么是分布式系统？解决什么问题？"><a href="#1-什么是分布式系统？解决什么问题？" class="headerlink" title="1.什么是分布式系统？解决什么问题？"></a>1.什么是分布式系统？解决什么问题？</h3><h3 id="2-如何提升系统吞吐量？"><a href="#2-如何提升系统吞吐量？" class="headerlink" title="2.如何提升系统吞吐量？"></a>2.如何提升系统吞吐量？</h3><h3 id="3-如何降低延迟？"><a href="#3-如何降低延迟？" class="headerlink" title="3.如何降低延迟？"></a>3.如何降低延迟？</h3><h3 id="4-如何做故障恢复？"><a href="#4-如何做故障恢复？" class="headerlink" title="4.如何做故障恢复？"></a>4.如何做故障恢复？</h3><h3 id="5-如何做日志统一系统？"><a href="#5-如何做日志统一系统？" class="headerlink" title="5.如何做日志统一系统？"></a>5.如何做日志统一系统？</h3><h3 id="6-怎么实现通讯编程？如rpc服务，webService服务等；"><a href="#6-怎么实现通讯编程？如rpc服务，webService服务等；" class="headerlink" title="6.怎么实现通讯编程？如rpc服务，webService服务等；"></a>6.怎么实现通讯编程？如rpc服务，webService服务等；</h3><h3 id="7-高并发秒杀解决方案有哪些？"><a href="#7-高并发秒杀解决方案有哪些？" class="headerlink" title="7.高并发秒杀解决方案有哪些？"></a>7.高并发秒杀解决方案有哪些？</h3><h3 id="8-分布式系统有哪些优势？"><a href="#8-分布式系统有哪些优势？" class="headerlink" title="8.分布式系统有哪些优势？"></a>8.分布式系统有哪些优势？</h3><h3 id="9-分布式系统会面临什么挑战？"><a href="#9-分布式系统会面临什么挑战？" class="headerlink" title="9.分布式系统会面临什么挑战？"></a>9.分布式系统会面临什么挑战？</h3><h3 id="10-如何设计分布式系统？"><a href="#10-如何设计分布式系统？" class="headerlink" title="10.如何设计分布式系统？"></a>10.如何设计分布式系统？</h3><h3 id="11-如何做分布式事务？"><a href="#11-如何做分布式事务？" class="headerlink" title="11.如何做分布式事务？"></a>11.如何做分布式事务？</h3><h2 id="其他问题："><a href="#其他问题：" class="headerlink" title="其他问题："></a>其他问题：</h2><h3 id="1-如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？"><a href="#1-如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？" class="headerlink" title="1.如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？"></a>1.如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？</h3><h3 id="2-如何支持大量流量的访问？可以在哪些地方进行优化？"><a href="#2-如何支持大量流量的访问？可以在哪些地方进行优化？" class="headerlink" title="2.如何支持大量流量的访问？可以在哪些地方进行优化？"></a>2.如何支持大量流量的访问？可以在哪些地方进行优化？</h3><h3 id="3-双11流量怎么控制？"><a href="#3-双11流量怎么控制？" class="headerlink" title="3.双11流量怎么控制？"></a>3.双11流量怎么控制？</h3><h3 id="4-1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）"><a href="#4-1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）" class="headerlink" title="4.1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）"></a>4.1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）</h3><h3 id="5-分布式环境下，如何对一个web请求的做监控？"><a href="#5-分布式环境下，如何对一个web请求的做监控？" class="headerlink" title="5.分布式环境下，如何对一个web请求的做监控？"></a>5.分布式环境下，如何对一个web请求的做监控？</h3>]]></content>
  </entry>
  <entry>
    <title>Java程序员Chrome浏览器必装插件</title>
    <url>/archives/b0de6b16.html</url>
    <content><![CDATA[<p>整理了一下自己一直在用的Chrome浏览器插件,之后有觉得好用的也会更新进来</p><h2 id="SQLDelimiter"><a href="#SQLDelimiter" class="headerlink" title="SQLDelimiter"></a><a href="https://chrome.google.com/webstore/detail/sqldelimiter/ngobnmgdnggmcafeblbealjjnpakoghd" target="_blank" rel="noopener">SQLDelimiter</a></h2><p>参数拆分插件,从Excel直接复制或者MySQL查询结果复制,直接转化成带逗号分隔<br><img src="/images/loading.png" data-original="/images/pasted-3.png" alt="upload successful"></p><h2 id="JSON-handle"><a href="#JSON-handle" class="headerlink" title="JSON-handle"></a><a href="https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj" target="_blank" rel="noopener">JSON-handle</a></h2><a id="more"></a>

<p>Json格式化或者转成更好看的形式,方便检查数据<br><img src="/images/loading.png" data-original="/images/pasted-4.png" alt="upload successful"></p>
<h2 id="JSON-Formatter"><a href="#JSON-Formatter" class="headerlink" title="JSON Formatter"></a><a href="https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa" target="_blank" rel="noopener">JSON Formatter</a></h2><p>直接格式化http请求返回的json内容</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>插件</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员必须知道的linux命令</title>
    <url>/archives/b77c3e4.html</url>
    <content><![CDATA[<h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find / -name filename.txt 根据名称查找/目录下的filename.txt文件。</span><br><span class="line">find . -name &quot;*.xml&quot; 递归查找所有的xml文件</span><br><span class="line">find .  -name &quot;*.xml&quot; |xargs grep  &quot;hello world&quot; 递归查找所有文件内容中包含hello world的xml文件</span><br><span class="line">grep -H  &apos;spring&apos; *.xml 查找所以有的包含spring的xml文件</span><br><span class="line">find ./ -size 0 | xargs rm -f &amp; 删除文件大小为零的文件</span><br><span class="line">ls -l | grep &apos;jar&apos; 查找当前目录中的所有jar文件</span><br><span class="line">grep &apos;test&apos; d* 显示所有以d开头的文件中包含test的行。</span><br><span class="line">grep &apos;test&apos; aa bb cc 显示在aa，bb，cc文件中匹配test的行。</span><br><span class="line">grep &apos;[a-z]\&#123;5\&#125;&apos; aa 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</span><br></pre></td></tr></table></figure><a id="more"></a>
<h3 id="查看一个程序是否运行"><a href="#查看一个程序是否运行" class="headerlink" title="查看一个程序是否运行"></a>查看一个程序是否运行</h3><p><code>ps –ef|grep tomcat 查看所有有关tomcat的进程</code></p>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p><code>kill -9 19979 终止线程号位19979的线程</code></p>
<h3 id="查看文件，包含隐藏文件"><a href="#查看文件，包含隐藏文件" class="headerlink" title="查看文件，包含隐藏文件"></a>查看文件，包含隐藏文件</h3><p><code>ls -al</code></p>
<h3 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h3><p><code>pwd</code></p>
<h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp  source dest 复制文件</span><br><span class="line">cp -r  sourceFolder targetFolder 递归复制整个文件夹</span><br><span class="line">scp sourecFile romoteUserName@remoteIp:remoteAddr 远程拷贝</span><br></pre></td></tr></table></figure>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p><code>mkdir newfolder</code></p>
<h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><p><code>rmdir deleteEmptyFolder 删除空目录 rm -rf deleteFile 递归删除目录中所有内容</code></p>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p><code>mv /temp/movefile /targetFolder</code></p>
<h3 id="重命令"><a href="#重命令" class="headerlink" title="重命令"></a>重命令</h3><p><code>mv oldNameFile newNameFile</code></p>
<h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p><code>su -username</code></p>
<h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p><code>chmod 777 file.java //file.java的权限-rwxrwxrwx，r表示读、w表示写、x表示可执行</code></p>
<h3 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h3><p><code>tar -czf test.tar.gz /test1 /test2</code></p>
<h3 id="列出压缩文件列表"><a href="#列出压缩文件列表" class="headerlink" title="列出压缩文件列表"></a>列出压缩文件列表</h3><p><code>tar -tzf test.tar.gz</code></p>
<h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><p><code>tar -xvzf test.tar.gz</code></p>
<h3 id="查看文件头10行"><a href="#查看文件头10行" class="headerlink" title="查看文件头10行"></a>查看文件头10行</h3><p><code>head -n 10 example.txt</code></p>
<h3 id="查看文件尾10行"><a href="#查看文件尾10行" class="headerlink" title="查看文件尾10行"></a>查看文件尾10行</h3><p><code>tail -n 10 example.txt</code></p>
<h3 id="查看日志类型文件"><a href="#查看日志类型文件" class="headerlink" title="查看日志类型文件"></a>查看日志类型文件</h3><p><code>tail -f exmaple.log //这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。</code></p>
<h3 id="使用超级管理员身份执行命令"><a href="#使用超级管理员身份执行命令" class="headerlink" title="使用超级管理员身份执行命令"></a>使用超级管理员身份执行命令</h3><p><code>sudo rm a.txt 使用管理员身份删除文件</code></p>
<h3 id="查看端口占用情况"><a href="#查看端口占用情况" class="headerlink" title="查看端口占用情况"></a>查看端口占用情况</h3><p><code>netstat -tln | grep 8080 查看端口8080的使用情况</code></p>
<h3 id="查看端口属于哪个程序"><a href="#查看端口属于哪个程序" class="headerlink" title="查看端口属于哪个程序"></a>查看端口属于哪个程序</h3><p><code>lsof -i :8080</code></p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps aux|grep java 查看java进程</span><br><span class="line">ps aux 查看所有进程</span><br></pre></td></tr></table></figure>
<h3 id="以树状图列出目录的内容"><a href="#以树状图列出目录的内容" class="headerlink" title="以树状图列出目录的内容"></a>以树状图列出目录的内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tree a</span><br><span class="line">ps:Mac下使用tree命令</span><br></pre></td></tr></table></figure>
<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://file.tgz mac下安装wget命令</span><br><span class="line">curl http://file.tgz</span><br></pre></td></tr></table></figure>
<h3 id="网络检测"><a href="#网络检测" class="headerlink" title="网络检测"></a>网络检测</h3><p><code>ping www.taobao.com</code></p>
<h3 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h3><p><code>ssh userName@ip</code></p>
<h3 id="打印信息"><a href="#打印信息" class="headerlink" title="打印信息"></a>打印信息</h3><p>echo $JAVA_HOME 打印java home环境变量的值</p>
<h3 id="java-常用命令"><a href="#java-常用命令" class="headerlink" title="java 常用命令"></a>java 常用命令</h3><p><code>java javac jps ,jstat ,jmap, jstack</code></p>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p><code>svn git maven</code></p>
<h3 id="linux命令学习网站"><a href="#linux命令学习网站" class="headerlink" title="linux命令学习网站:"></a>linux命令学习网站:</h3><p><a href="http://explainshell.com/" target="_blank" rel="noopener">http://explainshell.com/</a></p>
<h3 id="修改机器名"><a href="#修改机器名" class="headerlink" title="修改机器名"></a>修改机器名</h3><pre><code>更改/etc/sysconfig下的network文件，在提示符下输入vi /etc/sysconfig/network，然后将HOSTNAME后面的值改为想要设置的主机名，在提示符下输入reboot命令，重新启动服务器。</code></pre><h3 id="解压nginx日志"><a href="#解压nginx日志" class="headerlink" title="解压nginx日志"></a>解压nginx日志</h3><pre><code>现在nginx日志用gzip压缩，文件以gz结尾。

解压命令： gzip -d  压缩文件名 
不解压，直接查看压缩文件内容，命令： gunzip -c  压缩文件名</code></pre><h3 id="测试磁盘的读写"><a href="#测试磁盘的读写" class="headerlink" title="测试磁盘的读写"></a>测试磁盘的读写</h3><pre><code> time有计时作用，dd用于复制，从if读出，写到of。if=/dev/zero不产生IO，因此可以用来测试纯写速度。同理of=/dev/null不产生IO，可以用来测试纯读速度。bs是每次读或写的大小，即一个块的大小，count是读写块的数量。

纯写速度： time dd if=/dev/zero of=/var/test bs=8k count=10000

 纯读速度：time dd if=/var/test of=/dev/null bs=8k</code></pre><h3 id="linux端口连接范围-gt-gt-gt-gt-gt-用于向外连接的端口范围"><a href="#linux端口连接范围-gt-gt-gt-gt-gt-用于向外连接的端口范围" class="headerlink" title="linux端口连接范围&gt;&gt;&gt;&gt;&gt;用于向外连接的端口范围"></a>linux端口连接范围&gt;&gt;&gt;&gt;&gt;用于向外连接的端口范围</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/ip_local_port_range</span><br><span class="line">net.ipv4.ip_local_port_range=1024 65000</span><br></pre></td></tr></table></figure>
<h3 id="修改打开文件最大数，vi-etc-security-limits-conf-加入以下两行"><a href="#修改打开文件最大数，vi-etc-security-limits-conf-加入以下两行" class="headerlink" title="修改打开文件最大数，vi /etc/security/limits.conf,加入以下两行"></a>修改打开文件最大数，vi /etc/security/limits.conf,加入以下两行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* soft nofile 402400</span><br><span class="line">* hard nofile 480000</span><br></pre></td></tr></table></figure>
<p>然后重新登录即可使用命令ulimit -a 查看到修改。在这之前启动的进程仍旧使用以前的配置，之后启动的进程使用最新配置<br>用ulimit -n 2048 修改只对当前的shell有效，退出后失效</p>
<h3 id="tcp连接复用和快速回收"><a href="#tcp连接复用和快速回收" class="headerlink" title="tcp连接复用和快速回收"></a>tcp连接复用和快速回收</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br></pre></td></tr></table></figure>
<p><code>net.ipv4.tcp_keepalive_time = 1200</code>表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</p>
<p><code>net.ipv4.ip_local_port_range = 1024</code> 65535表示用于向外连接的端口范围。缺省情况下过窄：32768到61000，改为1024到65535。</p>
<p><code>net.ipv4.tcp_max_syn_backlog = 16384</code><br>表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。 </p>
<p><code>net.ipv4.tcp_max_tw_buckets = 180000</code> </p>
<p>表示系统同时保持TIME_WAIT套接字的最大数 量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000,可适当增大该值，但不建议减小。对于Apache、 Nginx等服务器，以上几行参数的设置可以很好地减少TIME_WAIT套接字数量，但是对于Squid，效果却不大。此项参数可以控制 TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time = 180</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 15</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 2</span><br><span class="line">net.ipv4.tcp_fin_timeout = 5</span><br><span class="line"></span><br><span class="line">nf_conntrack: table full, dropping packet.</span><br></pre></td></tr></table></figure>


<h3 id="查看NS提供商"><a href="#查看NS提供商" class="headerlink" title="查看NS提供商"></a>查看NS提供商</h3><p><code>dig baidu.com NS trace @8.8.8.8</code></p>
<h3 id="指定NS解析域名"><a href="#指定NS解析域名" class="headerlink" title="指定NS解析域名"></a>指定NS解析域名</h3><p> <code>nslookup www.baidu.com</code></p>
<h3 id="sz-rz安装"><a href="#sz-rz安装" class="headerlink" title="sz/rz安装"></a>sz/rz安装</h3><p>（1）编译安装</p>
<p>root 账号登陆后，依次执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line"></span><br><span class="line">wget http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxvf lrzsz-0.12.20.tar.gz &amp;&amp; cd lrzsz-0.12.20</span><br><span class="line"></span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>上面安装过程默认把lsz和lrz安装到了/usr/local/bin/目录下，现在我们并不能直接使用，下面创建软链接，并命名为rz/sz：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/bin</span><br><span class="line">ln -s /usr/local/bin/lrz rz</span><br><span class="line">ln -s /usr/local/bin/lsz sz</span><br></pre></td></tr></table></figure>


<p>（2）yum安装</p>
<p>root 账号登陆后执行以下命令：</p>
<p><code>yum install -y lrzsz</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Meno</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql数据库配置优化</title>
    <url>/archives/692ce8b8.html</url>
    <content><![CDATA[<h1 id="tmp-table-size-临时表-用于排序"><a href="#tmp-table-size-临时表-用于排序" class="headerlink" title="tmp_table_size 临时表 (用于排序)"></a>tmp_table_size 临时表 (用于排序)</h1><p>show global status like ‘created_tmp%’; </p><p>| Variable_name | Value | </p><p>| Created_tmp_disk_tables | 21197 | #在磁盘上创建临时表的次数 </p><a id="more"></a>


<p>| Created_tmp_files | 58 | #在磁盘上创建临时文件的次数</p>
<p>| Created_tmp_tables | 1771587 | #使用临时表的总次数</p>
<p>TmpTable的状况主要是用于监控MySQL使用临时表的量是否过多，</p>
<p>是否有临时表过大而不得不从内存中换出到磁盘文件上。 </p>
<p>a.如果：</p>
<p>Created_tmp_disk_tables/Created_tmp_tables&gt;10%，则需调大tmp_table_size</p>
<p>比较理想的配置是：</p>
<p>Created_tmp_disk_tables/Created_tmp_tables&lt;=25%</p>
<p>b.如果：</p>
<p>Created_tmp_tables非常大 ，则可能是系统中排序操作过多，或者是表连接方式不是很优化。</p>
<p>相关参数：</p>
<p>tmp_table_size 内存中，临时表区域总大小</p>
<p>max_heap_table_size 内存中，单个临时表的最大值，超过的部分会放到硬盘上。</p>
<h1 id="连接数"><a href="#连接数" class="headerlink" title="连接数:"></a>连接数:</h1><p>max_connections MySQL最大连接数</p>
<p>back_log 当连接数满了后，设置一个值，允许多少个连接进入等待堆栈</p>
<p>max_connect_errors 账号连接到服务器允许的错误次数</p>
<p>connect_timeout 一个连接报文的最大时间(单位：s)</p>
<p>skip-name-resolve 加入my.cnf即可，MySQL在收到连接请求的时候，会根据请求包 </p>
<p>中获得的ip来反向追查请求者的主机名。然后再根据返回</p>
<p>的主机名又一次去获取ip。如果两次获得的ip相同，那么连接就成功建立了。</p>
<p>加了次参数，即可省去这个步骤</p>
<p>NOTES:</p>
<p>查询当前连接数:show global status like ‘connections’;</p>
<h1 id="table-cache相关优化-："><a href="#table-cache相关优化-：" class="headerlink" title="table cache相关优化 ："></a>table cache相关优化 ：</h1><p>参数table_open_cache，将表的文件描述符打开，cache在内存中</p>
<p>global status：</p>
<p>open_tables 当前系统中打开的文件描述符的数量</p>
<p>opened_tables 系统打开过的文件描述符的数量</p>
<h1 id="慢查询日志："><a href="#慢查询日志：" class="headerlink" title="慢查询日志："></a>慢查询日志：</h1><p>slow_launch_time=2 查询大于某个时间的值(单位：s)</p>
<p>slow_query_log=on/off 开启关闭慢查询日志</p>
<p>slow_query_log_file=/opt/data/xxx.log 慢查询日志位置</p>
<h1 id="查询缓存-Query-Cache"><a href="#查询缓存-Query-Cache" class="headerlink" title="查询缓存(Query Cache)"></a>查询缓存(Query Cache)</h1><p>将客户端的SQL语句(仅限select语句)通过hash计算，放在hash链表中，同时将该SQL的结果集</p>
<p>放在内存中cache。该hash链表中，存放了结果集的内存地址以及所涉及到的所有Table等信息。</p>
<p>如果与该结果集相关的任何一个表的相关信息发生变化后(包扩：数据、索引、表结构等)，</p>
<p>就会导致结果集失效，释放与该结果集相关的所有资源，以便后面其他SQL能够使用。</p>
<p>当客户端有select SQL进入，先计算hash值，如果有相同的，就会直接将结果集返回。</p>
<p>Query Cache的负面影响：</p>
<p>a.使用了Query Cache后，每条select SQL都要进行hash计算，然后查找结果集。对于大量SQL</p>
<p>访问，会消耗过多额外的CPU。</p>
<p>b.如果表变更比较频繁，则会造成结果集失效率非常高。</p>
<p>c.结果集中保存的是整个结果，可能存在一条记录被多次cache的情况，这样会造成内存资源的</p>
<p>过度消耗。</p>
<p>Query Cache的正确使用：</p>
<p>a.根据表的变更情况来选择是否使用Query Cache，可使用SQL Hint：SQL_NO_CACHE和SQL_CACHE</p>
<p>b.对于 变更比较少 或 数据基本处于静态 的表，使用SQL_CACHE</p>
<p>c.对于结果集比较大的，使用Query Cache可能造成内存不足，或挤占内存。</p>
<p>可使用1.SQL_NO_CACHE 2.query_cache_limit控制Query Cache的最大结果集(系统默认1M)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;%query_cache%&apos;;</span><br><span class="line"></span><br><span class="line">+------------------------------+---------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+------------------------------+---------+</span><br><span class="line"></span><br><span class="line">| have_query_cache | YES | #是否支持Query Cache</span><br><span class="line"></span><br><span class="line">| query_cache_limit | 1048576 | #单个结果集的最大值，默认1M</span><br><span class="line"></span><br><span class="line">| query_cache_min_res_unit | 4096 | #每个结果集存放的最小内存，默认4K</span><br><span class="line"></span><br><span class="line">| query_cache_size | 0 | #Query Cache总内存大小，必须是1024的整数倍</span><br><span class="line"></span><br><span class="line">| query_cache_type | ON | #ON,OFF,DEMAND(包含SQL_CACHE的查询中才开启)</span><br><span class="line"></span><br><span class="line">| query_cache_wlock_invalidate | OFF | </span><br><span class="line"></span><br><span class="line">+------------------------------+---------+</span><br><span class="line"></span><br><span class="line">#query_cache_wlock_invalidate：</span><br></pre></td></tr></table></figure>

<p>针对于MyISAM存储引擎，设置当有WRITELOCK在某个Table上面的时候，</p>
<p>读请求是要等待WRITE LOCK释放资源之后再查询还是允许直接从QueryCache中读取结果，</p>
<p>默认为FALSE（可以直接从QueryCache中取得结果）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &apos;qcache%&apos;;</span><br><span class="line"></span><br><span class="line">+-------------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-------------------------+-------+</span><br><span class="line"></span><br><span class="line">| Qcache_free_blocks | 0 | </span><br><span class="line"></span><br><span class="line">| Qcache_free_memory | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_hits | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_inserts | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_lowmem_prunes | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_not_cached | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_queries_in_cache | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_total_blocks | 0 |</span><br><span class="line"></span><br><span class="line">+-------------------------+-------+</span><br><span class="line"></span><br><span class="line"># Qcache_free_blocks</span><br></pre></td></tr></table></figure>

<p>QueryCache中目前还有多少剩余的blocks</p>
<p>a.如果Qcache_free_blocks值较大，说明Query Cache中内存碎片比较多</p>
<p>b.如果Qcache_free_blocks约等于Qcache_total_blocks/2，说明内存碎片非常严重</p>
<p>移除碎片：</p>
<p>flush query cache;</p>
<p>这个命令会把所有的存储块向上移动，并把自由块移到底部。</p>
<p>查询缓存碎片率：</p>
<p>查询缓存碎片率 = Qcache_free_blocks / Qcache_total_blocks * 100%</p>
<p>c.如果：</p>
<p>查询缓存碎片率超过20%， 可以用flush query cache整理碎片，或者减小</p>
<p>query_cache_min_res_unit(如果该系统的查询都是小数据量的话)</p>
<h2 id="Qcache-free-memory"><a href="#Qcache-free-memory" class="headerlink" title="Qcache_free_memory"></a>Qcache_free_memory</h2><p>QueryCache中目前剩余的内存大小</p>
<p>查询缓存利用率：</p>
<p>查询缓存利用率 = (query_cache_size – Qcache_free_memory) / query_cache_size * 100%</p>
<p>a.如果：</p>
<p>查询缓存利用率在25%以下，说明query_cache_size设置过大，可适当减小。</p>
<p>b.如果：</p>
<p>查询缓存利用率&gt;80%，且Qcache_lowmem_prunes&gt;50，说明query_cache_size可能有点小，或者</p>
<p>有太多的碎片</p>
<h2 id="Qcache-hits"><a href="#Qcache-hits" class="headerlink" title="Qcache_hits"></a>Qcache_hits</h2><p>Query Cache的命中次数，可以看到QueryCache的基本效果；</p>
<h2 id="Qcache-inserts"><a href="#Qcache-inserts" class="headerlink" title="Qcache_inserts"></a>Qcache_inserts</h2><p>Query Cache未命中然后插入的次数</p>
<p>Query Cache的命中率：</p>
<p>=Qcache_hits/(Qcache_hits+Qcache_inserts)</p>
<h2 id="Qcache-lowmem-prunes"><a href="#Qcache-lowmem-prunes" class="headerlink" title="Qcache_lowmem_prunes"></a>Qcache_lowmem_prunes</h2><p>因为内存不足而被清除出Query Cache的SQL数量。</p>
<p>如果：</p>
<p>Qcache_lowmem_prunes的值正在增加，并且有大量的Qcache_free_blocks，</p>
<p>这意味着碎片导致查询正在被从缓存中永久删除。</p>
<h2 id="Qcache-not-cached"><a href="#Qcache-not-cached" class="headerlink" title="Qcache_not_cached"></a>Qcache_not_cached</h2><p>因为query_cache_type的设置或者不能被cache的select SQL数量</p>
<h2 id="Qcache-queries-in-cache"><a href="#Qcache-queries-in-cache" class="headerlink" title="Qcache_queries_in_cache"></a>Qcache_queries_in_cache</h2><p>Query Cache中cache的select SQL数量</p>
<h2 id="Qcache-total-blocks"><a href="#Qcache-total-blocks" class="headerlink" title="Qcache_total_blocks"></a>Qcache_total_blocks</h2><p>当前Query Cache中block的总数量</p>
<p>Query Cache限制：</p>
<p>a) 5.1.17之前的版本不能Cache帮定变量的Query，但是从5.1.17版本开始，QueryCache已经开</p>
<p>始支持帮定变量的Query了； </p>
<p>b) 所有子查询中的外部查询SQL不能被Cache； </p>
<p>c) 在Procedure，Function以及Trigger中的Query不能被Cache； </p>
<p>d) 包含其他很多每次执行可能得到不一样结果的函数的Query不能被Cache。</p>
<h1 id="进程的使用情况"><a href="#进程的使用情况" class="headerlink" title="进程的使用情况"></a>进程的使用情况</h1><p>在MySQL中，为了尽可能提高客户端请求创建连接这个过程的性能，实现了一个ThreadCache池，</p>
<p>将空闲的连接线程存放在其中，而不是完成请求后就销毁。这样，当有新的连接请求的时候，</p>
<p>MySQL首先会检查ThreadCache池中是否存在空闲连接线程，如果存在则取出来直接使用，</p>
<p>如果没有空闲连接线程，才创建新的连接线程。</p>
<p>参数：thread_cache_size</p>
<p>thread cache 池中存放的最大连接数</p>
<p>调整参考：</p>
<p>在短连接的数据库应用中，数据库连接的创建和销毁是非常频繁的，</p>
<p>如果每次都需要让MySQL新建和销毁相应的连接线程，那么这个资源消耗实际上是非常大的，因此</p>
<p>thread_cache_size的值应该设置的相对大一些，不应该小于应用系统对数据库的实际并发请求数。</p>
<p>参数：thread_stack - 每个连接线程被创建的时候，MySQL给他分配的内存大小，</p>
<p>类似PGA中存放数据的内存部分(不包括排序的空间)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &apos;connections&apos;;</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Connections | 80 | #接受到的来自客户端的总连接数，包括以前和现在的连接。</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">show status like &apos;thread%&apos;;</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br><span class="line"></span><br><span class="line">| Threads_cached | 0 | #当前系统中，缓存的连接数</span><br><span class="line"></span><br><span class="line">| Threads_connected | 1 | #当前系统中正连接的线程数</span><br><span class="line"></span><br><span class="line">| Threads_created | 77 | #创建过的总线程数</span><br><span class="line"></span><br><span class="line">| Threads_running | 1 | </span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br></pre></td></tr></table></figure>
<p>a.如果：</p>
<p>Threads_created 值过大，说明MySQL一直在创建线程，这是比较消耗资源的，应该适当增大</p>
<p>thread_cache_size的值</p>
<p>b.如果：</p>
<p>Threads_cached的值比参数thread_cache_size小太多，则可以适当减小thread_cache_size的值</p>
<p>ThreadCache命中率：</p>
<p>Threads_Cache_Hit=(Connections-Threads_created)/Connections*100%</p>
<p>一般来说，当系统稳定运行一段时间之后，我们的ThreadCache命中率应该保持在90%</p>
<p>左右甚至更高的比率才算正常。</p>
<h1 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h1><p>索引缓存大小，是对MyISAM表性能影响最大的一个参数</p>
<p>32bit平台上，此值不要超过2GB，64bit平台不用做此限制，但也不要超过4GB</p>
<p>根据3点计算：</p>
<p>a.系统索引总大小 </p>
<p>b.系统物理内存 </p>
<p>c.系统当前keycache命中率</p>
<p>粗略计算公式：</p>
<p>Key_Size =key_number*(key_length+4)/0.67 </p>
<p>Max_key_buffer_size&lt;Max_RAM-QCache_Usage-Threads_Usage-System_Usage </p>
<p>Threads_Usage = max_connections * (sort_buffer_size + join_buffer_size + </p>
<p>read_buffer_size+read_rnd_buffer_size+thread_stack)</p>
<p>key_cache_block_size ，是key_buffer缓存块的单位长度，以字节为单位，默认值为1024。</p>
<p>key_cache_division_limit 控制着缓存块重用算法。默认值为100，此值为key_buffer_size中暖链所占的大小百分比(其中有暖链和热链)，100意味着全是暖链。(类似于Oracle Data Buffer Cache中的default、keep、recycle)</p>
<p>key_cache_age_threshold 如果key_buffer里的热链里的某个缓存块在这个变量所设定的时间里没有被访问过，MySQL服务器就会把它调整到暖链里去。这个参数值越大，缓存块在热链里停留的时间就越长。</p>
<p>这个参数默认值为 300，最小值为100。</p>
<p>Myisam索引默认是缓存在原始key_buffer中的，我们可以手动创建新的key_buffer，如在my.cnf中加入参数new_cache.key_buffer_size=20M。指定将table1和table2的索引缓存到new_cache的key_buffer中：</p>
<p>cache index table1,table2 in new_cache;</p>
<p>(之前默认的key_buffer为default，现在手动创建的为new_cache)</p>
<p>手动将table1和table2的索引载入到key_buffer中：</p>
<p>load index into cache table1,table2;</p>
<p>系统中记录的与Key Cache相关的性能状态参数变量： global status </p>
<p>l Key_blocks_not_flushed，已经更改但还未刷新到磁盘的DirtyCacheBlock； </p>
<p>l Key_blocks_unused，目前未被使用的CacheBlock数目； </p>
<p>l Key_blocks_used，已经使用了的CacheBlock数目； </p>
<p>l Key_read_requests，CacheBlock被请求读取的总次数； </p>
<p>l Key_reads，在CacheBlock中找不到需要读取的Key信息后到“.MYI”文件中(磁盘)读取的次数； </p>
<p>l Key_write_requests，CacheBlock被请求修改的总次数； </p>
<p>l Key_writes，在CacheBlock中找不到需要修改的Key信息后到“.MYI”文件中读入再修改的次数；</p>
<p>索引命中缓存率：</p>
<p>key_buffer_read_hits=(1-Key_reads/Key_read_requests)*100% </p>
<p>key_buffer_write_hits=(1-Key_writes/Key_write_requests)*100%</p>
<p>该命中率就代表了MyISAM类型表的索引的cache</p>
<h1 id="排序使用情况："><a href="#排序使用情况：" class="headerlink" title="排序使用情况："></a>排序使用情况：</h1><p>参数 ：sort_buffer_size - 单个thread能用来排序的内存空间大小，系统默认2M</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;sort%&apos;;</span><br><span class="line"></span><br><span class="line">+------------------+---------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+------------------+---------+</span><br><span class="line"></span><br><span class="line">| sort_buffer_size | 2097144 |</span><br><span class="line"></span><br><span class="line">+------------------+---------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show global status like &apos;sort%&apos;;</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br><span class="line"></span><br><span class="line">| Sort_merge_passes | 0 |#在内存中无法完成排序，而在磁盘上创建临时文件的次数(两倍)</span><br><span class="line"></span><br><span class="line">| Sort_range | 0 |#在范围内执行的排序的数量</span><br><span class="line"></span><br><span class="line">| Sort_rows | 0 |#已经排序的行数</span><br><span class="line"></span><br><span class="line">| Sort_scan | 0 |#通过扫描表完成的排序的数量</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br></pre></td></tr></table></figure>


<h1 id="表锁情况"><a href="#表锁情况" class="headerlink" title="表锁情况"></a>表锁情况</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;table%&apos;;</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">| Table_locks_immediate | 96 | # 表示立即释放的表锁数</span><br><span class="line"></span><br><span class="line">| Table_locks_waited | 0 | # 表示需要等待的表锁数</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br></pre></td></tr></table></figure>
<p>如果 Table_locks_immediate / Table_locks_waited &gt; 5000，最好采用InnoDB引擎。</p>
<p>因为InnoDB是行锁而MyISAM是表锁，对于高并发写入的应用InnoDB效果会好些。</p>
<h1 id="表扫描情况"><a href="#表扫描情况" class="headerlink" title="表扫描情况"></a>表扫描情况</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;handler_read%&apos;;</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">| Handler_read_first | 60 |</span><br><span class="line"></span><br><span class="line">| Handler_read_key | 2442 |</span><br><span class="line"></span><br><span class="line">| Handler_read_next | 286 |</span><br><span class="line"></span><br><span class="line">| Handler_read_prev | 0 |</span><br><span class="line"></span><br><span class="line">| Handler_read_rnd | 28 |</span><br><span class="line"></span><br><span class="line">| Handler_read_rnd_next | 3191 |</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show global status like &apos;com_select&apos;;</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Com_select | 23 |</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>
<p>计算表扫描率： </p>
<p>表扫描率 = Handler_read_rnd_next / Com_select </p>
<p>如果：</p>
<p>表扫描率超过4000，说明进行了太多表扫描，很有可能索引没有建好，</p>
<p>增加read_buffer_size值会有一些好处，但最好不要超过8MB。</p>
<h2 id="Handler-read-first"><a href="#Handler-read-first" class="headerlink" title="Handler_read_first"></a>Handler_read_first</h2><p>此选项表明SQL是在做一个全索引扫描(注意是全部，而不是部分)，所以说如果存在WHERE语句，</p>
<p>这个值是不会变的。如果这个值的数值很大，既是好事 也是坏事。</p>
<p>说它好是因为毕竟查询是在索引里完成的，而不是数据文件里，说它坏是因为大数据量时，</p>
<p>即便是索引文件，做一次完整的扫描也是很费时的。</p>
<h2 id="Handler-read-key"><a href="#Handler-read-key" class="headerlink" title="Handler_read_key"></a>Handler_read_key</h2><p>此选项数值如果很高，说明系统高效的使用了索引，一切运转良好</p>
<h1 id="Handler-read-next"><a href="#Handler-read-next" class="headerlink" title="Handler_read_next"></a>Handler_read_next</h1><p>此选项表明在进行索引扫描时，按照索引从数据文件里取数据的次数</p>
<h2 id="Handler-read-prev"><a href="#Handler-read-prev" class="headerlink" title="Handler_read_prev"></a>Handler_read_prev</h2><p>此选项表明在进行索引扫描时，按照索引倒序从数据文件里取数据的次数，</p>
<p>一般就是ORDER BY … DESC。</p>
<h2 id="Handler-read-rnd"><a href="#Handler-read-rnd" class="headerlink" title="Handler_read_rnd"></a>Handler_read_rnd</h2><p>简单的说，就是查询直接操作了数据文件，很多时候表现为没有使用索引或者文件排序</p>
<p>可能是有大量的全表扫描或连接时没恰当使用keys。</p>
<p>The number of requests to read a row based on a fixed position. This value is </p>
<p>high if you are doing a lot of queries that require sorting of the result. You </p>
<p>probably have a lot of queries that require MySQL to scan entire tables or you </p>
<p>have joins that do not use keys properly.</p>
<h2 id="Handler-read-rnd-next"><a href="#Handler-read-rnd-next" class="headerlink" title="Handler_read_rnd_next"></a>Handler_read_rnd_next</h2><p>此选项表明在进行数据文件扫描时，从数据文件里取数据的次数。(物理IO次数)</p>
<h1 id="MySQL内存分配"><a href="#MySQL内存分配" class="headerlink" title="MySQL内存分配"></a>MySQL内存分配</h1><p>mysql服务器为每个连接上的客户端线程，分配的内存空间：</p>
<p>read_buffer_size + read_rnd_buffer_size + sort_buffer_size + </p>
<p>thread_stack + join_buffer_size</p>
<p>从内存的使用方式MySQL 数据库的内存使用主要分为以下两类</p>
<p>· 线程独享内存</p>
<p>· 全局共享内存</p>
<p>先分析 MySQL 中主要的 “线程独享内存” 的。</p>
<p>在 MySQL 中，线程独享内存主要用于各客户端连接线程存储各种操作的独享数据，如线程栈信息，分组排序操作，数据读写缓冲，结果集暂存等等，而且大多数可以通过相关参数来控制内存的使用量。</p>
<p>线程栈信息使用内存(thread_stack)：</p>
<p>主要用来存放每一个线程自身的标识信息，如线程id，线程运行时基本信息等等，我们可以通过 thread_stack 参数来设置为每一个线程栈分配多大的内存。</p>
<p>排序使用内存(sort_buffer_size)：</p>
<p>MySQL 用此内存区域进行排序操作（filesort），完成客户端的排序请求。当我们设置的排序区缓存大小无法满足排序实际所需内存的时候，MySQL 会将数据写入磁盘文件来完成排序。由于磁盘和内存的读写性能完全不在一个数量级，所以sort_buffer_size参数对排序操作的性能影响绝对不可小视。排序操作的实现原理请参考：MySQL Order By 的实现分析(<a href="http://www.kuqin.com/database/20081206/29716.html)。" target="_blank" rel="noopener">http://www.kuqin.com/database/20081206/29716.html)。</a></p>
<p>Join操作使用内存(join_buffer_size)：</p>
<p>应用程序经常会出现一些两表（或多表）Join的操作需求，MySQL在完成某些 Join 需求的时候（all/index join），为了减少参与Join的“被驱动表”的读取次数以提高性能，需要使用到 Join Buffer 来协助完成 Join操作（具体 Join 实现算法请参考：</p>
<p>MySQL 中的 Join 基本实现原理(<a href="http://www.kuqin.com/database/20081206/29717.html)）。当" target="_blank" rel="noopener">http://www.kuqin.com/database/20081206/29717.html)）。当</a> Join Buffer 太小，MySQL 不会将该 Buffer 存入磁盘文件，而是先将Join Buffer中的结果集与需要 Join 的表进行 Join 操作，然后清空 Join Buffer 中的数据，继续将剩余的结果集写入此 Buffer 中，如此往复。这势必会造成被驱动表需要被多次读取，成倍增加 IO 访问，降低效率。</p>
<p>顺序读取数据缓冲区使用内存(read_buffer_size)：</p>
<p>这部分内存主要用于当需要顺序读取数据的时候，如无法使用索引的情况下的全表扫描，全索引扫描等。在这种时候，MySQL 按照数据的存储顺序依次读取数据块，每次读取的数据快首先会暂存在read_buffer_size中，当 buffer 空间被写满或者全部数据读取结束后，再将buffer中的数据返回给上层调用者，以提高效率。</p>
<p>随机读取数据缓冲区使用内存(read_rnd_buffer_size)：</p>
<p>和顺序读取相对应，当 MySQL 进行非顺序读取（随机读取）数据块的时候，会利用这个缓冲区暂存读取的数据。如根据索引信息读取表数据，根据排序后的结果集与表进行Join等等。总的来说，就是当数据块的读取需要满足一定的顺序的情况下，MySQL 就需要产生随机读取，进而使用到 read_rnd_buffer_size 参数所设置的内存缓冲区。</p>
<p>连接信息及返回客户端前结果集暂存使用内存(net_buffer_size)：</p>
<p>这部分用来存放客户端连接线程的连接信息和返回客户端的结果集。当 MySQL 开始产生可以返回的结果集，会在通过网络返回给客户端请求线程之前，会先暂存在通过 net_buffer_size 所设置的缓冲区中，等满足一定大小的时候才开始向客户端发送，以提高网络传输效率。不过，net_buffer_size 参数所设置的仅仅只是该缓存区的初始化大小，MySQL 会根据实际需要自行申请更多的内存以满足需求，但最大不会超过 max_allowed_packet 参数大小。</p>
<p>批量插入暂存使用内存(bulk_insert_buffer_size)：</p>
<p>当我们使用如 insert … values(…),(…),(…)… 的方式进行批量插入的时候，MySQL 会先将提交的数据放如一个缓存空间中，当该缓存空间被写满或者提交完所有数据之后，MySQL 才会一次性将该缓存空间中的数据写入数据库并清空缓存。此外，当我们进行 LOAD DATA INFILE 操作来将文本文件中的数据 Load 进数据库的时候，同样会使用到此缓冲区。</p>
<p>MySQL对硬件的”收益递减点“为256G内存，32CPU。</p>
<h1 id="dalayed-queue-size"><a href="#dalayed-queue-size" class="headerlink" title="dalayed_queue_size"></a>dalayed_queue_size</h1><p>在被插入到实际的数据表里之前，来自insert delayed语句的数据航将在每个队列里等待</p>
<p>MySQL来处理他们。delayed_queue_size就是这个队列所能容纳的数据航的最大个数。当</p>
<p>这个队列满是，后续的insert delayed语句将被阻塞，直到这个队列里有容纳他们的空间</p>
<p>为止。</p>
<p>如果有很多客户在发出insert delayed语句以避免受阻塞，但你发现这些语句有阻塞的迹象，</p>
<p>加大这个变量的值将使更多的insert delayed语句更快地得到处理。</p>
<h1 id="文件打开数-open-files-limit"><a href="#文件打开数-open-files-limit" class="headerlink" title="文件打开数 open_files_limit"></a>文件打开数 open_files_limit</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;open%&apos;;</span><br><span class="line"></span><br><span class="line">+------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+------------------+-------+</span><br><span class="line"></span><br><span class="line">| open_files_limit | 1024 | #mysql总共能够打开的文件的数量</span><br><span class="line"></span><br><span class="line">+------------------+-------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show global status like &apos;open%file%&apos;;</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Open_files | 79 | # 系统当前打开的文件数</span><br><span class="line"></span><br><span class="line">| Opened_files | 278 | # 系统打开过的文件总数</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>
<p>比较合适的设置：Open_files / open_files_limit * 100% &lt;= 75%</p>
]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>为何选择logback+slf4j</title>
    <url>/archives/e2c1fb46.html</url>
    <content><![CDATA[<p>无论从设计上还是实现上，Logback相对log4j而言有了相对多的改进。不过尽管难以一一细数，这里还是列举部分理由为什么选择logback而不是log4j。牢记logback与log4j在概念上面是很相似的，它们都是有同一群开发者建立。所以如果你已经对log4j很熟悉，你也可以很快上手logback。如果你喜欢使用log4j,你也许会迷上使用logback。</p><a id="more"></a>
<ol>
<li>更快的执行速度</li>
</ol>
<p>基于我们先前在log4j上的工作，logback 重写了内部的实现，在某些特定的场景上面，甚至可以比之前的速度快上10倍。在保证logback的组件更加快速的同时，同时所需的内存更加少。</p>
<p>2.更充足的测试</p>
<p>Logback 历经了几年，数不清小时数的测试。尽管log4j也是测试过的，但是Logback的测试更加充分，跟log4j不在同一个级别。我们认为，这正是人们选择Logback而不是log4j的最重要的原因。人们都希望即使在恶劣的条件下，你的日记框架依然稳定而可靠。</p>
<ol start="3">
<li>logback-classic 非常自然的实现了SLF4J</li>
</ol>
<p>logback-classic中的登陆类自然的实现了SLF4J。当你使用 logback-classic作为底层实现时，涉及到LF4J日记系统的问题你完全不需要考虑。更进一步来说，由于 logback-classic强烈建议使用SLF4J作为客户端日记系统实现，如果需要切换到log4j或者其他，你只需要替换一个jar包即可，不需要去改变那些通过SLF4J API 实现的代码。这可以大大减少更换日记系统的工作量。</p>
<ol start="4">
<li>扩展文档</li>
</ol>
<p>Logback附带详细的和不断更新的文档。</p>
<p>5.使用XML配置文件或者Groovy</p>
<p>配置logback的传统方法是通过XML文件。在文档中，大部分例子都是是用XML语法。但是，对于logback版本0.9.22，通过Groovy编写的配置文件也得到支持。相比于XML，Groovy风格的配置文件更加直观，连贯和简短的语法。<br>现在， 已经有一个工具自动把logback.xml文件迁移至logback.groovy。</p>
<p>6.自动重新载入配置文件</p>
<p>Logback-classic可以在配置文件被修改后，自动重新载入。这个扫描过程很快，无资源争用，并且可以动态扩展支持在上百个线程之间每秒上百万个调用。它和应用服务器结合良好，并且在JEE环境通用，因为它不会调用创建一个单独的线程来做扫描。</p>
<p>7.优雅地从I/O错误中恢复</p>
<p>FileAppender和它的子类，包括RollingFileAppender，可以优雅的从I/O错误中恢复。所以，如果一个文件服务器临时宕机，你再也不需要重启你的应用，而日志功能就能正常工作。当文件服务器恢复工作，logback相关的appender就会透明地和快速的从上一个错误中恢复。</p>
<p>8.自动清除旧的日志归档文件</p>
<p>通过设置TimeBasedRollingPolicy 或者 SizeAndTimeBasedFNATP的 maxHistory 属性，你就可以控制日志归档文件的最大数量。如果你的回滚策略是每月回滚的，并且你希望保存一年的日志，那么只需简单的设置maxHistory属性为12。对于12个月之前的归档日志文件将被自动清除。</p>
<ol start="9">
<li>自动压缩归档日志文件</li>
</ol>
<p>RollingFileAppender可以在回滚操作中，自动压缩归档日志文件。压缩通常是异步执行的，所以即使是很大的日志文件，你的应用都不会因此而被阻塞。</p>
<ol start="10">
<li>谨慎模式</li>
</ol>
<p>在谨慎模式中，在多个JVM中运行的多个FileAppender实例，可以安全的写入统一个日志文件。谨慎模式可以在一定的限制条件下应用于RollingFileAppender。</p>
<p>11.Lilith</p>
<p>Lilith是logback的一个记录和访问事件查看器。它相当于log4j的 chainsaw，但是Lilith设计的目的是处理大量的日志记录。</p>
<ol start="12">
<li>配置文件中的条件处理</li>
</ol>
<p>开发者通常需要在不同的目标环境中变换logback的配置文件，例如开发环境，测试环境和生产环境。这些配置文件大体是一样的，除了某部分会有不同。为了避免重复，logback支持配置文件中的条件处理，只需使用<if>,<then>和<else>，那么同一个配置文件就可以在不同的环境中使用了。</else></then></if></p>
<p>13.过滤</p>
<p>Logback拥有远比log4j更丰富的过滤能力。例如，让我们假设，有一个相当重要的商业应用部署在生产环境。考虑到大量的交易数据需要处理，记录级别被设置为WARN，那么只有警告和错误信息才会被记录。现在，想象一下，你在开发环境遇到了一个臭虫，但是在测试平台中却很难发现，因为一些环境之间(生产环境/测试环境)的未知差异。</p>
<p>使用log4j，你只能选择在生产系统中降低记录的级别到DEBUG，来尝试发现问题。但是很不幸，这会生成大量的日志记录，让分析变得困难。更重要的是，多余的日志记录会影响到生产环境的性能。<br>使用logback，你可以选择保留只所有用户的WARN级别的日志，而除了某个用户，例如Alice，而她就是问题的相关用户。当Alice登录系统，她就会以DEBUG级别被记录，而其他用户仍然是以WARN级别来记录日志。这个功能，可以通过在配置文件的XML中添加4行。请在相关章节中查找MDCFilter</p>
<ol start="14">
<li>SiftingAppender</li>
</ol>
<p>SiftingAppender是一个全能的追加器。它可以基于任何给定的实时属性分开（或者筛选）日志。例如，SiftingAppender可以基于用户会话分开日志事件，这样，可以为每一个用户建立一个独立的日志文件。</p>
<p>15.Logback-access模块，提供了通过HTTP访问日志的能力，是logback不可或缺的组成部分</p>
<p>最后但绝非最不重要的是，作为logback发布包的一部分，logback-access模块可与Jetty或者Tomcat进行集成，提供了非常丰富而强大的通过HTTP访问日志的功能。因为logback-access模块是logback初期设计方案中的一部分，因此，所有你所喜欢的logback-classic模块所提供的全部特性logback-access同样也具备。</p>
<p>以上网络整理的内容————————————————————–<br>下面是我编写的一个demo配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration scan=&quot;false&quot; debug=&quot;false&quot;&gt;  </span><br><span class="line">  	&lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;mm:ss&#125; %-5level %logger&#123;36&#125; &gt;&gt;&gt; %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;appender name=&quot;DEBUG_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    	&lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;  </span><br><span class="line">            &lt;level&gt;DEBUG&lt;/level&gt;</span><br><span class="line">            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;  </span><br><span class="line">    		&lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">        &lt;/filter&gt; </span><br><span class="line">	    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">	      &lt;!-- daily rollover --&gt;</span><br><span class="line">	      &lt;fileNamePattern&gt;logs/debug.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">	</span><br><span class="line">	      &lt;!-- keep 30 days&apos; worth of history capped at 3GB total size --&gt;</span><br><span class="line">	      &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">	      &lt;totalSizeCap&gt;3GB&lt;/totalSizeCap&gt;</span><br><span class="line">	    &lt;/rollingPolicy&gt;</span><br><span class="line">	    &lt;encoder&gt;</span><br><span class="line">	      &lt;pattern&gt;%d [%thread] [%-5level] %file,%line - %msg%n&lt;/pattern&gt;</span><br><span class="line">	    &lt;/encoder&gt; </span><br><span class="line">    &lt;/appender&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;appender name=&quot;WARN_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    	&lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;  </span><br><span class="line">            &lt;level&gt;WARN&lt;/level&gt;</span><br><span class="line">        &lt;/filter&gt; </span><br><span class="line">	    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">	      &lt;!-- daily rollover --&gt;</span><br><span class="line">	      &lt;fileNamePattern&gt;logs/warn.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">	</span><br><span class="line">	      &lt;!-- keep 30 days&apos; worth of history capped at 3GB total size --&gt;</span><br><span class="line">	      &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">	      &lt;totalSizeCap&gt;3GB&lt;/totalSizeCap&gt;</span><br><span class="line">	    &lt;/rollingPolicy&gt;</span><br><span class="line">	    &lt;encoder&gt;</span><br><span class="line">	      &lt;pattern&gt;%d [%thread] [%-5level] %file,%line - %msg%n&lt;/pattern&gt;</span><br><span class="line">	    &lt;/encoder&gt; </span><br><span class="line">    &lt;/appender&gt; </span><br><span class="line">  </span><br><span class="line">    &lt;root level=&quot;DEBUG&quot;&gt;  </span><br><span class="line">        &lt;appender-ref ref=&quot;DEBUG_FILE&quot; /&gt;  </span><br><span class="line">        &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt;  </span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">    &lt;/root&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestA &#123;</span><br><span class="line">	static Logger log = LoggerFactory.getLogger(TestB.class);</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		log.trace(&quot;======trace&quot;);  </span><br><span class="line">		log.debug(&quot;======debug&quot;);  </span><br><span class="line">		log.info(&quot;======info&quot;);  </span><br><span class="line">		log.warn(&quot;======warn&quot;);  </span><br><span class="line">		log.error(&quot;======error&quot;); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<p><img src="/images/loading.png" data-original="/images/pasted-1.png" alt="upload successful"></p>
<p>日志记录情况:</p>
<p><img src="/images/loading.png" data-original="/images/pasted-2.png" alt="upload successful"></p>
<p>demo每天一个新日志文件,历史数据保留最大30天.日志总占数据量大于3G自动异步删除旧日志</p>
<p>根节点<code>&lt;configuration&gt;</code>包含的属性：</p>
<p>scan:</p>
<p>当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</p>
<p>scanPeriod:</p>
<p>设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</p>
<p>debug:</p>
<p>当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</p>
<p><code>&lt;level&gt;</code>:设置过滤级别</p>
<p><code>&lt;onMatch&gt;</code>:用于配置符合过滤条件的操作</p>
<p><code>&lt;onMismatch&gt;</code>:用于配置不符合过滤条件的操作</p>
<p>Logback的过滤器基于三值逻辑（ternary logic），允许把它们组装或成链，从而组成任意的复合过滤策略。过滤器很大程度上受到Linux的iptables启发。这里的所谓三值逻辑是说，过滤器的返回值只能是ACCEPT、DENY和NEUTRAL的其中一个。</p>
<p>如果返回DENY，那么记录事件立即被抛弃，不再经过剩余过滤器；</p>
<p>如果返回NEUTRAL，那么有序列表里的下一个过滤器会接着处理记录事件；</p>
<p>如果返回ACCEPT，那么记录事件被立即处理，不再经过剩余过滤器。</p>
<p><code>&lt;maxHistory&gt;</code>:<br>可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每个月滚动，且<maxhistory>是6，则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除。</maxhistory></p>
<p>独立的日志标签</p>
<p><code>&lt;logger name=&quot;monitor&quot; additivity=&quot;false&quot; level=&quot;INFO&quot;&gt;</code></p>
<p>这里通过设置additivity=”false”禁止monitor里的内容向上传递，否则会同时显示在默认的日志中。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>slf4j</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo学习记录</title>
    <url>/archives/33b13b3d.html</url>
    <content><![CDATA[<h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><p>分布式计算，远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。</p><a id="more"></a>
<p>如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，例：Java RMI。</p>
<p>RPC是一种进程间通信的模式，程序分布在不同的地址空间里。如果在同一主机里，RPC可以通过不同的虚拟地址空间（即便使用相同的物理地址）进行通讯，而在不同的主机间，则通过不同的物理进行交互。许多技术（常常是不兼容）都是基于这种概念而实现的。</p>
<h2 id="RPC实现原理"><a href="#RPC实现原理" class="headerlink" title="RPC实现原理"></a>RPC实现原理</h2><p>首先需要有处理网络连接通讯的模块，负责连接建立、管理和消息的传输。其次需要有编<br>解码的模块，因为网络通讯都是传输的字节码，需要将我们使用的对象序列化和反序列<br>化。剩下的就是客户端和服务器端的部分，服务器端暴露要开放的服务接口，客户调用服<br>务接口的一个代理实现，这个代理实现负责收集数据、编码并传输给服务器然后等待结果<br>返回。</p>
<h2 id="Dubbo的实现原理"><a href="#Dubbo的实现原理" class="headerlink" title="Dubbo的实现原理"></a>Dubbo的实现原理</h2><p>dubbo 作为 rpc 框架，实现的效果就是调用远程的方法就像在本地调用一样。如何做到<br>呢？就是本地有对远程方法的描述，包括方法名、参数、返回值，在 dubbo 中是远程和本<br>地使用同样的接口；然后呢，要有对网络通信的封装，要对调用方来说通信细节是完全不<br>可见的，网络通信要做的就是将调用方法的属性通过一定的协议（简单来说就是消息格<br>式）传递到服务端；服务端按照协议解析出调用的信息；执行相应的方法；在将方法的返<br>回值通过协议传递给客户端；客户端再解析；在调用方式上又可以分为同步调用和异步调<br>用；简单来说基本就这个过程</p>
<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>快速生成Maven archetype模板</title>
    <url>/archives/e0f55110.html</url>
    <content><![CDATA[<h2 id="快捷生成archetype方便修改"><a href="#快捷生成archetype方便修改" class="headerlink" title="快捷生成archetype方便修改"></a>快捷生成archetype方便修改</h2><p>mvn archetype:create-from-project -Darchetype.filteredExtensions=java -DpackageName=com.pearlgo -DartifactId=ec-template</p><a id="more"></a>
<h3 id="上传archetype到私服"><a href="#上传archetype到私服" class="headerlink" title="上传archetype到私服"></a>上传archetype到私服</h3><p>添加配置pom配置,是配置到archetype的pom</p>
<!-- 配置部署的远程仓库 -->
<p> <code>&lt;distributionManagement&gt;
  &lt;snapshotRepository&gt;
   &lt;id&gt;nexus-snapshots&lt;/id&gt;
   &lt;name&gt;nexus distribution snapshot repository&lt;/name&gt;
   &lt;url&gt;xxxx私服snapshots地址&lt;/url&gt;
  &lt;/snapshotRepository&gt;
  &lt;repository&gt;
   &lt;id&gt;nexus-releases&lt;/id&gt;
   &lt;name&gt;Nexus Release Repository&lt;/name&gt;
   &lt;url&gt;xxxx私服release地址&lt;/url&gt;
  &lt;/repository&gt;
 &lt;/distributionManagement&gt;</code></p>
<h2 id="执行上传-用IDEA可以直接用快捷方法无需用命令"><a href="#执行上传-用IDEA可以直接用快捷方法无需用命令" class="headerlink" title="执行上传,用IDEA可以直接用快捷方法无需用命令"></a>执行上传,用IDEA可以直接用快捷方法无需用命令</h2><p>mvn clean deploy</p>
]]></content>
      <categories>
        <category>archetype</category>
        <category>maven</category>
      </categories>
      <tags>
        <tag>archetype</tag>
        <tag>maven</tag>
        <tag>快捷</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作</title>
    <url>/archives/7a00f2af.html</url>
    <content><![CDATA[<h3 id="找到根目录下所有的以test开头的文件并把查找结果当做参数传给rm-rf命令进行删除："><a href="#找到根目录下所有的以test开头的文件并把查找结果当做参数传给rm-rf命令进行删除：" class="headerlink" title="找到根目录下所有的以test开头的文件并把查找结果当做参数传给rm -rf命令进行删除："></a>找到根目录下所有的以test开头的文件并把查找结果当做参数传给rm -rf命令进行删除：</h3><p>1、find / -name “test<em>” |xargs rm -rf<br>2、find / -name “test</em>” -exec rm -rf {} ;<br>3、rm -rf $(find / -name “test”)</p><a id="more"></a>
<h3 id="如果想指定递归深度，可以这样："><a href="#如果想指定递归深度，可以这样：" class="headerlink" title="如果想指定递归深度，可以这样："></a>如果想指定递归深度，可以这样：</h3><p>1、find / -maxdepth 3 -name “<em>.mp3” |xargs rm -rf<br>2、find / -maxdepth 3 -name “test</em>” -exec rm -rf {} ;<br>3、rm -rf $(find / -maxdepth 3 -name “test”)<br>这样只会查找三层目录中符合条件的文件并删除掉！ </p>
<h3 id="使用特定用户重启"><a href="#使用特定用户重启" class="headerlink" title="使用特定用户重启"></a>使用特定用户重启</h3><p>sudo -u apprunner bash ./start.sh restart</p>
<p>sudo -u apprunner /usr/local/java/jdk1.8.0_152/bin</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>ps aux –sort -rss|grep java</p>
<h4 id="线程数等数据"><a href="#线程数等数据" class="headerlink" title="线程数等数据"></a>线程数等数据</h4><p>cat /proc/PID/status</p>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>tar -czvf 文件名 要打包内容</p>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>tar -xzvf file.tar.gz</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>zcat vsftpd.tar.gz|grep –binary-files=text ‘footbar.js’或<br>zgrep –binary-files=text ‘footbar.js’ vsftpd.tar.gz</p>
<p>sudo rz -y 覆盖文件<br>sudo unzip -o<br>sudo cp -rf<br>chmod +x *.sh</p>
<p>df -lh 磁盘大小</p>
<p>du -h –max-depth=1 文件夹大小</p>
<p>sudo scp -P 58880  ./dwc-pj.tar.gz <a href="mailto:dwc-lyp@112.74.140.11" target="_blank" rel="noopener">dwc-lyp@112.74.140.11</a>:/data/project/dwc</p>
<p>jmap -histo:live 15441|less</p>
<p>netstat -nap|grep 120.24.166.239:6379</p>
<p>nohup java …. &gt; xx.txt &amp;</p>
<p>jps</p>
<p>功能</p>
<p>显示当前所有java进程pid的命令。</p>
<p>常用指令</p>
<p>jps：显示当前用户的所有java进程的PID<br>jps -v 3331：显示虚拟机参数<br>jps -m 3331：显示传递给main()函数的参数<br>jps -l 3331：显示主类的全路径<br>详细介绍</p>
<p>jinfo</p>
<p>功能</p>
<p>实时查看和调整虚拟机参数，可以显示未被显示指定的参数的默认值（jps -v 则不能）。</p>
<p>jdk8中已经不支持该命令。</p>
<p>常用指令</p>
<p>jinfo -flag CMSIniniatingOccupancyFration 1444：查询CMSIniniatingOccupancyFration参数值</p>
<p>详细介绍</p>
<p>jstat</p>
<p>功能</p>
<p>显示进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<p>常用指令</p>
<p>jstat -gc 3331 250 20 ：查询进程2764的垃圾收集情况，每250毫秒查询一次，一共查询20次。<br>jstat -gccause：额外输出上次GC原因<br>jstat -calss：件事类装载、类卸载、总空间以及所消耗的时间<br>详细介绍</p>
<p>jmap</p>
<p>功能</p>
<p>生成堆转储快照（heapdump）</p>
<p>常用指令</p>
<p>jmap -heap 3331：查看java 堆（heap）使用情况<br>jmap -histo 3331：查看堆内存(histogram)中的对象数量及大小<br>jmap -histo:live 3331：JVM会先触发gc，然后再统计信息<br>jmap -dump:format=b,file=heapDump 3331：将内存使用的详细情况输出到文件，之后一般使用其他工具进行分析。<br>详细介绍</p>
<p>jhat</p>
<p>功能</p>
<p>一般与jmap搭配使用，用来分析jmap生成的堆转储文件。</p>
<p>由于有很多可视化工具（Eclipse Memory Analyzer 、IBM HeapAnalyzer）可以替代，所以很少用。不过在没有可视化工具的机器上也是可用的。</p>
<p>常用指令</p>
<p>jmap -dump:format=b,file=heapDump 3331 + jhat heapDump：解析Java堆转储文件,并启动一个 web server</p>
<p>详细介绍</p>
<p>jstack</p>
<p>功能</p>
<p>生成当前时刻的线程快照。</p>
<p>常用指令</p>
<p>jstack 3331：查看线程情况<br>jstack -F 3331：正常输出不被响应时，使用该指令<br>jstack -l 3331：除堆栈外，显示关于锁的附件信息<br>详细介绍</p>
<p>常见问题定位过程</p>
<p>频繁GC问题或内存溢出问题</p>
<p>一、使用jps查看线程ID</p>
<p>二、使用jstat -gc 3331 250 20 查看gc情况，一般比较关注PERM区的情况，查看GC的增长情况。</p>
<p>三、使用jstat -gccause：额外输出上次GC原因</p>
<p>四、使用jmap -dump:format=b,file=heapDump 3331生成堆转储文件</p>
<p>五、使用jhat或者可视化工具（Eclipse Memory Analyzer 、IBM HeapAnalyzer）分析堆情况。</p>
<p>六、结合代码解决内存溢出或泄露问题。</p>
<p>死锁问题</p>
<p>一、使用jps查看线程ID</p>
<p>二、使用jstack 3331：查看线程情况</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA常用快捷键</title>
    <url>/archives/566321e7.html</url>
    <content><![CDATA[<h2 id="记录原因"><a href="#记录原因" class="headerlink" title="记录原因"></a>记录原因</h2><p>因为经常忘记快捷键,所以写一遍记录常用快捷键的博客,方便忘记的时候可以快速查找,不用到处翻。</p>
<a id="more"></a>
<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><p>Ctrl+Shift + Enter，语句完成<br>“！”，否定完成，输入表达式时按 “！”键<br>Ctrl+E，最近的文件<br>Ctrl+Shift+E，最近更改的文件<br>Shift+Click，可以关闭文件<br>Ctrl+[ OR ]，可以跑到大括号的开头与结尾<br>Ctrl+F12，可以显示当前文件的结构<br>Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择<br>Ctrl+N，可以快速打开类<br>Ctrl+Shift+N，可以快速打开文件<br>Alt+Q，可以看到当前方法的声明<br>Ctrl+P，可以显示参数信息<br>Ctrl+Shift+Insert，可以选择剪贴板内容并插入<br>Alt+Insert，可以生成构造器/Getter/Setter等<br>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义<br>Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch<br>Ctrl+Enter，导入包，自动修正<br>Ctrl+Alt+L，格式化代码<br>Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作<br>Ctrl+Alt+O，优化导入的类和包<br>Ctrl+R，替换文本<br>Ctrl+F，查找文本<br>Ctrl+Shift+Space，自动补全代码<br>Ctrl+空格，代码提示（与系统输入法快捷键冲突）<br>Ctrl+Shift+Alt+N，查找类中的方法或变量<br>Alt+Shift+C，最近的更改<br>Alt+Shift+Up/Down，上/下移一行<br>Shift+F6，重构 – 重命名<br>Ctrl+X，删除行<br>Ctrl+D，复制行<br>Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）<br>Ctrl+J，自动代码（例如：serr）<br>Ctrl+Alt+J，用动态模板环绕<br>Ctrl+H，显示类结构图（类的继承层次）<br>Ctrl+Q，显示注释文档<br>Alt+F1，查找代码所在位置<br>Alt+1，快速打开或隐藏工程面板<br>Ctrl+Alt+left/right，返回至上次浏览的位置<br>Alt+left/right，切换代码视图<br>Alt+Up/Down，在方法间快速移动定位<br>Ctrl+Shift+Up/Down，向上/下移动语句<br>F2 或 Shift+F2，高亮错误或警告快速定位<br>Tab，代码标签输入完成后，按 Tab，生成代码<br>Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失<br>Alt+F3，逐个往下查找相同文本，并高亮显示<br>Ctrl+Up/Down，光标中转到第一行或最后一行下<br>Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）<br>Ctrl+Alt+B，跳转到方法实现处<br>Ctrl+Shift+Backspace，跳转到上次编辑的地方<br>Ctrl+O，重写方法<br>Ctrl+Alt+Space，类名自动完成<br>Ctrl+Alt+Up/Down，快速跳转搜索结果<br>Ctrl+Shift+J，整合两行<br>Alt+F8，计算变量值<br>Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本<br>Ctrl+Alt+Shift+V，简单粘贴<br>Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口<br>F12，把焦点从编辑器移到最近使用的工具窗口<br>Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器<br>Ctrl+W，可以选择单词继而语句继而行继而函数<br>Ctrl+Shift+W，取消选择光标所在词<br>Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置<br>Ctrl+I，实现方法<br>Ctrl+Shift+U，大小写转化<br>Ctrl+Y，删除当前行<br>Shift+Enter，向下插入新行<br>psvm/sout，main/System.out.println(); Ctrl+J，查看更多<br>Ctrl+Shift+F，全局查找<br>Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找<br>Ctrl+Shift+S，高级搜索<br>Ctrl+U，转到父类<br>Ctrl+Alt+S，打开设置对话框<br>Alt+Shift+Inert，开启/关闭列选择模式<br>Ctrl+Alt+Shift+S，打开当前项目/模块属性<br>Ctrl+G，定位行<br>Alt+Home，跳转到导航栏<br>Ctrl+Enter，上插一行<br>Ctrl+Backspace，按单词删除<br>Ctrl+”+/-”，当前方法展开、折叠<br>Ctrl+Shift+”+/-”，全部展开、折叠</p>
<h2 id="【调试部分、编译】"><a href="#【调试部分、编译】" class="headerlink" title="【调试部分、编译】"></a>【调试部分、编译】</h2><p>Ctrl+F2，停止<br>Alt+Shift+F9，选择 Debug<br>Alt+Shift+F10，选择 Run<br>Ctrl+Shift+F9，编译<br>Ctrl+Shift+F10，运行<br>Ctrl+Shift+F8，查看断点<br>F8，步过<br>F7，步入<br>Shift+F7，智能步入<br>Shift+F8，步出<br>Alt+Shift+F8，强制步过<br>Alt+Shift+F7，强制步入<br>Alt+F9，运行至光标处<br>Ctrl+Alt+F9，强制运行至光标处<br>F9，恢复程序<br>Alt+F10，定位到断点<br>Ctrl+F8，切换行断点<br>Ctrl+F9，生成项目<br>Alt+1，项目<br>Alt+2，收藏<br>Alt+6，TODO<br>Alt+7，结构<br>Ctrl+Shift+C，复制路径<br>Ctrl+Alt+Shift+C，复制引用，必须选择类名<br>Ctrl+Alt+Y，同步<br>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）<br>Shift+F12，还原默认布局<br>Ctrl+Shift+F12，隐藏/恢复所有窗口<br>Ctrl+F4，关闭<br>Ctrl+Shift+F4，关闭活动选项卡<br>Ctrl+Tab，转到下一个拆分器<br>Ctrl+Shift+Tab，转到上一个拆分器</p>
<h2 id="【重构】"><a href="#【重构】" class="headerlink" title="【重构】"></a>【重构】</h2><p>Ctrl+Alt+Shift+T，弹出重构菜单<br>Shift+F6，重命名<br>F6，移动<br>F5，复制<br>Alt+Delete，安全删除<br>Ctrl+Alt+N，内联</p>
<h2 id="【查找】"><a href="#【查找】" class="headerlink" title="【查找】"></a>【查找】</h2><p>Ctrl+F，查找<br>Ctrl+R，替换<br>F3，查找下一个<br>Shift+F3，查找上一个<br>Ctrl+Shift+F，在路径中查找<br>Ctrl+Shift+R，在路径中替换<br>Ctrl+Shift+S，搜索结构<br>Ctrl+Shift+M，替换结构<br>Alt+F7，查找用法<br>Ctrl+Alt+F7，显示用法<br>Ctrl+F7，在文件中查找用法<br>Ctrl+Shift+F7，在文件中高亮显示用法</p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/archives/8979b4c0.html</url>
    <content><![CDATA[<h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p><p>示例：</p><p><code># 这是一级标题</code><br><br><code>## 这是二级标题</code><br><br><code>### 这是三级标题</code><br><br><code>#### 这是四级标题</code><br><br><code>##### 这是五级标题</code><br><br><code>###### 这是六级标题</code><br><br>效果如下：</p><a id="more"></a>



<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h2 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h2><p>加粗<br>要加粗的文字左右分别用两个*号包起来</p>
<p>斜体<br>要倾斜的文字左右分别用一个*号包起来</p>
<p>斜体加粗<br>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<p>删除线<br>要加删除线的文字左右分别用两个~~号包起来</p>
<p>示例：</p>
<p><code>**这是加粗的文字**</code><br><br><code>*这是倾斜的文字*``&lt;br&gt;</code><strong><em>这是斜体加粗的文字</em></strong><code>&lt;br&gt;</code><del>这是加删除线的文字</del>`<br><br>效果如下：</p>
<p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p>
<h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…<br>貌似可以一直加下去，但没神马卵用</p>
<p>示例：</p>
<p><code>&gt;这是引用的内容</code><br><br><code>&gt;&gt;这是引用的内容</code><br><br><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</code><br><br>效果如下：</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><p>三个或者三个以上的 - 或者 * 都可以。</p>
<p>示例：</p>
<p><code>---</code><br><br><code>----</code><br><br><code>***</code><br><br><code>*****</code><br><br>效果如下：<br>可以看到，显示效果是一样的。</p>
<hr>
<hr>
<hr>
<hr>
<h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><p>语法：</p>
<p><code>![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</code></p>
<p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加<br>示例：</p>
<p>![blockchain](<a href="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/" target="_blank" rel="noopener">https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</a><br>u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”)<br>效果如下：</p>
<p>blockchain<br>上传本地图片直接点击导航栏的图片标志，选择图片即可</p>
<h2 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h2><p>语法：</p>
<p><a href="超链接地址" title="超链接title">超链接名</a><br>title可加可不加<br>示例：</p>
<p><code>[简书](http://jianshu.com)</code><br><br><code>[百度](http://baidu.com)</code><br><br>效果如下：</p>
<p><a href="http://jianshu.com" target="_blank" rel="noopener">简书</a><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p>
<p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p>
<p><code>&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;</code></p>
<p>示例<br><a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank">简书</a></p>
<h2 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h2><p>无序列表</p>
<h4 id="语法：无序列表用-任何一种都可以"><a href="#语法：无序列表用-任何一种都可以" class="headerlink" title="语法：无序列表用 - + * 任何一种都可以"></a>语法：无序列表用 - + * 任何一种都可以</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br></pre></td></tr></table></figure>
<p>注意：- + * 跟内容之间都要有一个空格</p>
<p>效果如下：</p>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<p>语法：数字加点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br></pre></td></tr></table></figure>
<p>注意：序号跟内容之间要有空格<br>效果如下：</p>
<p>1.列表内容<br>2.列表内容<br>3.列表内容</p>
<p>列表嵌套<br>上一级和下一级之间敲三个空格即可</p>
<p>一级无序列表内容<br>   二级无序列表内容<br>   二级无序列表内容<br>   二级无序列表内容<br>一级无序列表内容<br>   二级有序列表内容<br>   二级有序列表内容<br>   二级有序列表内容<br>一级有序列表内容<br>   二级无序列表内容<br>   二级无序列表内容<br>   二级无序列表内容<br>一级有序列表内容<br>   二级有序列表内容<br>   二级有序列表内容<br>   二级有序列表内容</p>
<h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br></pre></td></tr></table></figure>
<p>第二行分割表头和内容。</p>
<ul>
<li>有一个就行，为了对齐，多加了几个<br>文字默认居左</li>
<li>两边加：表示文字居中</li>
<li>右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略<br>示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure>
效果如下：</li>
</ul>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
<tr>
<td>## 九、代码</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td>语法：</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td>单行代码：代码之间分别用一个反引号包起来</td>
<td align="center"></td>
<td align="right"></td>
</tr>
</tbody></table>
<pre><code>`代码内容`</code></pre><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(```)---去掉括号</span><br><span class="line"> 代码...</span><br><span class="line"> 代码...</span><br><span class="line"> 代码...</span><br><span class="line">(```)---去掉括号</span><br></pre></td></tr></table></figure>
<p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p>
<p>示例：</p>
<p>单行代码</p>
<p><code>create database hero;</code><br>代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">     echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p>单行代码</p>
<p><code>create database hero;</code></p>
<p>代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">  echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>
<h2 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
</search>
