<!DOCTYPE html><html class="theme-next muse use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="I Tell You Code"><meta name="description" content="java基础：1.HashMap的数据结构是什么？JDK版本 实现方式 节点数&amp;gt;=8 节点数&amp;lt;=61.8以前 数组+单向链表 数组+单向链表 数组+单向链表1.8以后 数组+单向链表+红黑树 数组+红黑树 数组+单向链表寻址算法优化(n - 1) &amp;amp; hash -&amp;gt; 数组里的一个位置 2、HashSet 是如何保证不重复的底层维护了一个HashMap 3、HashMap"><meta property="og:type" content="article"><meta property="og:title" content="面试经"><meta property="og:url" content="http:&#x2F;&#x2F;blog.iamlzz.cn&#x2F;archives&#x2F;4048efa0.html"><meta property="og:site_name" content="I Tell You Code"><meta property="og:description" content="java基础：1.HashMap的数据结构是什么？JDK版本 实现方式 节点数&amp;gt;=8 节点数&amp;lt;=61.8以前 数组+单向链表 数组+单向链表 数组+单向链表1.8以后 数组+单向链表+红黑树 数组+红黑树 数组+单向链表寻址算法优化(n - 1) &amp;amp; hash -&amp;gt; 数组里的一个位置 2、HashSet 是如何保证不重复的底层维护了一个HashMap 3、HashMap"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http:&#x2F;&#x2F;blog.iamlzz.cn&#x2F;images&#x2F;loading.png"><meta property="og:updated_time" content="2020-03-02T09:39:04.225Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http:&#x2F;&#x2F;blog.iamlzz.cn&#x2F;images&#x2F;loading.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.iamlzz.cn/archives/4048efa0.html"><title>面试经 | I Tell You Code</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?044a54c39f1f23e8ae637a69263df4d3";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">I Tell You Code</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> Home</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> Archives</a></li><li class="menu-item menu-item-search"><a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> Search</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.iamlzz.cn/archives/4048efa0.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="LZZ"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="I Tell You Code"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">面试经</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-22T15:25:00+08:00">2020-02-22</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="java基础："><a href="#java基础：" class="headerlink" title="java基础："></a>java基础：</h2><h3 id="1-HashMap的数据结构是什么？"><a href="#1-HashMap的数据结构是什么？" class="headerlink" title="1.HashMap的数据结构是什么？"></a>1.HashMap的数据结构是什么？</h3><p>JDK版本 实现方式 节点数&gt;=8 节点数&lt;=6<br>1.8以前 数组+单向链表 数组+单向链表 数组+单向链表<br>1.8以后 数组+单向链表+红黑树 数组+红黑树 数组+单向链表<br>寻址算法优化<br>(n - 1) &amp; hash -&gt; 数组里的一个位置</p><h3 id="2、HashSet-是如何保证不重复的"><a href="#2、HashSet-是如何保证不重复的" class="headerlink" title="2、HashSet 是如何保证不重复的"></a>2、HashSet 是如何保证不重复的</h3><p>底层维护了一个HashMap</p><h3 id="3、HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）"><a href="#3、HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）" class="headerlink" title="3、HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?"></a>3、HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?</h3><p>线程不安全</p><h3 id="4、HashMap-的扩容过程"><a href="#4、HashMap-的扩容过程" class="headerlink" title="4、HashMap 的扩容过程"></a>4、HashMap 的扩容过程</h3><p>初始长度是16，并且每次扩展时候，长度必须是2的幂。因为2的幂-1对应的二进制末尾总是是1111，这样，和key.hash做“与”运算的时候，只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。</p><h3 id="5、HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？"><a href="#5、HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？" class="headerlink" title="5、HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？"></a>5、HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？</h3><p>JDK版本 实现方式 节点数&gt;=8 节点数&lt;=6<br>1.8以前 数组+单向链表 数组+单向链表 数组+单向链表<br>1.8以后 数组+单向链表+红黑树 数组+红黑树 数组+单向链表<br>寻址算法优化<br>(n - 1) &amp; hash -&gt; 数组里的一个位置</p><h3 id="6、final-finally-finalize"><a href="#6、final-finally-finalize" class="headerlink" title="6、final finally finalize"></a>6、final finally finalize</h3><p>final用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。<br>finally是异常处理语句结构的一部分，表示总是执行。<br>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。</p><h3 id="7、强引用-、软引用、-弱引用、虚引用"><a href="#7、强引用-、软引用、-弱引用、虚引用" class="headerlink" title="7、强引用 、软引用、 弱引用、虚引用"></a>7、强引用 、软引用、 弱引用、虚引用</h3><p>强引用（Strong Reference）：通常我们通过new来创建一个新对象时返回的引用就是一个强引用，若一个对象通过一系列强引用可到达，它就是强可达的(strongly reachable)，那么它就不被回收；<br>软引用（Soft Reference）：软引用和弱引用的区别在于，若一个对象是弱引用可达，无论当前内存是否充足它都会被回收，而软引用可达的对象在内存不充足时才会被回收，因此软引用要比弱引用“强”一些；<br>弱引用（Weak Reference）：弱引用简单来说就是将对象留在内存的能力不是那么强的引用。使用Weak Reference，垃圾回收器会帮你来决定引用的对象何时回收并且将对象从内存移除。ThreadLocal的key使用了弱引用。<br>虚引用（Phantom Reference）：虚引用是Java中最弱的引用，那么它弱到什么程度呢？它是如此脆弱以至于我们通过虚引用甚至无法获取到被引用的对象，虚引用存在的唯一作用就是当它指向的对象被回收后，虚引用本身会被加入到引用队列中，用作记录它指向的对象已被回收。</p><h3 id="8、Java反射的实现原理"><a href="#8、Java反射的实现原理" class="headerlink" title="8、Java反射的实现原理"></a>8、Java反射的实现原理</h3><p>反射:(reflection):在运行时期,动态地去获取类中的信息(类的信息,方法信息,构造器信息,字段等信息进行操作);<br>一个类中包含的信息有： 构造器，字段，方法<br>如何使用反射描述这些相关的信息<br>Class ： 描述类<br>Method ： 描述方法<br>Constructor ：描述构造器<br>Field ：描述字段</p><h3 id="9、Arrays-sort-实现原理和-Collections-实现原理"><a href="#9、Arrays-sort-实现原理和-Collections-实现原理" class="headerlink" title="9、Arrays.sort 实现原理和 Collections 实现原理"></a>9、Arrays.sort 实现原理和 Collections 实现原理</h3><p>事实上Collections.sort方法底层就是调用的array.sort方法，而且不论是Collections.sort或者是Arrays.sort方法，<br>不论是Collections.sort方法或者是Arrays.sort方法，底层实现都是TimSort实现的，这是jdk1.7新增的，以前是归并排序。TimSort算法就是找到已经排好序数据的子序列，然后对剩余部分排序，然后合并起来</p><h3 id="10、LinkedHashMap的应用"><a href="#10、LinkedHashMap的应用" class="headerlink" title="10、LinkedHashMap的应用"></a>10、LinkedHashMap的应用</h3><p>LinkedHashMap是HashMap的子类，但是内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于双向链表中。LinkedHashMap支持两种顺序插入顺序 、 访问顺序</p><p>插入顺序：先添加的在前面，后添加的在后面。修改操作不影响顺序<br>访问顺序：所谓访问指的是get/put操作，对一个键执行get/put操作后，其对应的键值对会移动到链表末尾，所以最末尾的是最近访问的，最开始的是最久没有被访问的，这就是访问顺序。</p><p>可以设置访问顺序用做JVM LRU缓存</p><h3 id="11、cloneable接口实现原理"><a href="#11、cloneable接口实现原理" class="headerlink" title="11、cloneable接口实现原理"></a>11、cloneable接口实现原理</h3><p>Cloneable是一个标记接口，里面没有任何的方法。<br>java的一个类，如果要使用Cloneable实现拷贝功能，需要先实现这个接口，然后重写Object的clone方法。对于类中的引用类型的属性，需要在clone方法中实现深拷贝，否则就是浅拷贝。</p><h3 id="12、异常分类以及处理机制"><a href="#12、异常分类以及处理机制" class="headerlink" title="12、异常分类以及处理机制"></a>12、异常分类以及处理机制</h3><p>异常的分类：<br>　Throwable是根接口。<br>　Error和Exception继承这个接口 。<br>　　Error是无法处理的异常，比如OutOfMemoryError，一般发生这种异常，JVM会选择终止程序。因此我们编写程序时不需要关心这类异常。<br>　　Exception，也就是我们经常见到的一些异常情况，这些异常是我们可以处理的异常，是所有异常类的父类。<br>　　RuntimeException和checked exception(受査异常也称非运行时异常)继承Exception<br>　　 unchecked Exception(非受査异常)，包括Error和RuntimeException，比如常见的NullPointerException、IndexOutOfBoundsException。对于RuntimeException，java编译器不要求必须进行异常捕获处理或者抛出 声明，由程序员自行决定。<br>　　checked exception（受查异常），也称非运行时异常（运行时异常以外的异常就是非运行时异常），由代 码能力之外的因素导致的运行时错误。java编译器强制程序员必须进行捕获处理，比如常见的有IOExeption 和SQLException。如果不进行捕获或者抛出声明处理，编译都不会通过。<br>处理机制:<br>捕获机制：try-catch-finally<br>try-监控区域，执行可能产生异常的代码<br>catch-捕获，处理异常<br>finally-善后处理，无论是否发生异常，代码总能执行<br>抛出异常：throw 手动抛出异常<br>声明异常：throws 声明方法可能要抛出的异常<br>throw：手动抛出异常，一般由程序员在方法内抛出Exception的子类异常。<br>throws：声明在方法名之后，告诉调用者，该方法可能会抛出异常，也就是说异常发生后会抛给调用者，由 调用者处理异常。</p><p>请写出5种常见到的runtime exception<br>常见的几种如下：<br>NullPointerException - 空指针引用异常<br>ClassCastException - 类型强制转换异常。<br>IllegalArgumentException - 传递非法参数异常。<br>ArithmeticException - 算术运算异常<br>ArrayStoreException - 向数组中存放与声明类型不兼容对象异常<br>IndexOutOfBoundsException - 下标越界异常<br>NegativeArraySizeException - 创建一个大小为负数的数组错误异常<br>NumberFormatException - 数字格式异常<br>SecurityException - 安全异常<br>UnsupportedOperationException - 不支持的操作异常</p><h3 id="13、数组在内存中如何分配"><a href="#13、数组在内存中如何分配" class="headerlink" title="13、数组在内存中如何分配"></a>13、数组在内存中如何分配</h3><h3 id="14-io的模型和nio-selectionkey是什么"><a href="#14-io的模型和nio-selectionkey是什么" class="headerlink" title="14.io的模型和nio selectionkey是什么"></a>14.io的模型和nio selectionkey是什么</h3><h3 id="ConcurrentHashMap怎么实现高并发的"><a href="#ConcurrentHashMap怎么实现高并发的" class="headerlink" title="ConcurrentHashMap怎么实现高并发的"></a>ConcurrentHashMap怎么实现高并发的</h3><p>ConcurrentHashMap底层采用分段的数组+链表实现，线程安全(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)<br>ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术<br>有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁</p><h2 id="多线程："><a href="#多线程：" class="headerlink" title="多线程："></a>多线程：</h2><h3 id="1-什么是多线程，多线程的目的是什么？"><a href="#1-什么是多线程，多线程的目的是什么？" class="headerlink" title="1.什么是多线程，多线程的目的是什么？"></a>1.什么是多线程，多线程的目的是什么？</h3><p>1、避免阻塞（异步调用）<br>2、避免CPU空转<br>3、提升性能</p><h3 id="2-什么是线程安全，非线程安全？"><a href="#2-什么是线程安全，非线程安全？" class="headerlink" title="2.什么是线程安全，非线程安全？"></a>2.什么是线程安全，非线程安全？</h3><p>在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p><h3 id="3-线程的有那几个状态以及相互间的转换"><a href="#3-线程的有那几个状态以及相互间的转换" class="headerlink" title="3.线程的有那几个状态以及相互间的转换"></a>3.线程的有那几个状态以及相互间的转换</h3><p>创建<br>一般就是创建一个方法继承thread或实现runable方法的类，通过new来创建了。<br>就绪<br>当一个线程调用了start方法后，还没有获取到cpu线程。<br>运行<br>当就绪状态的线程获取到cpu后，便开始运行。<br>阻塞<br>当运行时的线程调用wait、sleep、join等方法后便进入阻塞状态，当线程重新被唤醒时，就会进入就绪或运行。<br>死亡<br>当线程的run方法执行完成后，或调用stop方法后就会死亡。</p><h3 id="4-wait-notify为什么必须存在于synchronized块中？"><a href="#4-wait-notify为什么必须存在于synchronized块中？" class="headerlink" title="4.wait/notify为什么必须存在于synchronized块中？"></a>4.wait/notify为什么必须存在于synchronized块中？</h3><p>也就是说wait/notify是线程之间的通信，他们存在竞态，我们必须保证在满足条件的情况下才进行wait。换句话说，如果不加锁的话，那么wait被调用的时候可能wait的条件已经不满足了(如上述)。由于错误的条件下进行了wait，那么就有可能永远不会被notify到，所以我们需要强制wait/notify在synchronized中</p><h3 id="5-多线程volatile关键字的作用？"><a href="#5-多线程volatile关键字的作用？" class="headerlink" title="5.多线程volatile关键字的作用？"></a>5.多线程volatile关键字的作用？</h3><p>volatile——Java虚拟机提供的最轻量级的同步机制。这个关键字的作用就是告诉编译器，只要是被此关键字修饰的变量都是易变的、不稳定的。<br> volatile特性之一：<br> 保证变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。<br> volatile特性之二：<br> 阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。</p><h3 id="6-Runnable，Thread，Callable三者的区别？"><a href="#6-Runnable，Thread，Callable三者的区别？" class="headerlink" title="6.Runnable，Thread，Callable三者的区别？"></a>6.Runnable，Thread，Callable三者的区别？</h3><p>Java中实现多线程有3种方法：<br>继承Thread类<br>实现Runnable接口<br>实现Callable接口(参考&lt;Java编程思想(第4版)&gt; 21.2.4章节，原来一直以为是2种，后来发现是3种)</p><p>Thread是继承重写run方法,可以直接执行start方法启动线程<br>Runnable是实现接口,本身不带线程启动方法,需要丢到Thread或者线程池里执行<br>Runnable是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成的能返回一个值，那么可以实现Callable接口而不是Runnable接口。在Java SE5中引入的Callable是一种具有类型参数的泛型，它的参数类型表示的是从方法call()(不是run())中返回的值。<br>总结<br>实现Runnable接口相比继承Thread类有如下优势：</p><p>可以避免由于Java的单继承特性而带来的局限；<br>增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；<br>适合多个相同程序代码的线程区处理同一资源的情况。</p><p>实现Runnable接口和实现Callable接口的区别:<br>Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的<br>Callable规定的方法是call(),Runnable规定的方法是run()<br>Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)<br>call方法可以抛出异常，run方法不可以<br>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。<br>加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。</p><h3 id="7-ThreadLocal-的作用，怎么使用它？"><a href="#7-ThreadLocal-的作用，怎么使用它？" class="headerlink" title="7.ThreadLocal 的作用，怎么使用它？"></a>7.ThreadLocal 的作用，怎么使用它？</h3><p>在每个线程中存储一个变量的副本，这样在每个线程对该变量进行使用的使用，使用的即是该线程的局部变量，从而保证了线程的安全性以及高效性。</p><p>ThreadLocal的使用场景：<br>在并发编程中时常有这样一种需求：每条线程都需要存取一个同名变量，但每条线程中该变量的值均不相同。比如后台系统登录账号信息</p><h3 id="8-Lock与synchronized的区别？"><a href="#8-Lock与synchronized的区别？" class="headerlink" title="8.Lock与synchronized的区别？"></a>8.Lock与synchronized的区别？</h3><p>1.　　Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定。<br>　　 但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将 unLock()放到finally{} 中；<br>2.　　synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；<br>　　　而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；<br>3.　　Lock可以让等待锁的线程响应中断，线程可以中断去干别的事务，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断<br>4.　　通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。<br>5.　　Lock可以提高多个线程进行读操作的效率。</p><h3 id="9-请对比hashTable-concurrentHashMap-HashMap的区别？"><a href="#9-请对比hashTable-concurrentHashMap-HashMap的区别？" class="headerlink" title="9.请对比hashTable , concurrentHashMap, HashMap的区别？"></a>9.请对比hashTable , concurrentHashMap, HashMap的区别？</h3><p>HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。<br>HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。<br>HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。<br>Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。<br>最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。</p><h3 id="10-什么是线程死锁？产生的原因？如何避免死锁？"><a href="#10-什么是线程死锁？产生的原因？如何避免死锁？" class="headerlink" title="10.什么是线程死锁？产生的原因？如何避免死锁？"></a>10.什么是线程死锁？产生的原因？如何避免死锁？</h3><p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><p>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。<br>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。<br>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。<br>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有，如图2-15所示。</p><p>在有些情况下死锁是可以避免的。三种用于避免死锁的技术：</p><p>加锁顺序（线程按照一定的顺序加锁）<br>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）<br>死锁检测</p><h3 id="11-什么是Executors框架？"><a href="#11-什么是Executors框架？" class="headerlink" title="11.什么是Executors框架？"></a>11.什么是Executors框架？</h3><h3 id="12-什么是Callable和Future"><a href="#12-什么是Callable和Future" class="headerlink" title="12.什么是Callable和Future?"></a>12.什么是Callable和Future?</h3><h3 id="13-在静态方法上使用同步时会发生什么事？"><a href="#13-在静态方法上使用同步时会发生什么事？" class="headerlink" title="13.在静态方法上使用同步时会发生什么事？"></a>13.在静态方法上使用同步时会发生什么事？</h3><p>同步静态方法时会获取该类的“Class”对象，所以当一个线程进入同步的静态方法中时，线程监视器获取类本身的对象锁，其它线程不能进入这个类的任何静态同步方法。它不像实例方法，因为多个线程可以同时访问不同实例同步实例方法。</p><h3 id="14-什么是线程饿死，什么是活锁？"><a href="#14-什么是线程饿死，什么是活锁？" class="headerlink" title="14.什么是线程饿死，什么是活锁？"></a>14.什么是线程饿死，什么是活锁？</h3><p>活锁：线程A和B都需要过桥(都需要使用进程),而都礼让不走(那到的系统优先级相同,都认为不是自己优先级高),就这么僵持下去.（很绅士，互相谦让）</p><p>并未产生线程阻塞，但是由于某种问题的存在，导致无法继续执行的情况。</p><p>消息重试。当某个消息处理失败的时候，一直重试，但重试由于某种原因，比如消息格式不对，导致解析失败，而它又被重试</p><p>这种时候一般是将不可修复的错误不要重试，或者是重试次数限定<br>相互协作的线程彼此响应从而修改自己状态，导致无法执行下去。比如两个很有礼貌的人在同一条路上相遇，彼此给对方让路，但是又在同一条路上遇到了。互相之间反复的避让下去</p><p>这种时候可以选择一个随机退让，使得具备一定的随机性</p><p>饥饿：:这是个独木桥(单进程),桥上只能走一个人,B来到时A在桥上,B等待;<br> 而此时比B年龄小的C来了,B让C现行(A走完后系统把进程分给了C),<br> C上桥后,D又来了,B又让D现行(C走完后系统把进程分个了D)<br> 以此类推B一直是等待状态.</p><h2 id="线程池："><a href="#线程池：" class="headerlink" title="线程池："></a>线程池：</h2><h3 id="1-解释线程池的作用？"><a href="#1-解释线程池的作用？" class="headerlink" title="1.解释线程池的作用？"></a>1.解释线程池的作用？</h3><p>1）降低资源消耗；2）提高响应速度；3）提高线程的可管理性。<br>线程的创建和销毁的开销是巨大的，而通过线程池的重用大大减少了这些不必要的开销，当然既然少了这么多消费内存的开销，其线程执行速度也是突飞猛进的提升。</p><p>并发：在某个时间段内，多个程序都处在执行和执行完毕之间；但在一个时间点上只有一个程序在运行。头脑风暴：老鹰妈妈喂小雏鹰食物，小雏鹰很多，而老鹰只有一张嘴，她需要一个个喂过去，到最后每个小雏鹰都可以吃到，但是在一个时间点里只能有一个小雏鹰可以吃到美味的食物。</p><p>并行：在某个时间段里，每个程序按照自己独立异步的速度执行，程序之间互不干扰。头脑风暴：这就好似老鹰妈妈决定这样喂食太费劲于是为每个小雏鹰请了个保姆，这样子在一个时间点里，每个小雏鹰都可以同时吃到食物，而且互相不干扰。</p><h3 id="2-线程池的处理流程？"><a href="#2-线程池的处理流程？" class="headerlink" title="2.线程池的处理流程？"></a>2.线程池的处理流程？</h3><p><img src="/images/loading.png" data-original="/images/pasted-11.png" alt="upload successful"><br>线程池优先要创建出基本线程池大小（corePoolSize）的线程数量，没有达到这个数量时，每次提交新任务都会直接创建一个新线程，当达到了基本线程数量后，又有新任务到达，优先放入等待队列，如果队列满了，才去创建新的线程（不能超过线程池的最大数maxmumPoolSize）</p><h3 id="3-jdk提供的线程池工具类有哪些，区别是什么？"><a href="#3-jdk提供的线程池工具类有哪些，区别是什么？" class="headerlink" title="3.jdk提供的线程池工具类有哪些，区别是什么？"></a>3.jdk提供的线程池工具类有哪些，区别是什么？</h3><p>newFixedThreadPool<br>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</p><p>newCachedThreadPool<br>创建一个可缓存的线程池。这种类型的线程池特点是：<br>1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。<br>2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p><p>newSingleThreadExecutor<br>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。</p><p>newScheduleThreadPool<br>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。(这种线程池原理暂还没完全了解透彻)</p><h3 id="4-关闭线程池的方法有哪些？区别是什么？"><a href="#4-关闭线程池的方法有哪些？区别是什么？" class="headerlink" title="4.关闭线程池的方法有哪些？区别是什么？"></a>4.关闭线程池的方法有哪些？区别是什么？</h3><p>一种是调用其shutdown()方法，另一种是调用shutdownNow()方法<br>shutdown:<br>1、调用之后不允许继续往线程池内继续添加线程;<br>2、线程池的状态变为SHUTDOWN状态;<br>3、所有在调用shutdown()方法之前提交到ExecutorSrvice的任务都会执行;<br>4、一旦所有线程结束执行当前任务，ExecutorService才会真正关闭。</p><p>shutdownNow():<br>1、该方法返回尚未执行的 task 的 List;<br>2、线程池的状态变为STOP状态;<br>3、阻止所有正在等待启动的任务, 并且停止当前正在执行的任务。</p><p>简单点来说，就是:<br>shutdown()调用后，不可以再 submit 新的 task，已经 submit 的将继续执行<br>shutdownNow()调用后，试图停止当前正在执行的 task，并返回尚未执行的 task 的 list</p><h2 id="MySqL："><a href="#MySqL：" class="headerlink" title="MySqL："></a>MySqL：</h2><h3 id="1-sql优化方法？"><a href="#1-sql优化方法？" class="headerlink" title="1.sql优化方法？"></a>1.sql优化方法？</h3><p>合理建立索引;对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引<br>应尽量避免使用!=和&lt;&gt;条件判断进行全表扫描;<br>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描;<br>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描;<br>in 和 not in 也要慎用，否则会导致全表扫描<br>避免模糊查询进行全表扫描<br>避免在字段上做表达式操作</p><h3 id="2-建索引有哪些策略和原则？"><a href="#2-建索引有哪些策略和原则？" class="headerlink" title="2.建索引有哪些策略和原则？"></a>2.建索引有哪些策略和原则？</h3><p>1.最左前缀匹配原则<br>非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>2.=和in可以乱序<br>比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p><p>3.尽量选择区分度高的列作为索引<br>区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</p><p>4.索引列不能参与计算<br>保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</p><p>5.尽量的扩展索引，不要新建索引。<br>比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p><p>6．选择唯一性索引<br>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p><p>7．为经常需要排序、分组和联合操作的字段建立索引<br>经常需要ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</p><p>8．为常作为查询条件的字段建立索引<br>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。</p><p>9．限制索引的数目<br>索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。</p><p>10．尽量使用数据量少的索引<br>如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR(100)类型的字段进行全文检索需要的时间肯定要比对CHAR(10)类型的字段需要的时间要多。</p><p>11．尽量使用前缀来索引<br>如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。</p><p>12．删除不再使用或者很少使用的索引<br>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p><h3 id="3-索引存储原理？"><a href="#3-索引存储原理？" class="headerlink" title="3.索引存储原理？"></a>3.索引存储原理？</h3><p>虽然 InnoDB 也使用 B+Tree 作为索引结构,但具体实现方式却与 MyISAM 截然不同。<br>1.第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道,MyISAM 索引文件和数据文件是分离的,索引文件仅保存数据记录的地址。</p><h3 id="4-mysql数据库锁有哪几种？"><a href="#4-mysql数据库锁有哪几种？" class="headerlink" title="4.mysql数据库锁有哪几种？"></a>4.mysql数据库锁有哪几种？</h3><p>表级锁和行级锁</p><h3 id="5-写一个数据库死锁的sql？"><a href="#5-写一个数据库死锁的sql？" class="headerlink" title="5.写一个数据库死锁的sql？"></a>5.写一个数据库死锁的sql？</h3><p>死锁是指，两个或者多个事务在同一个资源上互相占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</p><p>注意：当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。<br>例子：</p><p>事务1<br>START TRANSACTION;<br>UPDATE stock_price SET close = 45.50 WHERE stock_id = 4 and date = ‘2002-05-01’;<br>UPDATE stock_price SET close = 19.80 WHERE stock_id = 3 and date = ‘2002-05-02’;<br>COMMIT; 1<br>2<br>3<br>4</p><p>事务2<br>START TRANSACTION;<br>UPDATE stock_price SET high = 20.12 WHERE stock_id = 3 and date = ‘2002-05-02’;<br>UPDATE stock_price SET high = 47.20 WHERE stock_id = 4 and date = ‘2002-05-01’;<br>COMMIT; 1<br>2<br>3<br>4</p><p>如果凑巧，两个事务都执行了第一条UPDATE语句，更新了一行数据，同时也锁定了该行数据，接着每个事务都会尝试去执行第二条UPDATE语句，却发现该行已经被对方锁定，然后两个事务都等待对方释放锁，同时又持有对方需要的锁，则陷入死循环。（除非有外部因素介入，才可能解除死锁）</p><h3 id="6-如何做数据库分库分表？（mycat）"><a href="#6-如何做数据库分库分表？（mycat）" class="headerlink" title="6.如何做数据库分库分表？（mycat）"></a>6.如何做数据库分库分表？（mycat）</h3><h2 id="消息队列："><a href="#消息队列：" class="headerlink" title="消息队列："></a>消息队列：</h2><h3 id="1-RabbitMQ的exchange有哪几种？"><a href="#1-RabbitMQ的exchange有哪几种？" class="headerlink" title="1.RabbitMQ的exchange有哪几种？"></a>1.RabbitMQ的exchange有哪几种？</h3><p>四种ExchangeType分别是Direct exchange，Fanout exchange，Topic exchange和Headers exchange<br>Direct Exchange：<br>实现方式如下：</p><p>DirectExchange是RabbitMQ Broker的默认Exchange，它有一个特别的属性对一些简单的应用来说是非常有用的，在使用这个类型的Exchange时，可以不必指定routing key的名字，在此类型下创建的Queue有一个默认的routing key，这个routing key一般同Queue同名。</p><p>适用场景：<br>这种类型的Exchange，通常是将同一个message以一种循环的方式分发到不同的Queue，即不同的消费者手中，使用这种方式，值得注意的是message在消费者之间做了一个均衡，而不是说message在Queues之间做了均衡。</p><p>Fanout Exchange：<br> 实现方式如下：</p><p> 使用这种类型的Exchange，会忽略routing key的存在，直接将message广播到所有的Queue中。<br> 适用场景：<br> 第一：大型玩家在玩在线游戏的时候，可以用它来广播重大消息。这让我想到电影微微一笑很倾城中，有款游戏需要在世界上公布玩家重大消息，也许这个就是用的MQ实现的。这让我不禁佩服肖奈，人家在大学的时候就知道RabbitMQ的这种特性了。</p><pre><code>第二：体育新闻实时更新到手机客户端。

第三：群聊功能，广播消息给当前群聊中的所有人。</code></pre><p>Topic Exchange：<br>实现方式如下：</p><p>Topic Exchange是根据routing key和Exchange的类型将message发送到一个或者多个Queue中，我们经常拿他来实现各种publish/subscribe，即发布订阅，这也是我们经常使用到的ExchangeType。</p><p>使用场景：<br> 新闻的分类更新</p><pre><code>同意任务多个工作者协调完成

同一问题需要特定人员知晓</code></pre><p> Topic Exchange的使用场景很多，我们公司就在使用这种模式，将足球事件信息发布，需要使用这些事件消息的人只需要绑定对应的Exchange就可以获取最新消息。</p><p>Headers Exchange：<br>实现方式如下：</p><p> Headers Exchange不同于上面三种Exchange，它是根据Message的一些头部信息来分发过滤Message，忽略routing key的属性，如果Header信息和message消息的头信息相匹配，那么这条消息就匹配上了。</p><p>关于Headers Exchange我知道的并不多，但是这篇博客，我会在我持续深入理解RabbitMQ的基础上不断调整和更新，若有什么地方理解偏差，还请大家一起讨论。越来越体会到看英文资料的重要性。</p><h3 id="2-mq的使用场景有哪些？"><a href="#2-mq的使用场景有哪些？" class="headerlink" title="2.mq的使用场景有哪些？"></a>2.mq的使用场景有哪些？</h3><p>1.通过异步方式对系统解耦<br>比如用户注册流程</p><p>2.增加系统的并发处理能力<br>以电商中的秒杀场景为例，采用同步处理：</p><p>用户点击秒杀<br>调用订单服务，验证库存、锁定库存<br>跳转到支付页面进行支付<br>分析一下，存在的问题：</p><p>验证库存、锁定库存会访问数据库<br>秒杀场景，商品数量有限，请求量非常大，每个请求来了都做以上处理，直接会把数据库压垮，导致数据库无法对外提供服务，数据库的不可用直接导致整个业务的不可用，秒杀活动打水漂。</p><p>大量请求会同时到达，同时去访问数据库，数据库连接有限，导致很多请求会处于等待状态，导致并发性能急剧下降<br>大量用户同时操作库存，存在争抢数据库锁的情况，容易导致死锁<br>秒杀中数量一般是有限，大量用户抢购，其实最终只有很少的用户能够抢购到</p><p>大家都有在银行办理业务的经验，银行处理业务的流程：领号、排队、等待叫号办理业务。</p><p>秒杀中我们也可以参考银行办理业务的流程：</p><p>用户点击描述<br>系统接受到用户请求后，生成一个唯一的编号，然后投递一条消息（秒杀下单）到mq<br>响应用户：秒杀正在处理中<br>秒杀系统从mq中拉取消息进行处理，处理完成之后告知用户，这步操作对于用户来说是异步处理的过程<br>从上面可以看出，从接受用户请求到响应用户请求，未访问数据库，只有生成编号和发送消息的操作，这部分处理速度是非常快的，不存在性能的问题，数据库也不存在压力的问题了，所有用户的请求都被作为一条消息投递到mq进行异步处理；从而解决了秒杀中同步处理遇到的各种问题。</p><p>其他一些使用场景<br>系统日志的处理<br>系统手机日志，异步发送到mq，日志服务队从mq中拉取消息进行各种处理，关于这个以后我们会专门讨论。<br>通过事件驱动的一些业务，也可以使用mq实现</p><h3 id="3-RabbitMQ的系统架构？"><a href="#3-RabbitMQ的系统架构？" class="headerlink" title="3.RabbitMQ的系统架构？"></a>3.RabbitMQ的系统架构？</h3><h3 id="4-RabbitMQ的任务分发机制有哪些？"><a href="#4-RabbitMQ的任务分发机制有哪些？" class="headerlink" title="4.RabbitMQ的任务分发机制有哪些？"></a>4.RabbitMQ的任务分发机制有哪些？</h3><h2 id="Redis："><a href="#Redis：" class="headerlink" title="Redis："></a>Redis：</h2><h3 id="1-使用redis有哪些好处"><a href="#1-使用redis有哪些好处" class="headerlink" title="1.使用redis有哪些好处?"></a>1.使用redis有哪些好处?</h3><p>1.使用redis有哪些好处?<br>1、数据存储在内存中，读写速度快；<br>2、支持的数据类型资源丰富；<br>3、支持事务，操作都是原子性操作；<br>4、可以设置数据存活的生命周期。</p><h3 id="2-redis相比memcached有哪些优势？"><a href="#2-redis相比memcached有哪些优势？" class="headerlink" title="2.redis相比memcached有哪些优势？"></a>2.redis相比memcached有哪些优势？</h3><p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型<br>(2) redis的速度比memcached快很多<br>(3) redis可以持久化其数据</p><h3 id="3-redis常见性能问题和解决方案"><a href="#3-redis常见性能问题和解决方案" class="headerlink" title="3.redis常见性能问题和解决方案?"></a>3.redis常见性能问题和解决方案?</h3><p>(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件<br>(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次<br>(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内<br>(4) 尽量避免在压力很大的主库上增加从库<br>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</p><h3 id="4-redis集群有哪些模式？"><a href="#4-redis集群有哪些模式？" class="headerlink" title="4.redis集群有哪些模式？"></a>4.redis集群有哪些模式？</h3><p>一、主从同步/复制<br>二、哨兵模式<br>三、Cluster 集群</p><h3 id="5-redis中穿透，击穿与雪崩的预防及解决？"><a href="#5-redis中穿透，击穿与雪崩的预防及解决？" class="headerlink" title="5.redis中穿透，击穿与雪崩的预防及解决？"></a>5.redis中穿透，击穿与雪崩的预防及解决？</h3><p>缓存穿透:是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。<br>解决办法：<br>1.对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃。还有最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。<br>2.也可以采用一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><p>缓存击穿:就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。<br>解决方式<br>也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p><p>缓存雪崩:如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。<br>解决方法<br>1.在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。<br>2.可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存<br>不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀<br>3.做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。</p><h3 id="6-redis哨兵模式集群的原理？"><a href="#6-redis哨兵模式集群的原理？" class="headerlink" title="6.redis哨兵模式集群的原理？"></a>6.redis哨兵模式集群的原理？</h3><h2 id="Spring："><a href="#Spring：" class="headerlink" title="Spring："></a>Spring：</h2><h3 id="1-IOC和AOP的实现原理？"><a href="#1-IOC和AOP的实现原理？" class="headerlink" title="1.IOC和AOP的实现原理？"></a>1.IOC和AOP的实现原理？</h3><p>IOC:控制反转，就是把对象的创建交给Spring来做<br>二、SpringIoc所使用的技术<br>1、xml配置文件<br>2、dom4j解析XML文件<br>3、工厂设计模式<br>4、反射</p><h3 id="2-AOP的应用场景有哪些？以及动态代理原理是什么？"><a href="#2-AOP的应用场景有哪些？以及动态代理原理是什么？" class="headerlink" title="2.AOP的应用场景有哪些？以及动态代理原理是什么？"></a>2.AOP的应用场景有哪些？以及动态代理原理是什么？</h3><p>/* spring的AOP底层是由 JDK提供的动态代理技术 和 CGLIB(动态字节码增强技术)实现。<br><strong>JDK动态代理：</strong>Jdk动态代理只针对于接口操作。<br>CGLIB：可以针对没有接口的java类和有接口的java类。*/<br>动态代理，照我的理解就是，在不修改原有类对象方法的源代码基础上，通过代理对象实现原有类对象方法的增强，也就是拓展原有类对象的功能。</p><h3 id="3-事务的传播属性有哪几种？"><a href="#3-事务的传播属性有哪几种？" class="headerlink" title="3.事务的传播属性有哪几种？"></a>3.事务的传播属性有哪几种？</h3><p>事务特点<br>1.原子性：一个事务中所有对数据库的操作是一个不可分割的操作序列，要么全做要么全不做<br>2.一致性：数据不会因为事务的执行而遭到破坏<br>3.隔离性：一个事物的执行，不受其他事务的干扰，即并发执行的事物之间互不干扰<br>4.持久性：一个事物一旦提交，它对数据库的改变就是永久的。</p><p>七个事务传播属性<br>　PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br>　PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。<br>　PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。<br>　PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。<br>　PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>　PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。<br>　PROPAGATION_NESTED–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</p><p>五种隔离级别<br>隔离级别是指若干个并发的事务之间的隔离程度。<br>ISOLATION_DEFAULT–这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.另外四个与JDBC的隔离级别相对应；<br>ISOLATION_READ_UNCOMMITTED–这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。<br>ISOLATION_READ_COMMITTED–保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。<br>ISOLATION_REPEATABLE_READ–这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。<br>ISOLATION_SERIALIZABLE–这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。</p><p>关键词<br>1)幻读：事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录；<br>2)不可重复读取：事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录；<br>3)脏读：事务1更新了记录，但没有提交，事务2读取了更新后的行，然后事务T1回滚，现在T2读取无效。</p><h3 id="4-bean的生命周期？"><a href="#4-bean的生命周期？" class="headerlink" title="4.bean的生命周期？"></a>4.bean的生命周期？</h3><p>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化<br>Bean实例化后对将Bean的引入和值注入到Bean的属性中<br>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法<br>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入<br>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。<br>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。<br>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用<br>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。<br>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。<br>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</p><h3 id="5-Spring有哪些模块，分别有哪些作用和功能？"><a href="#5-Spring有哪些模块，分别有哪些作用和功能？" class="headerlink" title="5.Spring有哪些模块，分别有哪些作用和功能？"></a>5.Spring有哪些模块，分别有哪些作用和功能？</h3><ol><li>Spring Core： Core封装包是框架的最基础部分，提供IOC和依赖注入特性。这里的基础概念是BeanFactory，它提供对Factory模式的经典实现来消除对程序性单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置。</li></ol><p>2.Spring Context: 构建于Core封装包基础上的 Context封装包，提供了一种框架式的对象访问方法，有些象JNDI注册器。Context封装包的特性得自于Beans封装包，并添加了对国际化（I18N）的支持（例如资源绑定），事件传播，资源装载的方式和Context的透明创建，比如说通过Servlet容器。</p><p>3．Spring DAO: DAO (Data Access Object)提供了JDBC的抽象层，它可消除冗长的JDBC编码和解析数据库厂商特有的错误代码。 并且，JDBC封装包还提供了一种比编程性更好的声明性事务管理方法，不仅仅是实现了特定接口，而且对所有的POJOs（plain old Java objects）都适用。</p><p>4.Spring ORM: ORM 封装包提供了常用的“对象/关系”映射APIs的集成层。 其中包括JPA、JDO、Hibernate 和 iBatis 。利用ORM封装包，可以混合使用所有Spring提供的特性进行“对象/关系”映射，如前边提到的简单声明性事务管理。</p><p>5.Spring AOP: Spring的 AOP 封装包提供了符合AOP Alliance规范的面向方面的编程实现，让你可以定义，例如方法拦截器（method-interceptors）和切点（pointcuts），从逻辑上讲，从而减弱代码的功能耦合，清晰的被分离开。而且，利用source-level的元数据功能，还可以将各种行为信息合并到你的代码中。</p><p>6.Spring Web: Spring中的 Web 包提供了基础的针对Web开发的集成特性，例如多方文件上传，利用Servlet listeners进行IOC容器初始化和针对Web的ApplicationContext。当与WebWork或Struts一起使用Spring时，这个包使Spring可与其他框架结合。</p><p>7.Spring Web MVC: Spring中的MVC封装包提供了Web应用的Model-View-Controller（MVC）实现。Spring的MVC框架并不是仅仅提供一种传统的实现，它提供了一种清晰的分离模型，在领域模型代码和Web Form之间。并且，还可以借助Spring框架的其他特性。</p><h2 id="SpringMVC："><a href="#SpringMVC：" class="headerlink" title="SpringMVC："></a>SpringMVC：</h2><h3 id="1-SpringMVC的工作原理，举例说明流程？"><a href="#1-SpringMVC的工作原理，举例说明流程？" class="headerlink" title="1.SpringMVC的工作原理，举例说明流程？"></a>1.SpringMVC的工作原理，举例说明流程？</h3><h2 id="MyBatis："><a href="#MyBatis：" class="headerlink" title="MyBatis："></a>MyBatis：</h2><h3 id="1-Mybatis的二级缓存？"><a href="#1-Mybatis的二级缓存？" class="headerlink" title="1.Mybatis的二级缓存？"></a>1.Mybatis的二级缓存？</h3><p><a href="https://blog.csdn.net/Yang_Hui_Liang/article/details/88291752" target="_blank" rel="noopener">https://blog.csdn.net/Yang_Hui_Liang/article/details/88291752</a></p><h2 id="Zookeeper："><a href="#Zookeeper：" class="headerlink" title="Zookeeper："></a>Zookeeper：</h2><h3 id="1-zk的作用和原理？"><a href="#1-zk的作用和原理？" class="headerlink" title="1.zk的作用和原理？"></a>1.zk的作用和原理？</h3><h3 id="2-zk设计要满足哪些特性？分别解释一下？"><a href="#2-zk设计要满足哪些特性？分别解释一下？" class="headerlink" title="2.zk设计要满足哪些特性？分别解释一下？"></a>2.zk设计要满足哪些特性？分别解释一下？</h3><h3 id="3-zk的选举机制是什么？是否有了解Paxos算法？"><a href="#3-zk的选举机制是什么？是否有了解Paxos算法？" class="headerlink" title="3.zk的选举机制是什么？是否有了解Paxos算法？"></a>3.zk的选举机制是什么？是否有了解Paxos算法？</h3><h2 id="Nginx："><a href="#Nginx：" class="headerlink" title="Nginx："></a>Nginx：</h2><h3 id="1-什么是Nginx？Nginx的作用是什么？"><a href="#1-什么是Nginx？Nginx的作用是什么？" class="headerlink" title="1.什么是Nginx？Nginx的作用是什么？"></a>1.什么是Nginx？Nginx的作用是什么？</h3><p>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。</p><h3 id="2-Nginx-有哪些特点？"><a href="#2-Nginx-有哪些特点？" class="headerlink" title="2.Nginx 有哪些特点？"></a>2.Nginx 有哪些特点？</h3><h2 id="分布式："><a href="#分布式：" class="headerlink" title="分布式："></a>分布式：</h2><ol><li>单一职责、高内聚低耦合</li><li>服务粒度适中</li><li>考虑团队结构</li><li>以业务模型切入</li><li>演进式拆分</li><li>避免环形依赖与双向依赖</li></ol><h3 id="1-什么是分布式系统？解决什么问题？"><a href="#1-什么是分布式系统？解决什么问题？" class="headerlink" title="1.什么是分布式系统？解决什么问题？"></a>1.什么是分布式系统？解决什么问题？</h3><p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。<br>（1）提升性能和并发，操作被分发到不同的分片，相互独立<br>（2）提升系统的可用性，即使部分分片不能用，其他分片不会受到影响</p><h3 id="2-如何提升系统吞吐量？"><a href="#2-如何提升系统吞吐量？" class="headerlink" title="2.如何提升系统吞吐量？"></a>2.如何提升系统吞吐量？</h3><h3 id="3-如何降低延迟？"><a href="#3-如何降低延迟？" class="headerlink" title="3.如何降低延迟？"></a>3.如何降低延迟？</h3><p>局域网<br>业务精简</p><h3 id="4-如何做故障恢复？"><a href="#4-如何做故障恢复？" class="headerlink" title="4.如何做故障恢复？"></a>4.如何做故障恢复？</h3><h3 id="5-如何做日志统一系统？"><a href="#5-如何做日志统一系统？" class="headerlink" title="5.如何做日志统一系统？"></a>5.如何做日志统一系统？</h3><p>ELK是Elasticsearch、Logstash、Kibana三大开源框架首字母大写简称。市面上也被成为Elastic Stack。其中Elasticsearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架，可见Elasticsearch提供的搜索能力确实强大,市面上很多时候我们简称Elasticsearch为es。Logstash是ELK的中央数据流引擎，用于从不同目标（文件/数据存储/MQ）收集的不同格式数据，经过过滤后支持输出到不同目的地（文件/MQ/redis/elasticsearch/kafka等）。Kibana可以将elasticsearch的数据通过友好的页面展示出来，提供实时分析的功能。</p><h3 id="6-怎么实现通讯编程？如rpc服务，webService服务等；"><a href="#6-怎么实现通讯编程？如rpc服务，webService服务等；" class="headerlink" title="6.怎么实现通讯编程？如rpc服务，webService服务等；"></a>6.怎么实现通讯编程？如rpc服务，webService服务等；</h3><h3 id="7-高并发秒杀解决方案有哪些？"><a href="#7-高并发秒杀解决方案有哪些？" class="headerlink" title="7.高并发秒杀解决方案有哪些？"></a>7.高并发秒杀解决方案有哪些？</h3><h3 id="8-分布式系统有哪些优势？"><a href="#8-分布式系统有哪些优势？" class="headerlink" title="8.分布式系统有哪些优势？"></a>8.分布式系统有哪些优势？</h3><h3 id="9-分布式系统会面临什么挑战？"><a href="#9-分布式系统会面临什么挑战？" class="headerlink" title="9.分布式系统会面临什么挑战？"></a>9.分布式系统会面临什么挑战？</h3><p>问题一：异构系统的不标准问题<br>这主要表现在：软件和应用、通讯协议、数据格式、开发和运维的过程和方法不标准。</p><p>不同的语言会出现不同的兼容性和不同的开发、测试、运维标准。比如：有的软件修改配置要改它的.conf 文件，而有的则是调用管理 API 接口。</p><p>通讯：不同的软件用不同的协议，就算是相同的网络协议里也会出现不同的数据格式。还有，不同的团队因为用不同的技术，会有不同的开发和运维方式。这些不同的东西，会让我们的整个分布式系统架构变得异常复杂。所以，分布式系统架构需要有相应的规范。…</p><p>数据通讯协议。通常来说，协议有协议头（最基本的协议数据）和协议体（真正的业务数据）。协议头，统一标准定义，才容易对请求进行监控、调度和管理。</p><p>问题二：系统架构中的服务依赖性问题。<br>如果非关键业务被关键业务所依赖，会导致非关键业务变成一个关键业务。</p><p>服务依赖链中，出现“木桶短板效应”——整个 SLA 由最差的那个服务所决定。</p><p>服务治理需要定义出服务关键程度和关键业务或服务调用的主要路径。否则无法运维或是管理整个系统。</p><p>数据库方面也需要做相应的隔离：避免非关键业务把数据库拖死，那么会导致全站不可用。系统间不能读取对方的数据库，只通过服务接口耦合。这也是微服务的要求：拆分服务和相应数据库。</p><p>问题三：故障发生的概率更大<br>故障恢复时间过长/影响面过大才可怕。</p><p>系统里添加各种监控指标是在“使蛮力”。信息太多等于没有信息，要定义出关键指标。</p><p>设计时就要考虑如何减轻故障。如果无法避免，也要使用自动化的方式恢复故障，减少故障影响面。</p><p>问题四：多层架构的运维复杂度更大<br>基础层：机器、网络和存储设备等。</p><p>平台层：中间件层，Tomcat、MySQL、Redis、Kafka 之类的软件。</p><p>应用层：业务软件，比如，各种功能的服务。</p><p>接入层：接入用户请求的网关、负载均衡或是 CDN、DNS 这样的东西。</p><p>没有统一的视图和管理，导致运维被割裂开来，造成更大的复杂度。</p><p>技术团队分为产品开发、中间件开发、业务运维、系统运维等子团队。整个系统会像 “多米诺骨牌”一样，一个环节出现问题，就会倒下去一大片。因为没有一个统一的运维视图，不知道一个服务调用是如何经过每一个服务和资源，花大量的时间在沟通和定位问题上。</p><p>分工不是问题，问题是分工后的协作是否统一和规范。</p><h3 id="10-如何设计分布式系统？"><a href="#10-如何设计分布式系统？" class="headerlink" title="10.如何设计分布式系统？"></a>10.如何设计分布式系统？</h3><p>功能单一性<br>服务独立性</p><h3 id="11-如何做分布式事务？"><a href="#11-如何做分布式事务？" class="headerlink" title="11.如何做分布式事务？"></a>11.如何做分布式事务？</h3><p>一般来说，分布式事务的实现主要有以下 5 种方案：<br>XA 方案<br>TCC 方案<br>本地消息表<br>可靠消息最终一致性方案<br>最大努力通知方案</p><p>两阶段提交方案/XA方案<br>所谓的 XA 方案，即：两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</p><p>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 Spring + JTA 就可以搞定，自己随便搜个 demo 看看就知道了。</p><p>这个方案，我们很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求每个服务只能操作自己对应的一个数据库。</p><p>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p><p>如果你要操作别人的服务的库，你必须是通过调用别的服务的接口来实现，绝对不允许交叉访问别人的数据库。</p><p>​</p><p>TCC 方案<br>TCC 的全称是：Try、Confirm、Cancel。</p><p>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。<br>Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。<br>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）<br>这种方案说实话几乎很少人使用，我们用的也比较少，但是也有使用的场景。因为这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大，非常之恶心。</p><p>比如说我们，一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</p><p>而且最好是你的各个业务执行的时间都比较短。</p><p>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码很难维护。</p><p>​</p><p>本地消息表<br>本地消息表其实是国外的 ebay 搞出来的这么一套思想。</p><p>这个大概意思是这样的：</p><p>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；<br>接着 A 系统将这个消息发送到 MQ 中去；<br>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；<br>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；<br>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；<br>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。<br>这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务啥的，会导致如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</p><p>​</p><p>可靠消息最终一致性方案<br>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p><p>大概的意思就是：</p><p>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；<br>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；<br>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；<br>mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。<br>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。<br>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。<br>​</p><p>最大努力通知方案<br>这个方案的大致意思就是：</p><p>系统 A 本地事务执行完之后，发送个消息到 MQ；<br>这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；<br>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。<br>你们公司是如何处理分布式事务的？<br>如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。</p><p>你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</p><p>友情提示一下，RocketMQ 3.2.6 之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变，我这里不再赘述了。</p><p>当然如果你愿意，你可以参考可靠消息最终一致性方案来自己实现一套分布式事务，比如基于 RocketMQ 来玩儿。</p><h2 id="其他问题："><a href="#其他问题：" class="headerlink" title="其他问题："></a>其他问题：</h2><h3 id="1-如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？"><a href="#1-如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？" class="headerlink" title="1.如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？"></a>1.如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？</h3><h3 id="2-如何支持大量流量的访问？可以在哪些地方进行优化？"><a href="#2-如何支持大量流量的访问？可以在哪些地方进行优化？" class="headerlink" title="2.如何支持大量流量的访问？可以在哪些地方进行优化？"></a>2.如何支持大量流量的访问？可以在哪些地方进行优化？</h3><h3 id="3-双11流量怎么控制？"><a href="#3-双11流量怎么控制？" class="headerlink" title="3.双11流量怎么控制？"></a>3.双11流量怎么控制？</h3><p><a href="https://www.cnblogs.com/zhuifeng523/p/11837663.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuifeng523/p/11837663.html</a></p><h3 id="4-1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）"><a href="#4-1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）" class="headerlink" title="4.1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）"></a>4.1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）</h3><h3 id="5-分布式环境下，如何对一个web请求的做监控？"><a href="#5-分布式环境下，如何对一个web请求的做监控？" class="headerlink" title="5.分布式环境下，如何对一个web请求的做监控？"></a>5.分布式环境下，如何对一个web请求的做监控？</h3></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>Post author:</strong> LZZ</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="http://blog.iamlzz.cn/archives/4048efa0.html" title="面试经">http://blog.iamlzz.cn/archives/4048efa0.html</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/archives/b0de6b16.html" rel="next" title="Java程序员Chrome浏览器必装插件"><i class="fa fa-chevron-left"></i> Java程序员Chrome浏览器必装插件</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article><div class="post-spread"><div class="bdsharebuttonbox"><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a><a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a><a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a><a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a><a href="#" class="bds_more" data-cmd="more"></a><a class="bds_count" data-cmd="count"></a></div><script>window._bd_share_config={common:{bdText:"",bdMini:"2",bdMiniList:!1,bdPic:""},share:{bdSize:"16",bdStyle:"0"},image:{viewList:["tsina","douban","sqq","qzone","weixin","twi","fbook"],viewText:"分享到：",viewSize:"16"}}</script><script>with(document)(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="//bdimg.share.baidu.com/static/api/js/share.js?cdnversion="+~(-new Date/36e5)</script></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">LZZ</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives%7C%7C%20archive"><span class="site-state-item-count">10</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">8</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">14</span> <span class="site-state-item-name">tags</span></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#java基础："><span class="nav-number">1.</span> <span class="nav-text">java基础：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HashMap的数据结构是什么？"><span class="nav-number">1.1.</span> <span class="nav-text">1.HashMap的数据结构是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、HashSet-是如何保证不重复的"><span class="nav-number">1.2.</span> <span class="nav-text">2、HashSet 是如何保证不重复的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）"><span class="nav-number">1.3.</span> <span class="nav-text">3、HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、HashMap-的扩容过程"><span class="nav-number">1.4.</span> <span class="nav-text">4、HashMap 的扩容过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？"><span class="nav-number">1.5.</span> <span class="nav-text">5、HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、final-finally-finalize"><span class="nav-number">1.6.</span> <span class="nav-text">6、final finally finalize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、强引用-、软引用、-弱引用、虚引用"><span class="nav-number">1.7.</span> <span class="nav-text">7、强引用 、软引用、 弱引用、虚引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、Java反射的实现原理"><span class="nav-number">1.8.</span> <span class="nav-text">8、Java反射的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、Arrays-sort-实现原理和-Collections-实现原理"><span class="nav-number">1.9.</span> <span class="nav-text">9、Arrays.sort 实现原理和 Collections 实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、LinkedHashMap的应用"><span class="nav-number">1.10.</span> <span class="nav-text">10、LinkedHashMap的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11、cloneable接口实现原理"><span class="nav-number">1.11.</span> <span class="nav-text">11、cloneable接口实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12、异常分类以及处理机制"><span class="nav-number">1.12.</span> <span class="nav-text">12、异常分类以及处理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13、数组在内存中如何分配"><span class="nav-number">1.13.</span> <span class="nav-text">13、数组在内存中如何分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-io的模型和nio-selectionkey是什么"><span class="nav-number">1.14.</span> <span class="nav-text">14.io的模型和nio selectionkey是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap怎么实现高并发的"><span class="nav-number">1.15.</span> <span class="nav-text">ConcurrentHashMap怎么实现高并发的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程："><span class="nav-number">2.</span> <span class="nav-text">多线程：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-什么是多线程，多线程的目的是什么？"><span class="nav-number">2.1.</span> <span class="nav-text">1.什么是多线程，多线程的目的是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-什么是线程安全，非线程安全？"><span class="nav-number">2.2.</span> <span class="nav-text">2.什么是线程安全，非线程安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-线程的有那几个状态以及相互间的转换"><span class="nav-number">2.3.</span> <span class="nav-text">3.线程的有那几个状态以及相互间的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-wait-notify为什么必须存在于synchronized块中？"><span class="nav-number">2.4.</span> <span class="nav-text">4.wait/notify为什么必须存在于synchronized块中？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-多线程volatile关键字的作用？"><span class="nav-number">2.5.</span> <span class="nav-text">5.多线程volatile关键字的作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Runnable，Thread，Callable三者的区别？"><span class="nav-number">2.6.</span> <span class="nav-text">6.Runnable，Thread，Callable三者的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-ThreadLocal-的作用，怎么使用它？"><span class="nav-number">2.7.</span> <span class="nav-text">7.ThreadLocal 的作用，怎么使用它？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Lock与synchronized的区别？"><span class="nav-number">2.8.</span> <span class="nav-text">8.Lock与synchronized的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-请对比hashTable-concurrentHashMap-HashMap的区别？"><span class="nav-number">2.9.</span> <span class="nav-text">9.请对比hashTable , concurrentHashMap, HashMap的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-什么是线程死锁？产生的原因？如何避免死锁？"><span class="nav-number">2.10.</span> <span class="nav-text">10.什么是线程死锁？产生的原因？如何避免死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-什么是Executors框架？"><span class="nav-number">2.11.</span> <span class="nav-text">11.什么是Executors框架？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-什么是Callable和Future"><span class="nav-number">2.12.</span> <span class="nav-text">12.什么是Callable和Future?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-在静态方法上使用同步时会发生什么事？"><span class="nav-number">2.13.</span> <span class="nav-text">13.在静态方法上使用同步时会发生什么事？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-什么是线程饿死，什么是活锁？"><span class="nav-number">2.14.</span> <span class="nav-text">14.什么是线程饿死，什么是活锁？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池："><span class="nav-number">3.</span> <span class="nav-text">线程池：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-解释线程池的作用？"><span class="nav-number">3.1.</span> <span class="nav-text">1.解释线程池的作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-线程池的处理流程？"><span class="nav-number">3.2.</span> <span class="nav-text">2.线程池的处理流程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-jdk提供的线程池工具类有哪些，区别是什么？"><span class="nav-number">3.3.</span> <span class="nav-text">3.jdk提供的线程池工具类有哪些，区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-关闭线程池的方法有哪些？区别是什么？"><span class="nav-number">3.4.</span> <span class="nav-text">4.关闭线程池的方法有哪些？区别是什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySqL："><span class="nav-number">4.</span> <span class="nav-text">MySqL：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-sql优化方法？"><span class="nav-number">4.1.</span> <span class="nav-text">1.sql优化方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-建索引有哪些策略和原则？"><span class="nav-number">4.2.</span> <span class="nav-text">2.建索引有哪些策略和原则？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-索引存储原理？"><span class="nav-number">4.3.</span> <span class="nav-text">3.索引存储原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-mysql数据库锁有哪几种？"><span class="nav-number">4.4.</span> <span class="nav-text">4.mysql数据库锁有哪几种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-写一个数据库死锁的sql？"><span class="nav-number">4.5.</span> <span class="nav-text">5.写一个数据库死锁的sql？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-如何做数据库分库分表？（mycat）"><span class="nav-number">4.6.</span> <span class="nav-text">6.如何做数据库分库分表？（mycat）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息队列："><span class="nav-number">5.</span> <span class="nav-text">消息队列：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-RabbitMQ的exchange有哪几种？"><span class="nav-number">5.1.</span> <span class="nav-text">1.RabbitMQ的exchange有哪几种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-mq的使用场景有哪些？"><span class="nav-number">5.2.</span> <span class="nav-text">2.mq的使用场景有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-RabbitMQ的系统架构？"><span class="nav-number">5.3.</span> <span class="nav-text">3.RabbitMQ的系统架构？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-RabbitMQ的任务分发机制有哪些？"><span class="nav-number">5.4.</span> <span class="nav-text">4.RabbitMQ的任务分发机制有哪些？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis："><span class="nav-number">6.</span> <span class="nav-text">Redis：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-使用redis有哪些好处"><span class="nav-number">6.1.</span> <span class="nav-text">1.使用redis有哪些好处?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-redis相比memcached有哪些优势？"><span class="nav-number">6.2.</span> <span class="nav-text">2.redis相比memcached有哪些优势？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-redis常见性能问题和解决方案"><span class="nav-number">6.3.</span> <span class="nav-text">3.redis常见性能问题和解决方案?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-redis集群有哪些模式？"><span class="nav-number">6.4.</span> <span class="nav-text">4.redis集群有哪些模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-redis中穿透，击穿与雪崩的预防及解决？"><span class="nav-number">6.5.</span> <span class="nav-text">5.redis中穿透，击穿与雪崩的预防及解决？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-redis哨兵模式集群的原理？"><span class="nav-number">6.6.</span> <span class="nav-text">6.redis哨兵模式集群的原理？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring："><span class="nav-number">7.</span> <span class="nav-text">Spring：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-IOC和AOP的实现原理？"><span class="nav-number">7.1.</span> <span class="nav-text">1.IOC和AOP的实现原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-AOP的应用场景有哪些？以及动态代理原理是什么？"><span class="nav-number">7.2.</span> <span class="nav-text">2.AOP的应用场景有哪些？以及动态代理原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-事务的传播属性有哪几种？"><span class="nav-number">7.3.</span> <span class="nav-text">3.事务的传播属性有哪几种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-bean的生命周期？"><span class="nav-number">7.4.</span> <span class="nav-text">4.bean的生命周期？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Spring有哪些模块，分别有哪些作用和功能？"><span class="nav-number">7.5.</span> <span class="nav-text">5.Spring有哪些模块，分别有哪些作用和功能？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC："><span class="nav-number">8.</span> <span class="nav-text">SpringMVC：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-SpringMVC的工作原理，举例说明流程？"><span class="nav-number">8.1.</span> <span class="nav-text">1.SpringMVC的工作原理，举例说明流程？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis："><span class="nav-number">9.</span> <span class="nav-text">MyBatis：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Mybatis的二级缓存？"><span class="nav-number">9.1.</span> <span class="nav-text">1.Mybatis的二级缓存？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper："><span class="nav-number">10.</span> <span class="nav-text">Zookeeper：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-zk的作用和原理？"><span class="nav-number">10.1.</span> <span class="nav-text">1.zk的作用和原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-zk设计要满足哪些特性？分别解释一下？"><span class="nav-number">10.2.</span> <span class="nav-text">2.zk设计要满足哪些特性？分别解释一下？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-zk的选举机制是什么？是否有了解Paxos算法？"><span class="nav-number">10.3.</span> <span class="nav-text">3.zk的选举机制是什么？是否有了解Paxos算法？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx："><span class="nav-number">11.</span> <span class="nav-text">Nginx：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-什么是Nginx？Nginx的作用是什么？"><span class="nav-number">11.1.</span> <span class="nav-text">1.什么是Nginx？Nginx的作用是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Nginx-有哪些特点？"><span class="nav-number">11.2.</span> <span class="nav-text">2.Nginx 有哪些特点？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式："><span class="nav-number">12.</span> <span class="nav-text">分布式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-什么是分布式系统？解决什么问题？"><span class="nav-number">12.1.</span> <span class="nav-text">1.什么是分布式系统？解决什么问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-如何提升系统吞吐量？"><span class="nav-number">12.2.</span> <span class="nav-text">2.如何提升系统吞吐量？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-如何降低延迟？"><span class="nav-number">12.3.</span> <span class="nav-text">3.如何降低延迟？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-如何做故障恢复？"><span class="nav-number">12.4.</span> <span class="nav-text">4.如何做故障恢复？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-如何做日志统一系统？"><span class="nav-number">12.5.</span> <span class="nav-text">5.如何做日志统一系统？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-怎么实现通讯编程？如rpc服务，webService服务等；"><span class="nav-number">12.6.</span> <span class="nav-text">6.怎么实现通讯编程？如rpc服务，webService服务等；</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-高并发秒杀解决方案有哪些？"><span class="nav-number">12.7.</span> <span class="nav-text">7.高并发秒杀解决方案有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-分布式系统有哪些优势？"><span class="nav-number">12.8.</span> <span class="nav-text">8.分布式系统有哪些优势？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-分布式系统会面临什么挑战？"><span class="nav-number">12.9.</span> <span class="nav-text">9.分布式系统会面临什么挑战？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-如何设计分布式系统？"><span class="nav-number">12.10.</span> <span class="nav-text">10.如何设计分布式系统？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-如何做分布式事务？"><span class="nav-number">12.11.</span> <span class="nav-text">11.如何做分布式事务？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他问题："><span class="nav-number">13.</span> <span class="nav-text">其他问题：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？"><span class="nav-number">13.1.</span> <span class="nav-text">1.如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-如何支持大量流量的访问？可以在哪些地方进行优化？"><span class="nav-number">13.2.</span> <span class="nav-text">2.如何支持大量流量的访问？可以在哪些地方进行优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-双11流量怎么控制？"><span class="nav-number">13.3.</span> <span class="nav-text">3.双11流量怎么控制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）"><span class="nav-number">13.4.</span> <span class="nav-text">4.1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-分布式环境下，如何对一个web请求的做监控？"><span class="nav-number">13.5.</span> <span class="nav-text">5.分布式环境下，如何对一个web请求的做监控？</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">LZZ</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},log:!1,tagMode:!1})</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)0<=(t=c[r].getBoundingClientRect()).top&&0<=t.left&&t.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n()},e.src=i}();var t}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this)</script></body></html>