<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"7.5.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},sidebarPadding:40}</script><meta name="description" content="java基础：1.HashMap的数据结构是什么？JDK版本 实现方式 节点数&amp;gt;=8 节点数&amp;lt;=61.8以前 数组+单向链表 数组+单向链表 数组+单向链表1.8以后 数组+单向链表+红黑树 数组+红黑树 数组+单向链表寻址算法优化(n - 1) &amp;amp; hash -&amp;gt; 数组里的一个位置"><meta property="og:type" content="article"><meta property="og:title" content="面试经"><meta property="og:url" content="http:&#x2F;&#x2F;blog.iamlzz.cn&#x2F;archives&#x2F;4048efa0.html"><meta property="og:site_name" content="I Tell You Code"><meta property="og:description" content="java基础：1.HashMap的数据结构是什么？JDK版本 实现方式 节点数&amp;gt;=8 节点数&amp;lt;=61.8以前 数组+单向链表 数组+单向链表 数组+单向链表1.8以后 数组+单向链表+红黑树 数组+红黑树 数组+单向链表寻址算法优化(n - 1) &amp;amp; hash -&amp;gt; 数组里的一个位置"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http:&#x2F;&#x2F;blog.iamlzz.cn&#x2F;images&#x2F;loading.png"><meta property="og:updated_time" content="2020-02-22T07:31:50.884Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http:&#x2F;&#x2F;blog.iamlzz.cn&#x2F;images&#x2F;loading.png"><link rel="canonical" href="http://blog.iamlzz.cn/archives/4048efa0.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>面试经 | I Tell You Code</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c8b099fee41d37bf3c9d35730f4940c8";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">I Tell You Code</span><span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://blog.iamlzz.cn/archives/4048efa0.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="LZZ"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="I Tell You Code"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 面试经</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-02-22 15:25:00 / 修改时间：15:31:50" itemprop="dateCreated datePublished" datetime="2020-02-22T15:25:00+08:00">2020-02-22</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="java基础："><a href="#java基础：" class="headerlink" title="java基础："></a>java基础：</h2><h3 id="1-HashMap的数据结构是什么？"><a href="#1-HashMap的数据结构是什么？" class="headerlink" title="1.HashMap的数据结构是什么？"></a>1.HashMap的数据结构是什么？</h3><p>JDK版本 实现方式 节点数&gt;=8 节点数&lt;=6<br>1.8以前 数组+单向链表 数组+单向链表 数组+单向链表<br>1.8以后 数组+单向链表+红黑树 数组+红黑树 数组+单向链表<br>寻址算法优化<br>(n - 1) &amp; hash -&gt; 数组里的一个位置</p><a id="more"></a><h3 id="2、HashSet-是如何保证不重复的"><a href="#2、HashSet-是如何保证不重复的" class="headerlink" title="2、HashSet 是如何保证不重复的"></a>2、HashSet 是如何保证不重复的</h3><p>底层维护了一个HashMap</p><h3 id="3、HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）"><a href="#3、HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）" class="headerlink" title="3、HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?"></a>3、HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?</h3><p>线程不安全</p><h3 id="4、HashMap-的扩容过程"><a href="#4、HashMap-的扩容过程" class="headerlink" title="4、HashMap 的扩容过程"></a>4、HashMap 的扩容过程</h3><p>初始长度是16，并且每次扩展时候，长度必须是2的幂。因为2的幂-1对应的二进制末尾总是是1111，这样，和key.hash做“与”运算的时候，只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。</p><h3 id="5、HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？"><a href="#5、HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？" class="headerlink" title="5、HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？"></a>5、HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？</h3><p>JDK版本 实现方式 节点数&gt;=8 节点数&lt;=6<br>1.8以前 数组+单向链表 数组+单向链表 数组+单向链表<br>1.8以后 数组+单向链表+红黑树 数组+红黑树 数组+单向链表<br>寻址算法优化<br>(n - 1) &amp; hash -&gt; 数组里的一个位置</p><h3 id="6、final-finally-finalize"><a href="#6、final-finally-finalize" class="headerlink" title="6、final finally finalize"></a>6、final finally finalize</h3><p>final用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。<br>finally是异常处理语句结构的一部分，表示总是执行。<br>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。</p><h3 id="7、强引用-、软引用、-弱引用、虚引用"><a href="#7、强引用-、软引用、-弱引用、虚引用" class="headerlink" title="7、强引用 、软引用、 弱引用、虚引用"></a>7、强引用 、软引用、 弱引用、虚引用</h3><p>强引用（Strong Reference）：通常我们通过new来创建一个新对象时返回的引用就是一个强引用，若一个对象通过一系列强引用可到达，它就是强可达的(strongly reachable)，那么它就不被回收；<br>软引用（Soft Reference）：软引用和弱引用的区别在于，若一个对象是弱引用可达，无论当前内存是否充足它都会被回收，而软引用可达的对象在内存不充足时才会被回收，因此软引用要比弱引用“强”一些；<br>弱引用（Weak Reference）：弱引用简单来说就是将对象留在内存的能力不是那么强的引用。使用Weak Reference，垃圾回收器会帮你来决定引用的对象何时回收并且将对象从内存移除。ThreadLocal的key使用了弱引用。<br>虚引用（Phantom Reference）：虚引用是Java中最弱的引用，那么它弱到什么程度呢？它是如此脆弱以至于我们通过虚引用甚至无法获取到被引用的对象，虚引用存在的唯一作用就是当它指向的对象被回收后，虚引用本身会被加入到引用队列中，用作记录它指向的对象已被回收。</p><h3 id="8、Java反射的实现原理"><a href="#8、Java反射的实现原理" class="headerlink" title="8、Java反射的实现原理"></a>8、Java反射的实现原理</h3><p>反射:(reflection):在运行时期,动态地去获取类中的信息(类的信息,方法信息,构造器信息,字段等信息进行操作);<br>一个类中包含的信息有： 构造器，字段，方法<br>如何使用反射描述这些相关的信息<br>Class ： 描述类<br>Method ： 描述方法<br>Constructor ：描述构造器<br>Field ：描述字段</p><h3 id="9、Arrays-sort-实现原理和-Collections-实现原理"><a href="#9、Arrays-sort-实现原理和-Collections-实现原理" class="headerlink" title="9、Arrays.sort 实现原理和 Collections 实现原理"></a>9、Arrays.sort 实现原理和 Collections 实现原理</h3><p>事实上Collections.sort方法底层就是调用的array.sort方法，而且不论是Collections.sort或者是Arrays.sort方法，<br>不论是Collections.sort方法或者是Arrays.sort方法，底层实现都是TimSort实现的，这是jdk1.7新增的，以前是归并排序。TimSort算法就是找到已经排好序数据的子序列，然后对剩余部分排序，然后合并起来</p><h3 id="10、LinkedHashMap的应用"><a href="#10、LinkedHashMap的应用" class="headerlink" title="10、LinkedHashMap的应用"></a>10、LinkedHashMap的应用</h3><p>LinkedHashMap是HashMap的子类，但是内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于双向链表中。LinkedHashMap支持两种顺序插入顺序 、 访问顺序</p><p>插入顺序：先添加的在前面，后添加的在后面。修改操作不影响顺序<br>访问顺序：所谓访问指的是get/put操作，对一个键执行get/put操作后，其对应的键值对会移动到链表末尾，所以最末尾的是最近访问的，最开始的是最久没有被访问的，这就是访问顺序。</p><p>可以设置访问顺序用做JVM LRU缓存</p><h3 id="11、cloneable接口实现原理"><a href="#11、cloneable接口实现原理" class="headerlink" title="11、cloneable接口实现原理"></a>11、cloneable接口实现原理</h3><p>Cloneable是一个标记接口，里面没有任何的方法。<br>java的一个类，如果要使用Cloneable实现拷贝功能，需要先实现这个接口，然后重写Object的clone方法。对于类中的引用类型的属性，需要在clone方法中实现深拷贝，否则就是浅拷贝。</p><h3 id="12、异常分类以及处理机制"><a href="#12、异常分类以及处理机制" class="headerlink" title="12、异常分类以及处理机制"></a>12、异常分类以及处理机制</h3><p>异常的分类：<br>　Throwable是根接口。<br>　Error和Exception继承这个接口 。<br>　　Error是无法处理的异常，比如OutOfMemoryError，一般发生这种异常，JVM会选择终止程序。因此我们编写程序时不需要关心这类异常。<br>　　Exception，也就是我们经常见到的一些异常情况，这些异常是我们可以处理的异常，是所有异常类的父类。<br>　　RuntimeException和checked exception(受査异常也称非运行时异常)继承Exception<br>　　 unchecked Exception(非受査异常)，包括Error和RuntimeException，比如常见的NullPointerException、IndexOutOfBoundsException。对于RuntimeException，java编译器不要求必须进行异常捕获处理或者抛出 声明，由程序员自行决定。<br>　　checked exception（受查异常），也称非运行时异常（运行时异常以外的异常就是非运行时异常），由代 码能力之外的因素导致的运行时错误。java编译器强制程序员必须进行捕获处理，比如常见的有IOExeption 和SQLException。如果不进行捕获或者抛出声明处理，编译都不会通过。<br>处理机制:<br>捕获机制：try-catch-finally<br>try-监控区域，执行可能产生异常的代码<br>catch-捕获，处理异常<br>finally-善后处理，无论是否发生异常，代码总能执行<br>抛出异常：throw 手动抛出异常<br>声明异常：throws 声明方法可能要抛出的异常<br>throw：手动抛出异常，一般由程序员在方法内抛出Exception的子类异常。<br>throws：声明在方法名之后，告诉调用者，该方法可能会抛出异常，也就是说异常发生后会抛给调用者，由 调用者处理异常。</p><p>请写出5种常见到的runtime exception<br>常见的几种如下：<br>NullPointerException - 空指针引用异常<br>ClassCastException - 类型强制转换异常。<br>IllegalArgumentException - 传递非法参数异常。<br>ArithmeticException - 算术运算异常<br>ArrayStoreException - 向数组中存放与声明类型不兼容对象异常<br>IndexOutOfBoundsException - 下标越界异常<br>NegativeArraySizeException - 创建一个大小为负数的数组错误异常<br>NumberFormatException - 数字格式异常<br>SecurityException - 安全异常<br>UnsupportedOperationException - 不支持的操作异常</p><h3 id="13、数组在内存中如何分配"><a href="#13、数组在内存中如何分配" class="headerlink" title="13、数组在内存中如何分配"></a>13、数组在内存中如何分配</h3><h3 id="14-io的模型和nio-selectionkey是什么"><a href="#14-io的模型和nio-selectionkey是什么" class="headerlink" title="14.io的模型和nio selectionkey是什么"></a>14.io的模型和nio selectionkey是什么</h3><h2 id="多线程："><a href="#多线程：" class="headerlink" title="多线程："></a>多线程：</h2><h3 id="1-什么是多线程，多线程的目的是什么？"><a href="#1-什么是多线程，多线程的目的是什么？" class="headerlink" title="1.什么是多线程，多线程的目的是什么？"></a>1.什么是多线程，多线程的目的是什么？</h3><p>1、避免阻塞（异步调用）<br>2、避免CPU空转<br>3、提升性能</p><h3 id="2-什么是线程安全，非线程安全？"><a href="#2-什么是线程安全，非线程安全？" class="headerlink" title="2.什么是线程安全，非线程安全？"></a>2.什么是线程安全，非线程安全？</h3><p>在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p><h3 id="3-线程的有那几个状态以及相互间的转换"><a href="#3-线程的有那几个状态以及相互间的转换" class="headerlink" title="3.线程的有那几个状态以及相互间的转换"></a>3.线程的有那几个状态以及相互间的转换</h3><p>创建<br>一般就是创建一个方法继承thread或实现runable方法的类，通过new来创建了。<br>就绪<br>当一个线程调用了start方法后，还没有获取到cpu线程。<br>运行<br>当就绪状态的线程获取到cpu后，便开始运行。<br>阻塞<br>当运行时的线程调用wait、sleep、join等方法后便进入阻塞状态，当线程重新被唤醒时，就会进入就绪或运行。<br>死亡<br>当线程的run方法执行完成后，或调用stop方法后就会死亡。</p><h3 id="4-wait-notify为什么必须存在于synchronized块中？"><a href="#4-wait-notify为什么必须存在于synchronized块中？" class="headerlink" title="4.wait/notify为什么必须存在于synchronized块中？"></a>4.wait/notify为什么必须存在于synchronized块中？</h3><p>也就是说wait/notify是线程之间的通信，他们存在竞态，我们必须保证在满足条件的情况下才进行wait。换句话说，如果不加锁的话，那么wait被调用的时候可能wait的条件已经不满足了(如上述)。由于错误的条件下进行了wait，那么就有可能永远不会被notify到，所以我们需要强制wait/notify在synchronized中</p><h3 id="5-多线程volatile关键字的作用？"><a href="#5-多线程volatile关键字的作用？" class="headerlink" title="5.多线程volatile关键字的作用？"></a>5.多线程volatile关键字的作用？</h3><p>volatile——Java虚拟机提供的最轻量级的同步机制。这个关键字的作用就是告诉编译器，只要是被此关键字修饰的变量都是易变的、不稳定的。<br> volatile特性之一：<br> 保证变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。<br> volatile特性之二：<br> 阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。</p><h3 id="6-Runnable，Thread，Callable三者的区别？"><a href="#6-Runnable，Thread，Callable三者的区别？" class="headerlink" title="6.Runnable，Thread，Callable三者的区别？"></a>6.Runnable，Thread，Callable三者的区别？</h3><p>Java中实现多线程有3种方法：<br>继承Thread类<br>实现Runnable接口<br>实现Callable接口(参考&lt;Java编程思想(第4版)&gt; 21.2.4章节，原来一直以为是2种，后来发现是3种)</p><p>Thread是继承重写run方法,可以直接执行start方法启动线程<br>Runnable是实现接口,本身不带线程启动方法,需要丢到Thread或者线程池里执行<br>Runnable是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成的能返回一个值，那么可以实现Callable接口而不是Runnable接口。在Java SE5中引入的Callable是一种具有类型参数的泛型，它的参数类型表示的是从方法call()(不是run())中返回的值。<br>总结<br>实现Runnable接口相比继承Thread类有如下优势：</p><p>可以避免由于Java的单继承特性而带来的局限；<br>增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；<br>适合多个相同程序代码的线程区处理同一资源的情况。</p><p>实现Runnable接口和实现Callable接口的区别:<br>Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的<br>Callable规定的方法是call(),Runnable规定的方法是run()<br>Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)<br>call方法可以抛出异常，run方法不可以<br>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。<br>加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。</p><h3 id="7-ThreadLocal-的作用，怎么使用它？"><a href="#7-ThreadLocal-的作用，怎么使用它？" class="headerlink" title="7.ThreadLocal 的作用，怎么使用它？"></a>7.ThreadLocal 的作用，怎么使用它？</h3><p>在每个线程中存储一个变量的副本，这样在每个线程对该变量进行使用的使用，使用的即是该线程的局部变量，从而保证了线程的安全性以及高效性。</p><p>ThreadLocal的使用场景：<br>在并发编程中时常有这样一种需求：每条线程都需要存取一个同名变量，但每条线程中该变量的值均不相同。比如后台系统登录账号信息</p><h3 id="8-Lock与synchronized的区别？"><a href="#8-Lock与synchronized的区别？" class="headerlink" title="8.Lock与synchronized的区别？"></a>8.Lock与synchronized的区别？</h3><p>1.　　Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定。<br>　　 但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将 unLock()放到finally{} 中；<br>2.　　synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；<br>　　　而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；<br>3.　　Lock可以让等待锁的线程响应中断，线程可以中断去干别的事务，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断<br>4.　　通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。<br>5.　　Lock可以提高多个线程进行读操作的效率。</p><h3 id="9-请对比hashTable-concurrentHashMap-HashMap的区别？"><a href="#9-请对比hashTable-concurrentHashMap-HashMap的区别？" class="headerlink" title="9.请对比hashTable , concurrentHashMap, HashMap的区别？"></a>9.请对比hashTable , concurrentHashMap, HashMap的区别？</h3><p>HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。<br>HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。<br>HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。<br>Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。<br>最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。</p><h3 id="10-什么是线程死锁？产生的原因？如何避免死锁？"><a href="#10-什么是线程死锁？产生的原因？如何避免死锁？" class="headerlink" title="10.什么是线程死锁？产生的原因？如何避免死锁？"></a>10.什么是线程死锁？产生的原因？如何避免死锁？</h3><h3 id="11-什么是Executors框架？"><a href="#11-什么是Executors框架？" class="headerlink" title="11.什么是Executors框架？"></a>11.什么是Executors框架？</h3><h3 id="12-什么是Callable和Future"><a href="#12-什么是Callable和Future" class="headerlink" title="12.什么是Callable和Future?"></a>12.什么是Callable和Future?</h3><h3 id="13-在静态方法上使用同步时会发生什么事？"><a href="#13-在静态方法上使用同步时会发生什么事？" class="headerlink" title="13.在静态方法上使用同步时会发生什么事？"></a>13.在静态方法上使用同步时会发生什么事？</h3><p>同步静态方法时会获取该类的“Class”对象，所以当一个线程进入同步的静态方法中时，线程监视器获取类本身的对象锁，其它线程不能进入这个类的任何静态同步方法。它不像实例方法，因为多个线程可以同时访问不同实例同步实例方法。</p><h3 id="14-什么是线程饿死，什么是活锁？"><a href="#14-什么是线程饿死，什么是活锁？" class="headerlink" title="14.什么是线程饿死，什么是活锁？"></a>14.什么是线程饿死，什么是活锁？</h3><h2 id="线程池："><a href="#线程池：" class="headerlink" title="线程池："></a>线程池：</h2><h3 id="1-解释线程池的作用？"><a href="#1-解释线程池的作用？" class="headerlink" title="1.解释线程池的作用？"></a>1.解释线程池的作用？</h3><p>1）降低资源消耗；2）提高响应速度；3）提高线程的可管理性。<br>线程的创建和销毁的开销是巨大的，而通过线程池的重用大大减少了这些不必要的开销，当然既然少了这么多消费内存的开销，其线程执行速度也是突飞猛进的提升。</p><p>并发：在某个时间段内，多个程序都处在执行和执行完毕之间；但在一个时间点上只有一个程序在运行。头脑风暴：老鹰妈妈喂小雏鹰食物，小雏鹰很多，而老鹰只有一张嘴，她需要一个个喂过去，到最后每个小雏鹰都可以吃到，但是在一个时间点里只能有一个小雏鹰可以吃到美味的食物。</p><p>并行：在某个时间段里，每个程序按照自己独立异步的速度执行，程序之间互不干扰。头脑风暴：这就好似老鹰妈妈决定这样喂食太费劲于是为每个小雏鹰请了个保姆，这样子在一个时间点里，每个小雏鹰都可以同时吃到食物，而且互相不干扰。</p><h3 id="2-线程池的处理流程？"><a href="#2-线程池的处理流程？" class="headerlink" title="2.线程池的处理流程？"></a>2.线程池的处理流程？</h3><p><img src="/images/loading.png" data-original="/images/pasted-11.png" alt="upload successful"><br>线程池优先要创建出基本线程池大小（corePoolSize）的线程数量，没有达到这个数量时，每次提交新任务都会直接创建一个新线程，当达到了基本线程数量后，又有新任务到达，优先放入等待队列，如果队列满了，才去创建新的线程（不能超过线程池的最大数maxmumPoolSize）</p><h3 id="3-jdk提供的线程池工具类有哪些，区别是什么？"><a href="#3-jdk提供的线程池工具类有哪些，区别是什么？" class="headerlink" title="3.jdk提供的线程池工具类有哪些，区别是什么？"></a>3.jdk提供的线程池工具类有哪些，区别是什么？</h3><p>newFixedThreadPool<br>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</p><p>newCachedThreadPool<br>创建一个可缓存的线程池。这种类型的线程池特点是：<br>1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。<br>2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p><p>newSingleThreadExecutor<br>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。</p><p>newScheduleThreadPool<br>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。(这种线程池原理暂还没完全了解透彻)</p><h3 id="4-关闭线程池的方法有哪些？区别是什么？"><a href="#4-关闭线程池的方法有哪些？区别是什么？" class="headerlink" title="4.关闭线程池的方法有哪些？区别是什么？"></a>4.关闭线程池的方法有哪些？区别是什么？</h3><p>一种是调用其shutdown()方法，另一种是调用shutdownNow()方法<br>shutdown:<br>1、调用之后不允许继续往线程池内继续添加线程;<br>2、线程池的状态变为SHUTDOWN状态;<br>3、所有在调用shutdown()方法之前提交到ExecutorSrvice的任务都会执行;<br>4、一旦所有线程结束执行当前任务，ExecutorService才会真正关闭。</p><p>shutdownNow():<br>1、该方法返回尚未执行的 task 的 List;<br>2、线程池的状态变为STOP状态;<br>3、阻止所有正在等待启动的任务, 并且停止当前正在执行的任务。</p><p>简单点来说，就是:<br>shutdown()调用后，不可以再 submit 新的 task，已经 submit 的将继续执行<br>shutdownNow()调用后，试图停止当前正在执行的 task，并返回尚未执行的 task 的 list</p><h2 id="MySqL："><a href="#MySqL：" class="headerlink" title="MySqL："></a>MySqL：</h2><h3 id="1-sql优化方法？"><a href="#1-sql优化方法？" class="headerlink" title="1.sql优化方法？"></a>1.sql优化方法？</h3><h3 id="2-建索引有哪些策略和原则？"><a href="#2-建索引有哪些策略和原则？" class="headerlink" title="2.建索引有哪些策略和原则？"></a>2.建索引有哪些策略和原则？</h3><h3 id="3-索引存储原理？"><a href="#3-索引存储原理？" class="headerlink" title="3.索引存储原理？"></a>3.索引存储原理？</h3><h3 id="4-mysql数据库锁有哪几种？"><a href="#4-mysql数据库锁有哪几种？" class="headerlink" title="4.mysql数据库锁有哪几种？"></a>4.mysql数据库锁有哪几种？</h3><h3 id="5-写一个数据库死锁的sql？"><a href="#5-写一个数据库死锁的sql？" class="headerlink" title="5.写一个数据库死锁的sql？"></a>5.写一个数据库死锁的sql？</h3><h3 id="6-如何做数据库分库分表？（mycat）"><a href="#6-如何做数据库分库分表？（mycat）" class="headerlink" title="6.如何做数据库分库分表？（mycat）"></a>6.如何做数据库分库分表？（mycat）</h3><h2 id="消息队列："><a href="#消息队列：" class="headerlink" title="消息队列："></a>消息队列：</h2><h3 id="1-RabbitMQ的exchange有哪几种？"><a href="#1-RabbitMQ的exchange有哪几种？" class="headerlink" title="1.RabbitMQ的exchange有哪几种？"></a>1.RabbitMQ的exchange有哪几种？</h3><h3 id="2-mq的使用场景有哪些？"><a href="#2-mq的使用场景有哪些？" class="headerlink" title="2.mq的使用场景有哪些？"></a>2.mq的使用场景有哪些？</h3><h3 id="3-RabbitMQ的系统架构？"><a href="#3-RabbitMQ的系统架构？" class="headerlink" title="3.RabbitMQ的系统架构？"></a>3.RabbitMQ的系统架构？</h3><h3 id="4-RabbitMQ的任务分发机制有哪些？"><a href="#4-RabbitMQ的任务分发机制有哪些？" class="headerlink" title="4.RabbitMQ的任务分发机制有哪些？"></a>4.RabbitMQ的任务分发机制有哪些？</h3><h2 id="Redis："><a href="#Redis：" class="headerlink" title="Redis："></a>Redis：</h2><h3 id="1-使用redis有哪些好处"><a href="#1-使用redis有哪些好处" class="headerlink" title="1.使用redis有哪些好处?"></a>1.使用redis有哪些好处?</h3><h3 id="2-redis相比memcached有哪些优势？"><a href="#2-redis相比memcached有哪些优势？" class="headerlink" title="2.redis相比memcached有哪些优势？"></a>2.redis相比memcached有哪些优势？</h3><h3 id="3-redis常见性能问题和解决方案"><a href="#3-redis常见性能问题和解决方案" class="headerlink" title="3.redis常见性能问题和解决方案?"></a>3.redis常见性能问题和解决方案?</h3><h3 id="4-redis集群有哪些模式？"><a href="#4-redis集群有哪些模式？" class="headerlink" title="4.redis集群有哪些模式？"></a>4.redis集群有哪些模式？</h3><h3 id="5-redis中穿透，击穿与雪崩的预防及解决？"><a href="#5-redis中穿透，击穿与雪崩的预防及解决？" class="headerlink" title="5.redis中穿透，击穿与雪崩的预防及解决？"></a>5.redis中穿透，击穿与雪崩的预防及解决？</h3><h3 id="6-redis哨兵模式集群的原理？"><a href="#6-redis哨兵模式集群的原理？" class="headerlink" title="6.redis哨兵模式集群的原理？"></a>6.redis哨兵模式集群的原理？</h3><h2 id="Spring："><a href="#Spring：" class="headerlink" title="Spring："></a>Spring：</h2><h3 id="1-IOC和AOP的实现原理？"><a href="#1-IOC和AOP的实现原理？" class="headerlink" title="1.IOC和AOP的实现原理？"></a>1.IOC和AOP的实现原理？</h3><h3 id="2-AOP的应用场景有哪些？以及动态代理原理是什么？"><a href="#2-AOP的应用场景有哪些？以及动态代理原理是什么？" class="headerlink" title="2.AOP的应用场景有哪些？以及动态代理原理是什么？"></a>2.AOP的应用场景有哪些？以及动态代理原理是什么？</h3><h3 id="3-事务的传播属性有哪几种？"><a href="#3-事务的传播属性有哪几种？" class="headerlink" title="3.事务的传播属性有哪几种？"></a>3.事务的传播属性有哪几种？</h3><h3 id="4-bean的生命周期？"><a href="#4-bean的生命周期？" class="headerlink" title="4.bean的生命周期？"></a>4.bean的生命周期？</h3><h3 id="5-Spring有哪些模块，分别有哪些作用和功能？"><a href="#5-Spring有哪些模块，分别有哪些作用和功能？" class="headerlink" title="5.Spring有哪些模块，分别有哪些作用和功能？"></a>5.Spring有哪些模块，分别有哪些作用和功能？</h3><h2 id="SpringMVC："><a href="#SpringMVC：" class="headerlink" title="SpringMVC："></a>SpringMVC：</h2><h3 id="1-SpringMVC的工作原理，举例说明流程？"><a href="#1-SpringMVC的工作原理，举例说明流程？" class="headerlink" title="1.SpringMVC的工作原理，举例说明流程？"></a>1.SpringMVC的工作原理，举例说明流程？</h3><h2 id="MyBatis："><a href="#MyBatis：" class="headerlink" title="MyBatis："></a>MyBatis：</h2><h3 id="1-Mybatis的二级缓存？"><a href="#1-Mybatis的二级缓存？" class="headerlink" title="1.Mybatis的二级缓存？"></a>1.Mybatis的二级缓存？</h3><h2 id="Zookeeper："><a href="#Zookeeper：" class="headerlink" title="Zookeeper："></a>Zookeeper：</h2><h3 id="1-zk的作用和原理？"><a href="#1-zk的作用和原理？" class="headerlink" title="1.zk的作用和原理？"></a>1.zk的作用和原理？</h3><h3 id="2-zk设计要满足哪些特性？分别解释一下？"><a href="#2-zk设计要满足哪些特性？分别解释一下？" class="headerlink" title="2.zk设计要满足哪些特性？分别解释一下？"></a>2.zk设计要满足哪些特性？分别解释一下？</h3><h3 id="3-zk的选举机制是什么？是否有了解Paxos算法？"><a href="#3-zk的选举机制是什么？是否有了解Paxos算法？" class="headerlink" title="3.zk的选举机制是什么？是否有了解Paxos算法？"></a>3.zk的选举机制是什么？是否有了解Paxos算法？</h3><h2 id="Nginx："><a href="#Nginx：" class="headerlink" title="Nginx："></a>Nginx：</h2><h3 id="1-什么是Nginx？Nginx的作用是什么？"><a href="#1-什么是Nginx？Nginx的作用是什么？" class="headerlink" title="1.什么是Nginx？Nginx的作用是什么？"></a>1.什么是Nginx？Nginx的作用是什么？</h3><h3 id="2-Nginx-有哪些特点？"><a href="#2-Nginx-有哪些特点？" class="headerlink" title="2.Nginx 有哪些特点？"></a>2.Nginx 有哪些特点？</h3><h2 id="分布式："><a href="#分布式：" class="headerlink" title="分布式："></a>分布式：</h2><h3 id="1-什么是分布式系统？解决什么问题？"><a href="#1-什么是分布式系统？解决什么问题？" class="headerlink" title="1.什么是分布式系统？解决什么问题？"></a>1.什么是分布式系统？解决什么问题？</h3><h3 id="2-如何提升系统吞吐量？"><a href="#2-如何提升系统吞吐量？" class="headerlink" title="2.如何提升系统吞吐量？"></a>2.如何提升系统吞吐量？</h3><h3 id="3-如何降低延迟？"><a href="#3-如何降低延迟？" class="headerlink" title="3.如何降低延迟？"></a>3.如何降低延迟？</h3><h3 id="4-如何做故障恢复？"><a href="#4-如何做故障恢复？" class="headerlink" title="4.如何做故障恢复？"></a>4.如何做故障恢复？</h3><h3 id="5-如何做日志统一系统？"><a href="#5-如何做日志统一系统？" class="headerlink" title="5.如何做日志统一系统？"></a>5.如何做日志统一系统？</h3><h3 id="6-怎么实现通讯编程？如rpc服务，webService服务等；"><a href="#6-怎么实现通讯编程？如rpc服务，webService服务等；" class="headerlink" title="6.怎么实现通讯编程？如rpc服务，webService服务等；"></a>6.怎么实现通讯编程？如rpc服务，webService服务等；</h3><h3 id="7-高并发秒杀解决方案有哪些？"><a href="#7-高并发秒杀解决方案有哪些？" class="headerlink" title="7.高并发秒杀解决方案有哪些？"></a>7.高并发秒杀解决方案有哪些？</h3><h3 id="8-分布式系统有哪些优势？"><a href="#8-分布式系统有哪些优势？" class="headerlink" title="8.分布式系统有哪些优势？"></a>8.分布式系统有哪些优势？</h3><h3 id="9-分布式系统会面临什么挑战？"><a href="#9-分布式系统会面临什么挑战？" class="headerlink" title="9.分布式系统会面临什么挑战？"></a>9.分布式系统会面临什么挑战？</h3><h3 id="10-如何设计分布式系统？"><a href="#10-如何设计分布式系统？" class="headerlink" title="10.如何设计分布式系统？"></a>10.如何设计分布式系统？</h3><h3 id="11-如何做分布式事务？"><a href="#11-如何做分布式事务？" class="headerlink" title="11.如何做分布式事务？"></a>11.如何做分布式事务？</h3><h2 id="其他问题："><a href="#其他问题：" class="headerlink" title="其他问题："></a>其他问题：</h2><h3 id="1-如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？"><a href="#1-如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？" class="headerlink" title="1.如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？"></a>1.如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？</h3><h3 id="2-如何支持大量流量的访问？可以在哪些地方进行优化？"><a href="#2-如何支持大量流量的访问？可以在哪些地方进行优化？" class="headerlink" title="2.如何支持大量流量的访问？可以在哪些地方进行优化？"></a>2.如何支持大量流量的访问？可以在哪些地方进行优化？</h3><h3 id="3-双11流量怎么控制？"><a href="#3-双11流量怎么控制？" class="headerlink" title="3.双11流量怎么控制？"></a>3.双11流量怎么控制？</h3><h3 id="4-1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）"><a href="#4-1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）" class="headerlink" title="4.1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）"></a>4.1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）</h3><h3 id="5-分布式环境下，如何对一个web请求的做监控？"><a href="#5-分布式环境下，如何对一个web请求的做监控？" class="headerlink" title="5.分布式环境下，如何对一个web请求的做监控？"></a>5.分布式环境下，如何对一个web请求的做监控？</h3></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-heartbeat"></i>感谢您的阅读-------------</div></div></div><div class="reward-container"><div>贫穷使我面目全非</div> <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';"> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/images/loading.png" data-original="/images/wechatpay.png" alt="LZZ 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/images/loading.png" data-original="/images/alipay.png" alt="LZZ 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/archives/b0de6b16.html" rel="prev" title="Java程序员Chrome浏览器必装插件"><i class="fa fa-chevron-left"></i> Java程序员Chrome浏览器必装插件</a></div><div class="post-nav-item"></div></div></footer></article></div></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#java基础："><span class="nav-number">1.</span> <span class="nav-text">java基础：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HashMap的数据结构是什么？"><span class="nav-number">1.1.</span> <span class="nav-text">1.HashMap的数据结构是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、HashSet-是如何保证不重复的"><span class="nav-number">1.2.</span> <span class="nav-text">2、HashSet 是如何保证不重复的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）"><span class="nav-number">1.3.</span> <span class="nav-text">3、HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、HashMap-的扩容过程"><span class="nav-number">1.4.</span> <span class="nav-text">4、HashMap 的扩容过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？"><span class="nav-number">1.5.</span> <span class="nav-text">5、HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、final-finally-finalize"><span class="nav-number">1.6.</span> <span class="nav-text">6、final finally finalize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、强引用-、软引用、-弱引用、虚引用"><span class="nav-number">1.7.</span> <span class="nav-text">7、强引用 、软引用、 弱引用、虚引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、Java反射的实现原理"><span class="nav-number">1.8.</span> <span class="nav-text">8、Java反射的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、Arrays-sort-实现原理和-Collections-实现原理"><span class="nav-number">1.9.</span> <span class="nav-text">9、Arrays.sort 实现原理和 Collections 实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、LinkedHashMap的应用"><span class="nav-number">1.10.</span> <span class="nav-text">10、LinkedHashMap的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11、cloneable接口实现原理"><span class="nav-number">1.11.</span> <span class="nav-text">11、cloneable接口实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12、异常分类以及处理机制"><span class="nav-number">1.12.</span> <span class="nav-text">12、异常分类以及处理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13、数组在内存中如何分配"><span class="nav-number">1.13.</span> <span class="nav-text">13、数组在内存中如何分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-io的模型和nio-selectionkey是什么"><span class="nav-number">1.14.</span> <span class="nav-text">14.io的模型和nio selectionkey是什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程："><span class="nav-number">2.</span> <span class="nav-text">多线程：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-什么是多线程，多线程的目的是什么？"><span class="nav-number">2.1.</span> <span class="nav-text">1.什么是多线程，多线程的目的是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-什么是线程安全，非线程安全？"><span class="nav-number">2.2.</span> <span class="nav-text">2.什么是线程安全，非线程安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-线程的有那几个状态以及相互间的转换"><span class="nav-number">2.3.</span> <span class="nav-text">3.线程的有那几个状态以及相互间的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-wait-notify为什么必须存在于synchronized块中？"><span class="nav-number">2.4.</span> <span class="nav-text">4.wait/notify为什么必须存在于synchronized块中？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-多线程volatile关键字的作用？"><span class="nav-number">2.5.</span> <span class="nav-text">5.多线程volatile关键字的作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Runnable，Thread，Callable三者的区别？"><span class="nav-number">2.6.</span> <span class="nav-text">6.Runnable，Thread，Callable三者的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-ThreadLocal-的作用，怎么使用它？"><span class="nav-number">2.7.</span> <span class="nav-text">7.ThreadLocal 的作用，怎么使用它？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Lock与synchronized的区别？"><span class="nav-number">2.8.</span> <span class="nav-text">8.Lock与synchronized的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-请对比hashTable-concurrentHashMap-HashMap的区别？"><span class="nav-number">2.9.</span> <span class="nav-text">9.请对比hashTable , concurrentHashMap, HashMap的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-什么是线程死锁？产生的原因？如何避免死锁？"><span class="nav-number">2.10.</span> <span class="nav-text">10.什么是线程死锁？产生的原因？如何避免死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-什么是Executors框架？"><span class="nav-number">2.11.</span> <span class="nav-text">11.什么是Executors框架？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-什么是Callable和Future"><span class="nav-number">2.12.</span> <span class="nav-text">12.什么是Callable和Future?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-在静态方法上使用同步时会发生什么事？"><span class="nav-number">2.13.</span> <span class="nav-text">13.在静态方法上使用同步时会发生什么事？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-什么是线程饿死，什么是活锁？"><span class="nav-number">2.14.</span> <span class="nav-text">14.什么是线程饿死，什么是活锁？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池："><span class="nav-number">3.</span> <span class="nav-text">线程池：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-解释线程池的作用？"><span class="nav-number">3.1.</span> <span class="nav-text">1.解释线程池的作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-线程池的处理流程？"><span class="nav-number">3.2.</span> <span class="nav-text">2.线程池的处理流程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-jdk提供的线程池工具类有哪些，区别是什么？"><span class="nav-number">3.3.</span> <span class="nav-text">3.jdk提供的线程池工具类有哪些，区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-关闭线程池的方法有哪些？区别是什么？"><span class="nav-number">3.4.</span> <span class="nav-text">4.关闭线程池的方法有哪些？区别是什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySqL："><span class="nav-number">4.</span> <span class="nav-text">MySqL：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-sql优化方法？"><span class="nav-number">4.1.</span> <span class="nav-text">1.sql优化方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-建索引有哪些策略和原则？"><span class="nav-number">4.2.</span> <span class="nav-text">2.建索引有哪些策略和原则？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-索引存储原理？"><span class="nav-number">4.3.</span> <span class="nav-text">3.索引存储原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-mysql数据库锁有哪几种？"><span class="nav-number">4.4.</span> <span class="nav-text">4.mysql数据库锁有哪几种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-写一个数据库死锁的sql？"><span class="nav-number">4.5.</span> <span class="nav-text">5.写一个数据库死锁的sql？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-如何做数据库分库分表？（mycat）"><span class="nav-number">4.6.</span> <span class="nav-text">6.如何做数据库分库分表？（mycat）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息队列："><span class="nav-number">5.</span> <span class="nav-text">消息队列：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-RabbitMQ的exchange有哪几种？"><span class="nav-number">5.1.</span> <span class="nav-text">1.RabbitMQ的exchange有哪几种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-mq的使用场景有哪些？"><span class="nav-number">5.2.</span> <span class="nav-text">2.mq的使用场景有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-RabbitMQ的系统架构？"><span class="nav-number">5.3.</span> <span class="nav-text">3.RabbitMQ的系统架构？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-RabbitMQ的任务分发机制有哪些？"><span class="nav-number">5.4.</span> <span class="nav-text">4.RabbitMQ的任务分发机制有哪些？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis："><span class="nav-number">6.</span> <span class="nav-text">Redis：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-使用redis有哪些好处"><span class="nav-number">6.1.</span> <span class="nav-text">1.使用redis有哪些好处?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-redis相比memcached有哪些优势？"><span class="nav-number">6.2.</span> <span class="nav-text">2.redis相比memcached有哪些优势？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-redis常见性能问题和解决方案"><span class="nav-number">6.3.</span> <span class="nav-text">3.redis常见性能问题和解决方案?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-redis集群有哪些模式？"><span class="nav-number">6.4.</span> <span class="nav-text">4.redis集群有哪些模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-redis中穿透，击穿与雪崩的预防及解决？"><span class="nav-number">6.5.</span> <span class="nav-text">5.redis中穿透，击穿与雪崩的预防及解决？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-redis哨兵模式集群的原理？"><span class="nav-number">6.6.</span> <span class="nav-text">6.redis哨兵模式集群的原理？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring："><span class="nav-number">7.</span> <span class="nav-text">Spring：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-IOC和AOP的实现原理？"><span class="nav-number">7.1.</span> <span class="nav-text">1.IOC和AOP的实现原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-AOP的应用场景有哪些？以及动态代理原理是什么？"><span class="nav-number">7.2.</span> <span class="nav-text">2.AOP的应用场景有哪些？以及动态代理原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-事务的传播属性有哪几种？"><span class="nav-number">7.3.</span> <span class="nav-text">3.事务的传播属性有哪几种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-bean的生命周期？"><span class="nav-number">7.4.</span> <span class="nav-text">4.bean的生命周期？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Spring有哪些模块，分别有哪些作用和功能？"><span class="nav-number">7.5.</span> <span class="nav-text">5.Spring有哪些模块，分别有哪些作用和功能？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC："><span class="nav-number">8.</span> <span class="nav-text">SpringMVC：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-SpringMVC的工作原理，举例说明流程？"><span class="nav-number">8.1.</span> <span class="nav-text">1.SpringMVC的工作原理，举例说明流程？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis："><span class="nav-number">9.</span> <span class="nav-text">MyBatis：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Mybatis的二级缓存？"><span class="nav-number">9.1.</span> <span class="nav-text">1.Mybatis的二级缓存？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper："><span class="nav-number">10.</span> <span class="nav-text">Zookeeper：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-zk的作用和原理？"><span class="nav-number">10.1.</span> <span class="nav-text">1.zk的作用和原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-zk设计要满足哪些特性？分别解释一下？"><span class="nav-number">10.2.</span> <span class="nav-text">2.zk设计要满足哪些特性？分别解释一下？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-zk的选举机制是什么？是否有了解Paxos算法？"><span class="nav-number">10.3.</span> <span class="nav-text">3.zk的选举机制是什么？是否有了解Paxos算法？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx："><span class="nav-number">11.</span> <span class="nav-text">Nginx：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-什么是Nginx？Nginx的作用是什么？"><span class="nav-number">11.1.</span> <span class="nav-text">1.什么是Nginx？Nginx的作用是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Nginx-有哪些特点？"><span class="nav-number">11.2.</span> <span class="nav-text">2.Nginx 有哪些特点？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式："><span class="nav-number">12.</span> <span class="nav-text">分布式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-什么是分布式系统？解决什么问题？"><span class="nav-number">12.1.</span> <span class="nav-text">1.什么是分布式系统？解决什么问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-如何提升系统吞吐量？"><span class="nav-number">12.2.</span> <span class="nav-text">2.如何提升系统吞吐量？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-如何降低延迟？"><span class="nav-number">12.3.</span> <span class="nav-text">3.如何降低延迟？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-如何做故障恢复？"><span class="nav-number">12.4.</span> <span class="nav-text">4.如何做故障恢复？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-如何做日志统一系统？"><span class="nav-number">12.5.</span> <span class="nav-text">5.如何做日志统一系统？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-怎么实现通讯编程？如rpc服务，webService服务等；"><span class="nav-number">12.6.</span> <span class="nav-text">6.怎么实现通讯编程？如rpc服务，webService服务等；</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-高并发秒杀解决方案有哪些？"><span class="nav-number">12.7.</span> <span class="nav-text">7.高并发秒杀解决方案有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-分布式系统有哪些优势？"><span class="nav-number">12.8.</span> <span class="nav-text">8.分布式系统有哪些优势？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-分布式系统会面临什么挑战？"><span class="nav-number">12.9.</span> <span class="nav-text">9.分布式系统会面临什么挑战？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-如何设计分布式系统？"><span class="nav-number">12.10.</span> <span class="nav-text">10.如何设计分布式系统？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-如何做分布式事务？"><span class="nav-number">12.11.</span> <span class="nav-text">11.如何做分布式事务？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他问题："><span class="nav-number">13.</span> <span class="nav-text">其他问题：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？"><span class="nav-number">13.1.</span> <span class="nav-text">1.如何将一个请求由原来的10s减少到3s？可以从哪些地方优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-如何支持大量流量的访问？可以在哪些地方进行优化？"><span class="nav-number">13.2.</span> <span class="nav-text">2.如何支持大量流量的访问？可以在哪些地方进行优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-双11流量怎么控制？"><span class="nav-number">13.3.</span> <span class="nav-text">3.双11流量怎么控制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）"><span class="nav-number">13.4.</span> <span class="nav-text">4.1亿无序的数据文件，如何找出最小的10个数并去重？（topk算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-分布式环境下，如何对一个web请求的做监控？"><span class="nav-number">13.5.</span> <span class="nav-text">5.分布式环境下，如何对一个web请求的做监控？</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="LZZ" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">LZZ</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">10</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="http://iamlzz.cn/" title="Blog → http:&#x2F;&#x2F;iamlzz.cn" rel="noopener" target="_blank"><i class="fa fa-fw fa-home"></i> Blog</a></span><span class="links-of-author-item"><a href="https://itellyoucode.github.io/" title="GitHub → https:&#x2F;&#x2F;itellyoucode.github.io" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://codeif.xinke.org.cn/" title="https:&#x2F;&#x2F;codeif.xinke.org.cn" rel="noopener" target="_blank">CodeIf(变量命名)</a></li><li class="links-of-blogroll-item"> <a href="https://tool.lu/" title="https:&#x2F;&#x2F;tool.lu&#x2F;" rel="noopener" target="_blank">在线工具</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备18096650号</a></div><div class="copyright"> &copy; 2018 – <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">LZZ</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},log:!1,tagMode:!1})</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)0<=(t=c[r].getBoundingClientRect()).top&&0<=t.left&&t.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n()},e.src=i}();var t}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this)</script></body></html>