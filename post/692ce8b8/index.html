<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.ico"><link rel="mask-icon" href="/images/favicon-32.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"wwww.iamlzz.cn",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!1,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="tmp_table_size 临时表 (用于排序)show global status like ‘created_tmp%’;  | Variable_name | Value |  | Created_tmp_disk_tables | 21197 | #在磁盘上创建临时表的次数  | Created_tmp_files | 58 | #在磁盘上创建临时文件的次数"><meta name="keywords" content="mysql"><meta property="og:type" content="article"><meta property="og:title" content="Mysql数据库配置优化"><meta property="og:url" content="https:&#x2F;&#x2F;wwww.iamlzz.cn&#x2F;post&#x2F;692ce8b8&#x2F;index.html"><meta property="og:site_name" content="I Tell You Code"><meta property="og:description" content="tmp_table_size 临时表 (用于排序)show global status like ‘created_tmp%’;  | Variable_name | Value |  | Created_tmp_disk_tables | 21197 | #在磁盘上创建临时表的次数  | Created_tmp_files | 58 | #在磁盘上创建临时文件的次数"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2019-11-24T07:05:32.047Z"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://wwww.iamlzz.cn/post/692ce8b8/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Mysql数据库配置优化 | I Tell You Code</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?044a54c39f1f23e8ae637a69263df4d3";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">I Tell You Code</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wwww.iamlzz.cn/post/692ce8b8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar-my.gif"><meta itemprop="name" content="龙赞正"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="I Tell You Code"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Mysql数据库配置优化</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-11-24 14:16:00 / 修改时间：15:05:32" itemprop="dateCreated datePublished" datetime="2019-11-24T14:16:00+08:00">2019-11-24</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/db/" itemprop="url" rel="index"><span itemprop="name">db</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>11k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>10 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="tmp-table-size-临时表-用于排序"><a href="#tmp-table-size-临时表-用于排序" class="headerlink" title="tmp_table_size 临时表 (用于排序)"></a>tmp_table_size 临时表 (用于排序)</h1><p>show global status like ‘created_tmp%’;</p><p>| Variable_name | Value |</p><p>| Created_tmp_disk_tables | 21197 | #在磁盘上创建临时表的次数</p><p>| Created_tmp_files | 58 | #在磁盘上创建临时文件的次数</p><p>| Created_tmp_tables | 1771587 | #使用临时表的总次数</p><p>TmpTable的状况主要是用于监控MySQL使用临时表的量是否过多，</p><p>是否有临时表过大而不得不从内存中换出到磁盘文件上。</p><p>a.如果：</p><p>Created_tmp_disk_tables/Created_tmp_tables&gt;10%，则需调大tmp_table_size</p><p>比较理想的配置是：</p><p>Created_tmp_disk_tables/Created_tmp_tables&lt;=25%</p><p>b.如果：</p><p>Created_tmp_tables非常大 ，则可能是系统中排序操作过多，或者是表连接方式不是很优化。</p><p>相关参数：</p><p>tmp_table_size 内存中，临时表区域总大小</p><p>max_heap_table_size 内存中，单个临时表的最大值，超过的部分会放到硬盘上。</p><h1 id="连接数"><a href="#连接数" class="headerlink" title="连接数:"></a>连接数:</h1><p>max_connections MySQL最大连接数</p><p>back_log 当连接数满了后，设置一个值，允许多少个连接进入等待堆栈</p><p>max_connect_errors 账号连接到服务器允许的错误次数</p><p>connect_timeout 一个连接报文的最大时间(单位：s)</p><p>skip-name-resolve 加入my.cnf即可，MySQL在收到连接请求的时候，会根据请求包</p><p>中获得的ip来反向追查请求者的主机名。然后再根据返回</p><p>的主机名又一次去获取ip。如果两次获得的ip相同，那么连接就成功建立了。</p><p>加了次参数，即可省去这个步骤</p><p>NOTES:</p><p>查询当前连接数:show global status like ‘connections’;</p><h1 id="table-cache相关优化-："><a href="#table-cache相关优化-：" class="headerlink" title="table cache相关优化 ："></a>table cache相关优化 ：</h1><p>参数table_open_cache，将表的文件描述符打开，cache在内存中</p><p>global status：</p><p>open_tables 当前系统中打开的文件描述符的数量</p><p>opened_tables 系统打开过的文件描述符的数量</p><h1 id="慢查询日志："><a href="#慢查询日志：" class="headerlink" title="慢查询日志："></a>慢查询日志：</h1><p>slow_launch_time=2 查询大于某个时间的值(单位：s)</p><p>slow_query_log=on/off 开启关闭慢查询日志</p><p>slow_query_log_file=/opt/data/xxx.log 慢查询日志位置</p><h1 id="查询缓存-Query-Cache"><a href="#查询缓存-Query-Cache" class="headerlink" title="查询缓存(Query Cache)"></a>查询缓存(Query Cache)</h1><p>将客户端的SQL语句(仅限select语句)通过hash计算，放在hash链表中，同时将该SQL的结果集</p><p>放在内存中cache。该hash链表中，存放了结果集的内存地址以及所涉及到的所有Table等信息。</p><p>如果与该结果集相关的任何一个表的相关信息发生变化后(包扩：数据、索引、表结构等)，</p><p>就会导致结果集失效，释放与该结果集相关的所有资源，以便后面其他SQL能够使用。</p><p>当客户端有select SQL进入，先计算hash值，如果有相同的，就会直接将结果集返回。</p><p>Query Cache的负面影响：</p><p>a.使用了Query Cache后，每条select SQL都要进行hash计算，然后查找结果集。对于大量SQL</p><p>访问，会消耗过多额外的CPU。</p><p>b.如果表变更比较频繁，则会造成结果集失效率非常高。</p><p>c.结果集中保存的是整个结果，可能存在一条记录被多次cache的情况，这样会造成内存资源的</p><p>过度消耗。</p><p>Query Cache的正确使用：</p><p>a.根据表的变更情况来选择是否使用Query Cache，可使用SQL Hint：SQL_NO_CACHE和SQL_CACHE</p><p>b.对于 变更比较少 或 数据基本处于静态 的表，使用SQL_CACHE</p><p>c.对于结果集比较大的，使用Query Cache可能造成内存不足，或挤占内存。</p><p>可使用1.SQL_NO_CACHE 2.query_cache_limit控制Query Cache的最大结果集(系统默认1M)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;%query_cache%&apos;;</span><br><span class="line"></span><br><span class="line">+------------------------------+---------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+------------------------------+---------+</span><br><span class="line"></span><br><span class="line">| have_query_cache | YES | #是否支持Query Cache</span><br><span class="line"></span><br><span class="line">| query_cache_limit | 1048576 | #单个结果集的最大值，默认1M</span><br><span class="line"></span><br><span class="line">| query_cache_min_res_unit | 4096 | #每个结果集存放的最小内存，默认4K</span><br><span class="line"></span><br><span class="line">| query_cache_size | 0 | #Query Cache总内存大小，必须是1024的整数倍</span><br><span class="line"></span><br><span class="line">| query_cache_type | ON | #ON,OFF,DEMAND(包含SQL_CACHE的查询中才开启)</span><br><span class="line"></span><br><span class="line">| query_cache_wlock_invalidate | OFF | </span><br><span class="line"></span><br><span class="line">+------------------------------+---------+</span><br><span class="line"></span><br><span class="line">#query_cache_wlock_invalidate：</span><br></pre></td></tr></table></figure><p>针对于MyISAM存储引擎，设置当有WRITELOCK在某个Table上面的时候，</p><p>读请求是要等待WRITE LOCK释放资源之后再查询还是允许直接从QueryCache中读取结果，</p><p>默认为FALSE（可以直接从QueryCache中取得结果）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;qcache%&apos;;</span><br><span class="line"></span><br><span class="line">+-------------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-------------------------+-------+</span><br><span class="line"></span><br><span class="line">| Qcache_free_blocks | 0 | </span><br><span class="line"></span><br><span class="line">| Qcache_free_memory | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_hits | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_inserts | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_lowmem_prunes | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_not_cached | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_queries_in_cache | 0 |</span><br><span class="line"></span><br><span class="line">| Qcache_total_blocks | 0 |</span><br><span class="line"></span><br><span class="line">+-------------------------+-------+</span><br><span class="line"></span><br><span class="line"># Qcache_free_blocks</span><br></pre></td></tr></table></figure><p>QueryCache中目前还有多少剩余的blocks</p><p>a.如果Qcache_free_blocks值较大，说明Query Cache中内存碎片比较多</p><p>b.如果Qcache_free_blocks约等于Qcache_total_blocks/2，说明内存碎片非常严重</p><p>移除碎片：</p><p>flush query cache;</p><p>这个命令会把所有的存储块向上移动，并把自由块移到底部。</p><p>查询缓存碎片率：</p><p>查询缓存碎片率 = Qcache_free_blocks / Qcache_total_blocks * 100%</p><p>c.如果：</p><p>查询缓存碎片率超过20%， 可以用flush query cache整理碎片，或者减小</p><p>query_cache_min_res_unit(如果该系统的查询都是小数据量的话)</p><h2 id="Qcache-free-memory"><a href="#Qcache-free-memory" class="headerlink" title="Qcache_free_memory"></a>Qcache_free_memory</h2><p>QueryCache中目前剩余的内存大小</p><p>查询缓存利用率：</p><p>查询缓存利用率 = (query_cache_size – Qcache_free_memory) / query_cache_size * 100%</p><p>a.如果：</p><p>查询缓存利用率在25%以下，说明query_cache_size设置过大，可适当减小。</p><p>b.如果：</p><p>查询缓存利用率&gt;80%，且Qcache_lowmem_prunes&gt;50，说明query_cache_size可能有点小，或者</p><p>有太多的碎片</p><h2 id="Qcache-hits"><a href="#Qcache-hits" class="headerlink" title="Qcache_hits"></a>Qcache_hits</h2><p>Query Cache的命中次数，可以看到QueryCache的基本效果；</p><h2 id="Qcache-inserts"><a href="#Qcache-inserts" class="headerlink" title="Qcache_inserts"></a>Qcache_inserts</h2><p>Query Cache未命中然后插入的次数</p><p>Query Cache的命中率：</p><p>=Qcache_hits/(Qcache_hits+Qcache_inserts)</p><h2 id="Qcache-lowmem-prunes"><a href="#Qcache-lowmem-prunes" class="headerlink" title="Qcache_lowmem_prunes"></a>Qcache_lowmem_prunes</h2><p>因为内存不足而被清除出Query Cache的SQL数量。</p><p>如果：</p><p>Qcache_lowmem_prunes的值正在增加，并且有大量的Qcache_free_blocks，</p><p>这意味着碎片导致查询正在被从缓存中永久删除。</p><h2 id="Qcache-not-cached"><a href="#Qcache-not-cached" class="headerlink" title="Qcache_not_cached"></a>Qcache_not_cached</h2><p>因为query_cache_type的设置或者不能被cache的select SQL数量</p><h2 id="Qcache-queries-in-cache"><a href="#Qcache-queries-in-cache" class="headerlink" title="Qcache_queries_in_cache"></a>Qcache_queries_in_cache</h2><p>Query Cache中cache的select SQL数量</p><h2 id="Qcache-total-blocks"><a href="#Qcache-total-blocks" class="headerlink" title="Qcache_total_blocks"></a>Qcache_total_blocks</h2><p>当前Query Cache中block的总数量</p><p>Query Cache限制：</p><p>a) 5.1.17之前的版本不能Cache帮定变量的Query，但是从5.1.17版本开始，QueryCache已经开</p><p>始支持帮定变量的Query了；</p><p>b) 所有子查询中的外部查询SQL不能被Cache；</p><p>c) 在Procedure，Function以及Trigger中的Query不能被Cache；</p><p>d) 包含其他很多每次执行可能得到不一样结果的函数的Query不能被Cache。</p><h1 id="进程的使用情况"><a href="#进程的使用情况" class="headerlink" title="进程的使用情况"></a>进程的使用情况</h1><p>在MySQL中，为了尽可能提高客户端请求创建连接这个过程的性能，实现了一个ThreadCache池，</p><p>将空闲的连接线程存放在其中，而不是完成请求后就销毁。这样，当有新的连接请求的时候，</p><p>MySQL首先会检查ThreadCache池中是否存在空闲连接线程，如果存在则取出来直接使用，</p><p>如果没有空闲连接线程，才创建新的连接线程。</p><p>参数：thread_cache_size</p><p>thread cache 池中存放的最大连接数</p><p>调整参考：</p><p>在短连接的数据库应用中，数据库连接的创建和销毁是非常频繁的，</p><p>如果每次都需要让MySQL新建和销毁相应的连接线程，那么这个资源消耗实际上是非常大的，因此</p><p>thread_cache_size的值应该设置的相对大一些，不应该小于应用系统对数据库的实际并发请求数。</p><p>参数：thread_stack - 每个连接线程被创建的时候，MySQL给他分配的内存大小，</p><p>类似PGA中存放数据的内存部分(不包括排序的空间)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">show status like &apos;connections&apos;;</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Connections | 80 | #接受到的来自客户端的总连接数，包括以前和现在的连接。</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">show status like &apos;thread%&apos;;</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br><span class="line"></span><br><span class="line">| Threads_cached | 0 | #当前系统中，缓存的连接数</span><br><span class="line"></span><br><span class="line">| Threads_connected | 1 | #当前系统中正连接的线程数</span><br><span class="line"></span><br><span class="line">| Threads_created | 77 | #创建过的总线程数</span><br><span class="line"></span><br><span class="line">| Threads_running | 1 | </span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br></pre></td></tr></table></figure><p>a.如果：</p><p>Threads_created 值过大，说明MySQL一直在创建线程，这是比较消耗资源的，应该适当增大</p><p>thread_cache_size的值</p><p>b.如果：</p><p>Threads_cached的值比参数thread_cache_size小太多，则可以适当减小thread_cache_size的值</p><p>ThreadCache命中率：</p><p>Threads_Cache_Hit=(Connections-Threads_created)/Connections*100%</p><p>一般来说，当系统稳定运行一段时间之后，我们的ThreadCache命中率应该保持在90%</p><p>左右甚至更高的比率才算正常。</p><h1 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h1><p>索引缓存大小，是对MyISAM表性能影响最大的一个参数</p><p>32bit平台上，此值不要超过2GB，64bit平台不用做此限制，但也不要超过4GB</p><p>根据3点计算：</p><p>a.系统索引总大小</p><p>b.系统物理内存</p><p>c.系统当前keycache命中率</p><p>粗略计算公式：</p><p>Key_Size =key_number*(key_length+4)/0.67</p><p>Max_key_buffer_size&lt;Max_RAM-QCache_Usage-Threads_Usage-System_Usage</p><p>Threads_Usage = max_connections * (sort_buffer_size + join_buffer_size +</p><p>read_buffer_size+read_rnd_buffer_size+thread_stack)</p><p>key_cache_block_size ，是key_buffer缓存块的单位长度，以字节为单位，默认值为1024。</p><p>key_cache_division_limit 控制着缓存块重用算法。默认值为100，此值为key_buffer_size中暖链所占的大小百分比(其中有暖链和热链)，100意味着全是暖链。(类似于Oracle Data Buffer Cache中的default、keep、recycle)</p><p>key_cache_age_threshold 如果key_buffer里的热链里的某个缓存块在这个变量所设定的时间里没有被访问过，MySQL服务器就会把它调整到暖链里去。这个参数值越大，缓存块在热链里停留的时间就越长。</p><p>这个参数默认值为 300，最小值为100。</p><p>Myisam索引默认是缓存在原始key_buffer中的，我们可以手动创建新的key_buffer，如在my.cnf中加入参数new_cache.key_buffer_size=20M。指定将table1和table2的索引缓存到new_cache的key_buffer中：</p><p>cache index table1,table2 in new_cache;</p><p>(之前默认的key_buffer为default，现在手动创建的为new_cache)</p><p>手动将table1和table2的索引载入到key_buffer中：</p><p>load index into cache table1,table2;</p><p>系统中记录的与Key Cache相关的性能状态参数变量： global status</p><p>l Key_blocks_not_flushed，已经更改但还未刷新到磁盘的DirtyCacheBlock；</p><p>l Key_blocks_unused，目前未被使用的CacheBlock数目；</p><p>l Key_blocks_used，已经使用了的CacheBlock数目；</p><p>l Key_read_requests，CacheBlock被请求读取的总次数；</p><p>l Key_reads，在CacheBlock中找不到需要读取的Key信息后到“.MYI”文件中(磁盘)读取的次数；</p><p>l Key_write_requests，CacheBlock被请求修改的总次数；</p><p>l Key_writes，在CacheBlock中找不到需要修改的Key信息后到“.MYI”文件中读入再修改的次数；</p><p>索引命中缓存率：</p><p>key_buffer_read_hits=(1-Key_reads/Key_read_requests)*100%</p><p>key_buffer_write_hits=(1-Key_writes/Key_write_requests)*100%</p><p>该命中率就代表了MyISAM类型表的索引的cache</p><h1 id="排序使用情况："><a href="#排序使用情况：" class="headerlink" title="排序使用情况："></a>排序使用情况：</h1><p>参数 ：sort_buffer_size - 单个thread能用来排序的内存空间大小，系统默认2M</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;sort%&apos;;</span><br><span class="line"></span><br><span class="line">+------------------+---------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+------------------+---------+</span><br><span class="line"></span><br><span class="line">| sort_buffer_size | 2097144 |</span><br><span class="line"></span><br><span class="line">+------------------+---------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show global status like &apos;sort%&apos;;</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br><span class="line"></span><br><span class="line">| Sort_merge_passes | 0 |#在内存中无法完成排序，而在磁盘上创建临时文件的次数(两倍)</span><br><span class="line"></span><br><span class="line">| Sort_range | 0 |#在范围内执行的排序的数量</span><br><span class="line"></span><br><span class="line">| Sort_rows | 0 |#已经排序的行数</span><br><span class="line"></span><br><span class="line">| Sort_scan | 0 |#通过扫描表完成的排序的数量</span><br><span class="line"></span><br><span class="line">+-------------------+-------+</span><br></pre></td></tr></table></figure><h1 id="表锁情况"><a href="#表锁情况" class="headerlink" title="表锁情况"></a>表锁情况</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;table%&apos;;</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">| Table_locks_immediate | 96 | # 表示立即释放的表锁数</span><br><span class="line"></span><br><span class="line">| Table_locks_waited | 0 | # 表示需要等待的表锁数</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br></pre></td></tr></table></figure><p>如果 Table_locks_immediate / Table_locks_waited &gt; 5000，最好采用InnoDB引擎。</p><p>因为InnoDB是行锁而MyISAM是表锁，对于高并发写入的应用InnoDB效果会好些。</p><h1 id="表扫描情况"><a href="#表扫描情况" class="headerlink" title="表扫描情况"></a>表扫描情况</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;handler_read%&apos;;</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">| Handler_read_first | 60 |</span><br><span class="line"></span><br><span class="line">| Handler_read_key | 2442 |</span><br><span class="line"></span><br><span class="line">| Handler_read_next | 286 |</span><br><span class="line"></span><br><span class="line">| Handler_read_prev | 0 |</span><br><span class="line"></span><br><span class="line">| Handler_read_rnd | 28 |</span><br><span class="line"></span><br><span class="line">| Handler_read_rnd_next | 3191 |</span><br><span class="line"></span><br><span class="line">+-----------------------+-------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show global status like &apos;com_select&apos;;</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Com_select | 23 |</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure><p>计算表扫描率：</p><p>表扫描率 = Handler_read_rnd_next / Com_select</p><p>如果：</p><p>表扫描率超过4000，说明进行了太多表扫描，很有可能索引没有建好，</p><p>增加read_buffer_size值会有一些好处，但最好不要超过8MB。</p><h2 id="Handler-read-first"><a href="#Handler-read-first" class="headerlink" title="Handler_read_first"></a>Handler_read_first</h2><p>此选项表明SQL是在做一个全索引扫描(注意是全部，而不是部分)，所以说如果存在WHERE语句，</p><p>这个值是不会变的。如果这个值的数值很大，既是好事 也是坏事。</p><p>说它好是因为毕竟查询是在索引里完成的，而不是数据文件里，说它坏是因为大数据量时，</p><p>即便是索引文件，做一次完整的扫描也是很费时的。</p><h2 id="Handler-read-key"><a href="#Handler-read-key" class="headerlink" title="Handler_read_key"></a>Handler_read_key</h2><p>此选项数值如果很高，说明系统高效的使用了索引，一切运转良好</p><h1 id="Handler-read-next"><a href="#Handler-read-next" class="headerlink" title="Handler_read_next"></a>Handler_read_next</h1><p>此选项表明在进行索引扫描时，按照索引从数据文件里取数据的次数</p><h2 id="Handler-read-prev"><a href="#Handler-read-prev" class="headerlink" title="Handler_read_prev"></a>Handler_read_prev</h2><p>此选项表明在进行索引扫描时，按照索引倒序从数据文件里取数据的次数，</p><p>一般就是ORDER BY … DESC。</p><h2 id="Handler-read-rnd"><a href="#Handler-read-rnd" class="headerlink" title="Handler_read_rnd"></a>Handler_read_rnd</h2><p>简单的说，就是查询直接操作了数据文件，很多时候表现为没有使用索引或者文件排序</p><p>可能是有大量的全表扫描或连接时没恰当使用keys。</p><p>The number of requests to read a row based on a fixed position. This value is</p><p>high if you are doing a lot of queries that require sorting of the result. You</p><p>probably have a lot of queries that require MySQL to scan entire tables or you</p><p>have joins that do not use keys properly.</p><h2 id="Handler-read-rnd-next"><a href="#Handler-read-rnd-next" class="headerlink" title="Handler_read_rnd_next"></a>Handler_read_rnd_next</h2><p>此选项表明在进行数据文件扫描时，从数据文件里取数据的次数。(物理IO次数)</p><h1 id="MySQL内存分配"><a href="#MySQL内存分配" class="headerlink" title="MySQL内存分配"></a>MySQL内存分配</h1><p>mysql服务器为每个连接上的客户端线程，分配的内存空间：</p><p>read_buffer_size + read_rnd_buffer_size + sort_buffer_size +</p><p>thread_stack + join_buffer_size</p><p>从内存的使用方式MySQL 数据库的内存使用主要分为以下两类</p><p>· 线程独享内存</p><p>· 全局共享内存</p><p>先分析 MySQL 中主要的 “线程独享内存” 的。</p><p>在 MySQL 中，线程独享内存主要用于各客户端连接线程存储各种操作的独享数据，如线程栈信息，分组排序操作，数据读写缓冲，结果集暂存等等，而且大多数可以通过相关参数来控制内存的使用量。</p><p>线程栈信息使用内存(thread_stack)：</p><p>主要用来存放每一个线程自身的标识信息，如线程id，线程运行时基本信息等等，我们可以通过 thread_stack 参数来设置为每一个线程栈分配多大的内存。</p><p>排序使用内存(sort_buffer_size)：</p><p>MySQL 用此内存区域进行排序操作（filesort），完成客户端的排序请求。当我们设置的排序区缓存大小无法满足排序实际所需内存的时候，MySQL 会将数据写入磁盘文件来完成排序。由于磁盘和内存的读写性能完全不在一个数量级，所以sort_buffer_size参数对排序操作的性能影响绝对不可小视。排序操作的实现原理请参考：MySQL Order By 的实现分析(<a href="http://www.kuqin.com/database/20081206/29716.html)。" target="_blank" rel="noopener">http://www.kuqin.com/database/20081206/29716.html)。</a></p><p>Join操作使用内存(join_buffer_size)：</p><p>应用程序经常会出现一些两表（或多表）Join的操作需求，MySQL在完成某些 Join 需求的时候（all/index join），为了减少参与Join的“被驱动表”的读取次数以提高性能，需要使用到 Join Buffer 来协助完成 Join操作（具体 Join 实现算法请参考：</p><p>MySQL 中的 Join 基本实现原理(<a href="http://www.kuqin.com/database/20081206/29717.html)）。当" target="_blank" rel="noopener">http://www.kuqin.com/database/20081206/29717.html)）。当</a> Join Buffer 太小，MySQL 不会将该 Buffer 存入磁盘文件，而是先将Join Buffer中的结果集与需要 Join 的表进行 Join 操作，然后清空 Join Buffer 中的数据，继续将剩余的结果集写入此 Buffer 中，如此往复。这势必会造成被驱动表需要被多次读取，成倍增加 IO 访问，降低效率。</p><p>顺序读取数据缓冲区使用内存(read_buffer_size)：</p><p>这部分内存主要用于当需要顺序读取数据的时候，如无法使用索引的情况下的全表扫描，全索引扫描等。在这种时候，MySQL 按照数据的存储顺序依次读取数据块，每次读取的数据快首先会暂存在read_buffer_size中，当 buffer 空间被写满或者全部数据读取结束后，再将buffer中的数据返回给上层调用者，以提高效率。</p><p>随机读取数据缓冲区使用内存(read_rnd_buffer_size)：</p><p>和顺序读取相对应，当 MySQL 进行非顺序读取（随机读取）数据块的时候，会利用这个缓冲区暂存读取的数据。如根据索引信息读取表数据，根据排序后的结果集与表进行Join等等。总的来说，就是当数据块的读取需要满足一定的顺序的情况下，MySQL 就需要产生随机读取，进而使用到 read_rnd_buffer_size 参数所设置的内存缓冲区。</p><p>连接信息及返回客户端前结果集暂存使用内存(net_buffer_size)：</p><p>这部分用来存放客户端连接线程的连接信息和返回客户端的结果集。当 MySQL 开始产生可以返回的结果集，会在通过网络返回给客户端请求线程之前，会先暂存在通过 net_buffer_size 所设置的缓冲区中，等满足一定大小的时候才开始向客户端发送，以提高网络传输效率。不过，net_buffer_size 参数所设置的仅仅只是该缓存区的初始化大小，MySQL 会根据实际需要自行申请更多的内存以满足需求，但最大不会超过 max_allowed_packet 参数大小。</p><p>批量插入暂存使用内存(bulk_insert_buffer_size)：</p><p>当我们使用如 insert … values(…),(…),(…)… 的方式进行批量插入的时候，MySQL 会先将提交的数据放如一个缓存空间中，当该缓存空间被写满或者提交完所有数据之后，MySQL 才会一次性将该缓存空间中的数据写入数据库并清空缓存。此外，当我们进行 LOAD DATA INFILE 操作来将文本文件中的数据 Load 进数据库的时候，同样会使用到此缓冲区。</p><p>MySQL对硬件的”收益递减点“为256G内存，32CPU。</p><h1 id="dalayed-queue-size"><a href="#dalayed-queue-size" class="headerlink" title="dalayed_queue_size"></a>dalayed_queue_size</h1><p>在被插入到实际的数据表里之前，来自insert delayed语句的数据航将在每个队列里等待</p><p>MySQL来处理他们。delayed_queue_size就是这个队列所能容纳的数据航的最大个数。当</p><p>这个队列满是，后续的insert delayed语句将被阻塞，直到这个队列里有容纳他们的空间</p><p>为止。</p><p>如果有很多客户在发出insert delayed语句以避免受阻塞，但你发现这些语句有阻塞的迹象，</p><p>加大这个变量的值将使更多的insert delayed语句更快地得到处理。</p><h1 id="文件打开数-open-files-limit"><a href="#文件打开数-open-files-limit" class="headerlink" title="文件打开数 open_files_limit"></a>文件打开数 open_files_limit</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;open%&apos;;</span><br><span class="line"></span><br><span class="line">+------------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+------------------+-------+</span><br><span class="line"></span><br><span class="line">| open_files_limit | 1024 | #mysql总共能够打开的文件的数量</span><br><span class="line"></span><br><span class="line">+------------------+-------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show global status like &apos;open%file%&apos;;</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">| Open_files | 79 | # 系统当前打开的文件数</span><br><span class="line"></span><br><span class="line">| Opened_files | 278 | # 系统打开过的文件总数</span><br><span class="line"></span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure><p>比较合适的设置：Open_files / open_files_limit * 100% &lt;= 75%</p></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> LZZ</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://wwww.iamlzz.cn/post/692ce8b8/" title="Mysql数据库配置优化">https://wwww.iamlzz.cn/post/692ce8b8/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/mysql/" rel="tag"><i class="fa fa-tag"></i> mysql</a></div><div class="post-nav"><div class="post-nav-item"><a href="/post/e2c1fb46/" rel="prev" title="为何选择logback+slf4j"><i class="fa fa-chevron-left"></i> 为何选择logback+slf4j</a></div><div class="post-nav-item"> <a href="/post/b77c3e4/" rel="next" title="程序员必须知道的linux命令">程序员必须知道的linux命令<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#tmp-table-size-临时表-用于排序"><span class="nav-text">tmp_table_size 临时表 (用于排序)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#连接数"><span class="nav-text">连接数:</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#table-cache相关优化-："><span class="nav-text">table cache相关优化 ：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#慢查询日志："><span class="nav-text">慢查询日志：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查询缓存-Query-Cache"><span class="nav-text">查询缓存(Query Cache)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Qcache-free-memory"><span class="nav-text">Qcache_free_memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Qcache-hits"><span class="nav-text">Qcache_hits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Qcache-inserts"><span class="nav-text">Qcache_inserts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Qcache-lowmem-prunes"><span class="nav-text">Qcache_lowmem_prunes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Qcache-not-cached"><span class="nav-text">Qcache_not_cached</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Qcache-queries-in-cache"><span class="nav-text">Qcache_queries_in_cache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Qcache-total-blocks"><span class="nav-text">Qcache_total_blocks</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程的使用情况"><span class="nav-text">进程的使用情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#key-buffer-size"><span class="nav-text">key_buffer_size</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序使用情况："><span class="nav-text">排序使用情况：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#表锁情况"><span class="nav-text">表锁情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#表扫描情况"><span class="nav-text">表扫描情况</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler-read-first"><span class="nav-text">Handler_read_first</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler-read-key"><span class="nav-text">Handler_read_key</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Handler-read-next"><span class="nav-text">Handler_read_next</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler-read-prev"><span class="nav-text">Handler_read_prev</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler-read-rnd"><span class="nav-text">Handler_read_rnd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler-read-rnd-next"><span class="nav-text">Handler_read_rnd_next</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL内存分配"><span class="nav-text">MySQL内存分配</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dalayed-queue-size"><span class="nav-text">dalayed_queue_size</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件打开数-open-files-limit"><span class="nav-text">文件打开数 open_files_limit</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="龙赞正" src="/images/avatar-my.gif"><p class="site-author-name" itemprop="name">龙赞正</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/itellyoucode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;itellyoucode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="/mailto:itellyoucode@qq.com" title="E-Mail → mailto:itellyoucode@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备18096650号-2</a> <img src="/images/loading.png" data-original="/images/beian.png" style="display:inline-block"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44010602005510" rel="noopener" target="_blank">粤公网安备44010602005510号</a></div><div class="copyright"> &copy; 2017 – <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">龙赞正</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">51k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">46 分钟</span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},log:!1,tagMode:!1})</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)0<=(t=c[r].getBoundingClientRect()).top&&0<=t.left&&t.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n()},e.src=i}();var t}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this)</script></body></html>